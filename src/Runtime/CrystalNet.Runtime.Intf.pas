unit CrystalNet.Runtime.Intf;

{$I CNCompilerDefines.inc}
{$WARN HIDING_MEMBER OFF}
{$WARN HIDDEN_VIRTUAL OFF}

interface
uses
	CNCoreClrLib.BridgeMgr, CNCoreClrLib.NullableMgr, CNCoreClrLib.CallbackMgr, 
	CrystalNet.Runtime.Consts, CrystalNet.Runtime.Enums, CNCoreClrLib.RttiMgr;

type
{ Forward Declarations }

	IException = interface;
	IVersion = interface;
	IAssemblyName = interface;
	IArraySegment<T> = interface;
	IStream = interface;
	IDecimal = interface;
	IGuid = interface;
	IIEnumerable<T> = interface;
	IMulticastDelegate = interface;
	IIReadOnlyList<T> = interface;
	IEncoding = interface;
	IType = interface;
	ICultureInfo = interface;
	IAttribute = interface;
	IArray = interface;
	IIEnumerator = interface;
	IIList<T> = interface;
	IICollection = interface;
	IIList = interface;
	IEventArgs = interface;
	IAssembly = interface;
	IDelegate = interface;
	IIComparer = interface;
	IIDictionary = interface;
	IMemberInfo = interface;
	IIResourceReader = interface;
	ISerializationInfo = interface;
	IStreamingContext = interface;
	IModule = interface;
	IHashtable = interface;
	ITimeSpan = interface;
	IIAsyncResult = interface;
	IIntPtr = interface;
	ITextWriter = interface;
	ITextReader = interface;
	IValueTuple<T1,T2> = interface;
	ISecureString = interface;
	IStreamReader = interface;
	IStreamWriter = interface;
	ITask = interface;
	ICancellationToken = interface;
	ICollection<T> = interface;
	IIDictionary<TKey,TValue> = interface;
	IFileStream = interface;
	IMethodInfo = interface;
	IReadOnlyCollection<T> = interface;
	IMethodBase = interface;
	IFieldInfo = interface;
	IConstructorInfo = interface;
	IPropertyInfo = interface;
	IIEnumerator<T> = interface;
	IReadOnlyMemory<T> = interface;
	ITask<TResult> = interface;
	IReadOnlySpan<T> = interface;
	IDateTimeOffset = interface;
	IValueTask<TResult> = interface;
	IValueTask = interface;
	IKeyValuePair<TKey,TValue> = interface;
	ISpan<T> = interface;
	IICollection<T> = interface;
	IIObservable<T> = interface;
	IIDisposable = interface;
	IIObserver<T> = interface;
	IMemory<T> = interface;
	IIAsyncEnumerable<T> = interface;
	ISynchronizationContext = interface;
	IIIdentity = interface;
	IIEnumerable = interface;
	IList<T> = interface;
	IIPrincipal = interface;
	IIEqualityComparer<T> = interface;
	IIComparer<T> = interface;
	IDictionary<TKey,TValue> = interface;
	IHashSet<T> = interface;
	IIDictionaryEnumerator = interface;
	IIEqualityComparer = interface;
	IIHashCodeProvider = interface;
	IEnum = interface;
	IIFormatProvider = interface;
	ISecurityElement = interface;
	ISafeHandle = interface;
	IRange = interface;
	IBinaryReader = interface;
	IBinaryWriter = interface;
	ICustomAttributeData = interface;
	IIMoniker = interface;
	IEncoder = interface;
	IDecoder = interface;
	IIMemoryOwner<T> = interface;
	IIReadOnlyDictionary<TKey,TValue> = interface;
	IIProducerConsumerCollection<T> = interface;
	ITuple<T1,T2> = interface;
	IWaitHandle = interface;
	IMutex = interface;
	IBinder = interface;
	IObjectHandle = interface;
	IAdjustmentRule = interface;
	ITransitionTime = interface;
	IVector64<T> = interface;
	IVector128<T> = interface;
	IAggregateException = interface;
	IFirstChanceExceptionEventArgs = interface;
	IUnhandledExceptionEventArgs = interface;
	IAppDomain = interface;
	IAssemblyLoadEventArgs = interface;
	IResolveEventArgs = interface;
	IPermissionSet = interface;
	IAppDomainSetup = interface;
	IApplicationId = interface;
	ITypedReference = interface;
	IRuntimeTypeHandle = interface;
	IRuntimeArgumentHandle = interface;
	IArrayList = interface;
	IArrayPool<T> = interface;
	IArraySegment_Enumerator<T> = interface;
	IArrayWithOffset = interface;
	ITypeInfo = interface;
	IManifestResourceInfo = interface;
	IAssemblyBuilder = interface;
	ICustomAttributeBuilder = interface;
	IModuleBuilder = interface;
	IAssemblyLoadContext = interface;
	IContextualReflectionScope = interface;
	IStrongNameKeyPair = interface;
	IAsyncFlowControl = interface;
	IAsyncIteratorMethodBuilder = interface;
	IAsyncLocalValueChangedArgs<T> = interface;
	IAsyncTaskMethodBuilder = interface;
	IIAsyncStateMachine = interface;
	IAsyncTaskMethodBuilder<TResult> = interface;
	IAsyncValueTaskMethodBuilder = interface;
	IAsyncValueTaskMethodBuilder<TResult> = interface;
	IAsyncVoidMethodBuilder = interface;
	IParameterInfo = interface;
	IVector256<T> = interface;
	IParameterModifier = interface;
	ICalendar = interface;
	ICancellationTokenRegistration = interface;
	ICancellationTokenSource = interface;
	IChunkEnumerator = interface;
	IRune = interface;
	ICompareInfo = interface;
	ISortVersion = interface;
	ISortKey = interface;
	IComparer = interface;
	IComparer<T> = interface;
	ICompressedStack = interface;
	IComWrappers = interface;
	ITaskScheduler = interface;
	IConfiguredValueTaskAwaitable = interface;
	IConfiguredCancelableAsyncEnumerable<T> = interface;
	IConfiguredCancelableAsyncEnumerable_Enumerator<T> = interface;
	IConfiguredValueTaskAwaitable<TResult> = interface;
	IConfiguredTaskAwaiter = interface;
	IConfiguredTaskAwaitable_ConfiguredTaskAwaiter<TResult> = interface;
	IConfiguredValueTaskAwaiter = interface;
	IConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter<TResult> = interface;
	IRuntimeMethodHandle = interface;
	IParameterBuilder = interface;
	IILGenerator = interface;
	IMethodToken = interface;
	IContractFailedEventArgs = interface;
	IDateTimeFormatInfo = interface;
	INumberFormatInfo = interface;
	ITextInfo = interface;
	ICustomAttributeTypedArgument = interface;
	ICustomAttributeNamedArgument = interface;
	IDBNull = interface;
	IDebugProvider = interface;
	IDecoderFallback = interface;
	IDecoderFallbackBuffer = interface;
	IDecoderReplacementFallback = interface;
	IIDLDESC = interface;
	IPARAMDESC = interface;
	IEventSource = interface;
	IDictionary_KeyCollection<TKey,TValue> = interface;
	IDictionary_ValueCollection<TKey,TValue> = interface;
	IDictionary_Enumerator<TKey,TValue> = interface;
	IKeyCollection_Enumerator<TKey,TValue> = interface;
	IValueCollection_Enumerator<TKey,TValue> = interface;
	IDynamicMethod = interface;
	IRuntimeFieldHandle = interface;
	IICustomAttributeProvider = interface;
	IDynamicILInfo = interface;
	IDESCUNION = interface;
	ITYPEDESC = interface;
	IEncoderFallback = interface;
	IEncoderFallbackBuffer = interface;
	IEncoderReplacementFallback = interface;
	IEncodingInfo = interface;
	IEncodingProvider = interface;
	ITypeToken = interface;
	IFieldBuilder = interface;
	IEventInfo = interface;
	IInterfaceMapping = interface;
	IOperatingSystem = interface;
	IEqualityComparer<T> = interface;
	IMethodBuilder = interface;
	IEventToken = interface;
	IEventSourceCreatedEventArgs = interface;
	IEventWrittenEventArgs = interface;
	IEventSourceOptions = interface;
	IEventCommandEventArgs = interface;
	IEventWaitHandle = interface;
	IExceptionDispatchInfo = interface;
	IExecutionContext = interface;
	IFieldToken = interface;
	ISafeFileHandle = interface;
	IFloatingPointInfo = interface;
	IFormattableString = interface;
	IFrameworkName = interface;
	IELEMDESC = interface;
	IWeakReference = interface;
	IGCMemoryInfo = interface;
	IGCHandle = interface;
	IGCGenerationInfo = interface;
	IStringComparer = interface;
	IHalf = interface;
	IHandleRef = interface;
	IHashSet_Enumerator<T> = interface;
	IIAsyncEnumerator<T> = interface;
	IIEnumString = interface;
	IBIND_OPTS = interface;
	IIRunningObjectTable = interface;
	IIEnumConnections = interface;
	IIConnectionPointContainer = interface;
	IIEnumConnectionPoints = interface;
	IIConnectionPoint = interface;
	IMarshalByRefObject = interface;
	IDictionaryEntry = interface;
	ICONNECTDATA = interface;
	IIEnumMoniker = interface;
	IIEnumVARIANT = interface;
	ISignatureHelper = interface;
	ILabel = interface;
	ILocalBuilder = interface;
	IOpCode = interface;
	IISymbolDocumentWriter = interface;
	IIBindCtx = interface;
	IFILETIME = interface;
	IIStream = interface;
	IIndex = interface;
	IIPermission = interface;
	IMemoryHandle = interface;
	ISTATSTG = interface;
	IITypeInfo = interface;
	IBINDPTR = interface;
	IITypeComp = interface;
	IITypeLib = interface;
	IDISPPARAMS = interface;
	IList_Enumerator<T> = interface;
	IVector2 = interface;
	IMatrix3x2 = interface;
	IVector3 = interface;
	IMatrix4x4 = interface;
	IQuaternion = interface;
	IPlane = interface;
	IIComparable<T> = interface;
	ISpanRuneEnumerator = interface;
	IIPinnable = interface;
	IMethodBody = interface;
	IExceptionHandlingClause = interface;
	ILocalVariableInfo = interface;
	IGenericTypeParameterBuilder = interface;
	IMissing = interface;
	IModuleHandle = interface;
	IEnumBuilder = interface;
	ITypeBuilder = interface;
	ISignatureToken = interface;
	IStringToken = interface;
	INullable<T> = interface;
	IOverlapped = interface;
	IParameterToken = interface;
	IVector4 = interface;
	IPropertyToken = interface;
	IReadOnlySpan_Enumerator<T> = interface;
	IReferenceEqualityComparer = interface;
	IRegionInfo = interface;
	IResourceManager = interface;
	IResourceSet = interface;
	IUnmanagedMemoryStream = interface;
	IISafeSerializationData = interface;
	IUIntPtr = interface;
	ISemaphore = interface;
	IDeserializationToken = interface;
	ISerializationInfoEnumerator = interface;
	IIFormatterConverter = interface;
	ISerializationEntry = interface;
	ISpan_Enumerator<T> = interface;
	IStackFrame = interface;
	IStandardFormat = interface;
	IStopwatch = interface;
	IStringRuneEnumerator = interface;
	ICharEnumerator = interface;
	IStringBuilder = interface;
	ITextElementEnumerator = interface;
	ITaskFactory = interface;
	IYieldAwaitable = interface;
	IConfiguredTaskAwaitable = interface;
	ITaskAwaiter = interface;
	ITaskFactory<TResult> = interface;
	IConfiguredTaskAwaitable<TResult> = interface;
	ITaskAwaiter<TResult> = interface;
	IIAsyncDisposable = interface;
	IConfiguredAsyncDisposable = interface;
	IUnobservedTaskExceptionEventArgs = interface;
	IThread = interface;
	ILocalDataStoreSlot = interface;
	IIThreadPoolWorkItem = interface;
	IRegisteredWaitHandle = interface;
	IThreadPoolBoundHandle = interface;
	IPreAllocatedOverlapped = interface;
	ITimeZone = interface;
	IDaylightTime = interface;
	ITimeZoneInfo = interface;
	ITuple<T1> = interface;
	ITuple<T1,T2,T3> = interface;
	ITuple<T1,T2,T3,T4> = interface;
	ITuple<T1,T2,T3,T4,T5> = interface;
	ITuple<T1,T2,T3,T4,T5,T6> = interface;
	ITuple<T1,T2,T3,T4,T5,T6,T7> = interface;
	ITuple<T1,T2,T3,T4,T5,T6,T7,TRest> = interface;
	IValueTuple<T1,T2,T3,T4,T5,T6,T7,TRest> = interface;
	IValueTuple<T1,T2,T3> = interface;
	IValueTuple<T1,T2,T3,T4> = interface;
	IValueTuple<T1,T2,T3,T4,T5> = interface;
	IValueTuple<T1,T2,T3,T4,T5,T6> = interface;
	IValueTuple<T1,T2,T3,T4,T5,T6,T7> = interface;
	IValueTuple<T1> = interface;
	IStructLayoutAttribute = interface;
	IConstructorBuilder = interface;
	IEventBuilder = interface;
	IPropertyBuilder = interface;
	ISafeBuffer = interface;
	IValueTaskAwaiter = interface;
	IIValueTaskSource = interface;
	IValueTaskAwaiter<TResult> = interface;
	IIValueTaskSource<TResult> = interface;
	IValueTuple = interface;
	IDESCUNION_1 = interface;
	IVector<T> = interface;
	ISafeWaitHandle = interface;
	IYieldAwaiter = interface;
	IValueType = interface;
	IObject = interface;

	[CoreTypeSignature(SYSTEM_THREADING_IASYNCLOCAL)]
	IIAsyncLocal = interface(ICoreClrInstance)
	['{F8261947-51A2-45A1-8379-674DEAC83EDD}']
	end;

{	Event Handlers	}

{$M+}
	TComparison<T> = reference to function(x: T; y: T): Integer;
	TConverter<TInput, TOutput> = reference to function(input: TInput): TOutput;
	TAsyncCallback = reference to procedure(ar: IIAsyncResult);
	TContextCallback = reference to procedure(state: ICoreClrInstance);
	TCreateValueCallback<TKey, TValue> = reference to function(key: TKey): TValue;
	TTypeFilter = reference to function(m: IType; filterCriteria: ICoreClrInstance): Boolean;
	TDllImportResolver = reference to function(libraryName: String; assembly: IAssembly; searchPath: Nullable<TDllImportSearchPath_Set>): IIntPtr;
	TIOCompletionCallback = reference to procedure(errorCode: longword; numBytes: longword; pOVERLAP: ICoreClrInstance);
	TTryCode = reference to procedure(userData: ICoreClrInstance);
	TCleanupCode = reference to procedure(userData: ICoreClrInstance; exceptionThrown: Boolean);
	TSpanAction<T, TArg> = reference to procedure(span: ISpan<T>; arg: TArg);
	TSendOrPostCallback = reference to procedure(state: ICoreClrInstance);
	TThreadStart = reference to procedure;
	TParameterizedThreadStart = reference to procedure(obj: ICoreClrInstance);
	TWaitCallback = reference to procedure(state: ICoreClrInstance);
	TWaitOrTimerCallback = reference to procedure(state: ICoreClrInstance; timedOut: Boolean);
	TTimerCallback = reference to procedure(state: ICoreClrInstance);
	TMemberFilter = reference to function(m: IMemberInfo; filterCriteria: ICoreClrInstance): Boolean;
	TEventHandler<TEventArgs> = reference to procedure(sender: ICoreClrInstance; e: TEventArgs);
	TEventHandler = reference to procedure(sender: ICoreClrInstance; e: IEventArgs);
	TUnhandledExceptionEventHandler = reference to procedure(sender: ICoreClrInstance; e: IUnhandledExceptionEventArgs);
	TAssemblyLoadEventHandler = reference to procedure(sender: ICoreClrInstance; args: IAssemblyLoadEventArgs);
	TResolveEventHandler = reference to function(sender: ICoreClrInstance; args: IResolveEventArgs): IAssembly;
	TModuleResolveEventHandler = reference to function(sender: ICoreClrInstance; e: IResolveEventArgs): IModule;
{$M-}

	IObjectClass = interface(ICoreClrClass)
	['{496E8053-EF3B-42DA-99E7-20E076868751}']
	{ public }
		{ class } function Equals(objA: Variant; objB: Variant): Boolean;
		{ class } function ReferenceEquals(objA: Variant; objB: Variant): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_OBJECT_)]
	IObject = interface(ICoreClrInstance)
	['{0D3C6FB0-2A6C-4246-9D74-4FF35A0B28F4}']
	{ public }
		function Equals(obj: Variant): Boolean;
		function GetHashCode(): Integer;
		function GetType(): IType;
		function ToString(): String;
	end;

	[CoreTypeSignature(SYSTEM_MARSHALBYREFOBJECT)]
	IMarshalByRefObject = interface(IObject)
	['{A59999D6-E392-4C54-9CB9-AE8C0A0C28AA}']
	{ public }
		function GetLifetimeService(): Variant;
		function InitializeLifetimeService(): Variant;
	end;

	[CoreTypeSignature(SYSTEM___COMOBJECT)]
	I__ComObject = interface(IMarshalByRefObject)
	['{EC125153-C934-4F7A-B3EF-5C136CF25BDD}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ISERIALIZABLE)]
	IISerializable = interface(IObject)
	['{8117D3BF-FE25-4C06-8AF9-E7268CB09E03}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_EXCEPTION)]
	IException = interface(IISerializable)
	['{3AA31D67-2FBD-4DEF-A9D5-161339B05FED}']
	{ private }
		function _GetProp_Data: IIDictionary;
		function _GetProp_HelpLink: String;
		procedure _SetProp_HelpLink(Value: String);
		function _GetProp_HResult: Integer;
		procedure _SetProp_HResult(Value: Integer);
		function _GetProp_InnerException: IException;
		function _GetProp_Message: String;
		function _GetProp_Source: String;
		procedure _SetProp_Source(Value: String);
		function _GetProp_StackTrace: String;
		function _GetProp_TargetSite: IMethodBase;
	{ public }
		function GetBaseException(): IException;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Data: IIDictionary read _GetProp_Data;
		property HelpLink: String read _GetProp_HelpLink write _SetProp_HelpLink;
		property HResult: Integer read _GetProp_HResult write _SetProp_HResult;
		property InnerException: IException read _GetProp_InnerException;
		property Message: String read _GetProp_Message;
		property Source: String read _GetProp_Source write _SetProp_Source;
		property StackTrace: String read _GetProp_StackTrace;
		property TargetSite: IMethodBase read _GetProp_TargetSite;
	end;

	[CoreTypeSignature(SYSTEM_SYSTEMEXCEPTION)]
	ISystemException = interface(IException)
	['{AC2DDEA5-3DF6-4404-9848-B1D559C33072}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_ABANDONEDMUTEXEXCEPTION)]
	IAbandonedMutexException = interface(ISystemException)
	['{6A7DE482-1855-4772-8CAE-83283FF48C79}']
	{ private }
		function _GetProp_Mutex: IMutex;
		function _GetProp_MutexIndex: Integer;
	{ public }
		property Mutex: IMutex read _GetProp_Mutex;
		property MutexIndex: Integer read _GetProp_MutexIndex;
	end;

	IAttributeClass = interface(ICoreClrClass)
	['{EEDC8841-8FBA-4A10-BDE2-F2A94FB494FA}']
	{ public }
		{ class } function GetCustomAttribute(element: IMemberInfo; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IParameterInfo; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IModule; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IAssembly; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IMemberInfo; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IParameterInfo; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IModule; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IAssembly; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; type_: IType): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; attributeType: IType): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule; attributeType: IType): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IAssembly; attributeType: IType): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IAssembly; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; type_: IType; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; attributeType: IType; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule; attributeType: IType; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IAssembly; attributeType: IType; inherit: Boolean): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule): TArray<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IAssembly): TArray<IAttribute>; overload;
		{ class } function IsDefined(element: IMemberInfo; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IParameterInfo; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IModule; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IAssembly; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IMemberInfo; attributeType: IType; inherit: Boolean): Boolean; overload;
		{ class } function IsDefined(element: IParameterInfo; attributeType: IType; inherit: Boolean): Boolean; overload;
		{ class } function IsDefined(element: IModule; attributeType: IType; inherit: Boolean): Boolean; overload;
		{ class } function IsDefined(element: IAssembly; attributeType: IType; inherit: Boolean): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_ATTRIBUTE)]
	IAttribute = interface(IObject)
	['{9E42D73A-C0A1-4A6A-8E56-04F54FF2B621}']
	{ private }
		function _GetProp_TypeId: Variant;
	{ public }
		function IsDefaultAttribute(): Boolean;
		function Match(obj: Variant): Boolean;
		property TypeId: Variant read _GetProp_TypeId;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ACCESSEDTHROUGHPROPERTYATTRIBUTE)]
	IAccessedThroughPropertyAttribute = interface(IAttribute)
	['{F39E4FE4-557D-4B06-9636-60784A93D28E}']
	{ private }
		function _GetProp_PropertyName: String;
	{ public }
		property PropertyName: String read _GetProp_PropertyName;
	end;

	[CoreTypeSignature(SYSTEM_ACCESSVIOLATIONEXCEPTION)]
	IAccessViolationException = interface(ISystemException)
	['{D7E93154-1D85-4028-942D-B030D90FD220}']
	end;

	IActivatorClass = interface(ICoreClrClass)
	['{46BAF486-00FC-4F4D-806F-DCA6DCE825D5}']
	{ public }
		{ class } function CreateInstance(type_: IType; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		{ class } function CreateInstance(type_: IType; args: TArray<Variant>): Variant; overload;
		{ class } function CreateInstance(assemblyName: String; typeName: String): IObjectHandle; overload;
		{ class } function CreateInstance(type_: IType; nonPublic: Boolean): Variant; overload;
		{ class } function CreateInstance(type_: IType; args: TArray<Variant>; activationAttributes: TArray<Variant>): Variant; overload;
		{ class } function CreateInstance(assemblyName: String; typeName: String; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		{ class } function CreateInstance(type_: IType): Variant; overload;
		{ class } function CreateInstance(type_: IType; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): Variant; overload;
		{ class } function CreateInstance(assemblyName: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		{ class } function CreateInstance(T: PTypeInfo): Variant{T};
 overload;
		{ class } function CreateInstanceFrom(assemblyFile: String; typeName: String): IObjectHandle; overload;
		{ class } function CreateInstanceFrom(assemblyFile: String; typeName: String; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		{ class } function CreateInstanceFrom(assemblyFile: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): IObjectHandle; overload;
	end;

	[CoreTypeSignature(SYSTEM_ACTIVATOR)]
	IActivator = interface(IObject)
	['{E8507E97-A7A6-41C2-9720-B331A4837A06}']
	end;

	IAdjustmentRuleClass = interface(ICoreClrClass)
	['{9216F2F1-37BC-46D6-AEE1-42E57C3EA1DF}']
	{ public }
		{ class } function CreateAdjustmentRule(dateStart: TDateTime; dateEnd: TDateTime; daylightDelta: ITimeSpan; daylightTransitionStart: ITransitionTime; daylightTransitionEnd: ITransitionTime): IAdjustmentRule;
	end;

	[CoreTypeSignature(SYSTEM_ADJUSTMENTRULE)]
	IAdjustmentRule = interface(IObject)
	['{DE7840FD-03D3-4B38-9999-239F9232EC68}']
	{ private }
		function _GetProp_DateEnd: TDateTime;
		function _GetProp_DateStart: TDateTime;
		function _GetProp_DaylightDelta: ITimeSpan;
		function _GetProp_DaylightTransitionEnd: ITransitionTime;
		function _GetProp_DaylightTransitionStart: ITransitionTime;
	{ public }
		function Equals(other: IAdjustmentRule): Boolean;
		property DateEnd: TDateTime read _GetProp_DateEnd;
		property DateStart: TDateTime read _GetProp_DateStart;
		property DaylightDelta: ITimeSpan read _GetProp_DaylightDelta;
		property DaylightTransitionEnd: ITransitionTime read _GetProp_DaylightTransitionEnd;
		property DaylightTransitionStart: ITransitionTime read _GetProp_DaylightTransitionStart;
	end;

	IArmBaseClass = interface(ICoreClrClass)
	['{DBCB4353-437F-4D59-B46F-53AB1466A0EB}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function LeadingZeroCount(value: Integer): Integer; overload;
		{ class } function LeadingZeroCount(value: longword): Integer; overload;
		{ class } function ReverseElementBits(value: Integer): Integer; overload;
		{ class } function ReverseElementBits(value: longword): longword; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARMBASE)]
	IArmBase = interface(IObject)
	['{FA8798E0-3D66-402A-AF7F-374970F141B6}']
	end;

	IAdvSimdClass = interface(ICoreClrClass)
	['{13CD2C7A-4718-48D8-840D-7D2033BC4097}']
	{$IFDEF DELPHI_XE8_UP}
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Abs(value: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function Abs(value: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function Abs(value: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function Abs(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Abs(value: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function Abs(value: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function Abs(value: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function Abs(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteCompareGreaterThan(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteCompareGreaterThanOrEqual(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteCompareLessThan(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteCompareLessThanOrEqual(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteDifference(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AbsoluteDifference(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function AbsoluteDifference(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function AbsoluteDifference(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function AbsoluteDifference(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteDifference(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AbsoluteDifference(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AbsoluteDifference(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AbsoluteDifference(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<Byte>; left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<Shortint>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<Byte>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<Shortint>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceAdd(addend: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<UInt64>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningLower(left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<Word>; left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<SmallInt>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<longword>; left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningLowerAndAdd(addend: IVector128<UInt64>; left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<UInt64>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningUpper(left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<Word>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<SmallInt>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<longword>; left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AbsoluteDifferenceWideningUpperAndAdd(addend: IVector128<UInt64>; left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function AbsSaturate(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AbsSaturate(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AbsSaturate(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AbsSaturate(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AbsSaturate(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AbsSaturate(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AbsScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Add(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function Add(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Add(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Add(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Add(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Add(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function Add(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function Add(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Add(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Add(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Add(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Add(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function Add(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Add(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Add(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Add(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<Word>; right: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<Integer>; right: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<Int64>; right: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<longword>; right: IVector128<longword>): IVector64<Word>; overload;
		{ class } function AddHighNarrowingLower(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<Byte>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<SmallInt>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<Integer>; left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<Shortint>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<Word>; left: IVector128<longword>; right: IVector128<longword>): IVector128<Word>; overload;
		{ class } function AddHighNarrowingUpper(lower: IVector64<longword>; left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function AddPairwise(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AddPairwise(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AddPairwise(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AddPairwise(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AddPairwise(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AddPairwise(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AddPairwise(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function AddPairwiseWidening(value: IVector64<Byte>): IVector64<Word>; overload;
		{ class } function AddPairwiseWidening(value: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function AddPairwiseWidening(value: IVector64<Shortint>): IVector64<SmallInt>; overload;
		{ class } function AddPairwiseWidening(value: IVector64<Word>): IVector64<longword>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AddPairwiseWidening(value: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector64<Word>; value: IVector64<Byte>): IVector64<Word>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector64<Integer>; value: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector64<SmallInt>; value: IVector64<Shortint>): IVector64<SmallInt>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector64<longword>; value: IVector64<Word>): IVector64<longword>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<Word>; value: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<Integer>; value: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<Int64>; value: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<SmallInt>; value: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<longword>; value: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AddPairwiseWideningAndAdd(addend: IVector128<UInt64>; value: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function AddPairwiseWideningAndAddScalar(addend: IVector64<Int64>; value: IVector64<Integer>): IVector64<Int64>; overload;
		{ class } function AddPairwiseWideningAndAddScalar(addend: IVector64<UInt64>; value: IVector64<longword>): IVector64<UInt64>; overload;
		{ class } function AddPairwiseWideningScalar(value: IVector64<Integer>): IVector64<Int64>; overload;
		{ class } function AddPairwiseWideningScalar(value: IVector64<longword>): IVector64<UInt64>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<Word>; right: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<Integer>; right: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<Int64>; right: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<longword>; right: IVector128<longword>): IVector64<Word>; overload;
		{ class } function AddRoundedHighNarrowingLower(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<Byte>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<SmallInt>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<Integer>; left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<Shortint>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<Word>; left: IVector128<longword>; right: IVector128<longword>): IVector128<Word>; overload;
		{ class } function AddRoundedHighNarrowingUpper(lower: IVector64<longword>; left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function AddSaturate(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AddSaturate(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AddSaturate(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AddSaturate(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AddSaturate(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function AddSaturate(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AddSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AddSaturate(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function AddSaturate(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AddSaturate(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AddSaturate(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function AddSaturate(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function AddSaturateScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function AddScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AddScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function AddScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AddScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function AddWideningLower(left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function AddWideningLower(left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function AddWideningLower(left: IVector128<SmallInt>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddWideningLower(left: IVector128<Integer>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddWideningLower(left: IVector128<Int64>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function AddWideningLower(left: IVector128<Word>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function AddWideningLower(left: IVector128<longword>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function AddWideningLower(left: IVector128<UInt64>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function AddWideningLower(left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function AddWideningLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddWideningLower(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function AddWideningLower(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddWideningUpper(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AddWideningUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddWideningUpper(left: IVector128<SmallInt>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddWideningUpper(left: IVector128<Integer>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function AddWideningUpper(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function AddWideningUpper(left: IVector128<Int64>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function AddWideningUpper(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function AddWideningUpper(left: IVector128<Word>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function AddWideningUpper(left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AddWideningUpper(left: IVector128<longword>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function AddWideningUpper(left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function AddWideningUpper(left: IVector128<UInt64>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function &And(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function &And(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function &And(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function &And(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function &And(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function &And(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function &And(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function &And(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function &And(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function &And(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function &And(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &And(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function &And(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &And(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &And(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &And(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &And(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function &And(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &And(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &And(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function BitwiseClear(value: IVector64<Byte>; mask: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function BitwiseClear(value: IVector64<Double>; mask: IVector64<Double>): IVector64<Double>; overload;
		{ class } function BitwiseClear(value: IVector64<SmallInt>; mask: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function BitwiseClear(value: IVector64<Integer>; mask: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function BitwiseClear(value: IVector64<Int64>; mask: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function BitwiseClear(value: IVector64<Shortint>; mask: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function BitwiseClear(value: IVector64<Single>; mask: IVector64<Single>): IVector64<Single>; overload;
		{ class } function BitwiseClear(value: IVector64<Word>; mask: IVector64<Word>): IVector64<Word>; overload;
		{ class } function BitwiseClear(value: IVector64<longword>; mask: IVector64<longword>): IVector64<longword>; overload;
		{ class } function BitwiseClear(value: IVector64<UInt64>; mask: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function BitwiseClear(value: IVector128<Byte>; mask: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function BitwiseClear(value: IVector128<Double>; mask: IVector128<Double>): IVector128<Double>; overload;
		{ class } function BitwiseClear(value: IVector128<SmallInt>; mask: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function BitwiseClear(value: IVector128<Integer>; mask: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function BitwiseClear(value: IVector128<Int64>; mask: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function BitwiseClear(value: IVector128<Shortint>; mask: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function BitwiseClear(value: IVector128<Single>; mask: IVector128<Single>): IVector128<Single>; overload;
		{ class } function BitwiseClear(value: IVector128<Word>; mask: IVector128<Word>): IVector128<Word>; overload;
		{ class } function BitwiseClear(value: IVector128<longword>; mask: IVector128<longword>): IVector128<longword>; overload;
		{ class } function BitwiseClear(value: IVector128<UInt64>; mask: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function BitwiseSelect(select: IVector64<Byte>; left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function BitwiseSelect(select: IVector64<Double>; left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function BitwiseSelect(select: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function BitwiseSelect(select: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function BitwiseSelect(select: IVector64<Int64>; left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function BitwiseSelect(select: IVector64<Shortint>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function BitwiseSelect(select: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function BitwiseSelect(select: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function BitwiseSelect(select: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function BitwiseSelect(select: IVector64<UInt64>; left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function BitwiseSelect(select: IVector128<Byte>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function BitwiseSelect(select: IVector128<Double>; left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function BitwiseSelect(select: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function BitwiseSelect(select: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function BitwiseSelect(select: IVector128<Int64>; left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function BitwiseSelect(select: IVector128<Shortint>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function BitwiseSelect(select: IVector128<Single>; left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function BitwiseSelect(select: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function BitwiseSelect(select: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function BitwiseSelect(select: IVector128<UInt64>; left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function Ceiling(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Ceiling(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CeilingScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CeilingScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareEqual(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareEqual(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareEqual(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareEqual(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareEqual(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareEqual(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareEqual(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareEqual(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareEqual(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareEqual(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareEqual(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareEqual(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareEqual(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareGreaterThan(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareGreaterThan(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareGreaterThan(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareGreaterThan(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareGreaterThan(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareGreaterThan(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareGreaterThan(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareGreaterThan(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareGreaterThan(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareLessThan(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareLessThan(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareLessThan(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareLessThan(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareLessThan(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareLessThan(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareLessThan(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareLessThan(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareLessThan(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareLessThan(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareLessThan(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareLessThan(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareLessThan(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareTest(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function CompareTest(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function CompareTest(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function CompareTest(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function CompareTest(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareTest(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function CompareTest(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function CompareTest(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareTest(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareTest(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareTest(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareTest(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareTest(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareTest(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ConvertToInt32RoundAwayFromZero(value: IVector64<Single>): IVector64<Integer>; overload;
		{ class } function ConvertToInt32RoundAwayFromZero(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToInt32RoundAwayFromZeroScalar(value: IVector64<Single>): IVector64<Integer>;
		{ class } function ConvertToInt32RoundToEven(value: IVector64<Single>): IVector64<Integer>; overload;
		{ class } function ConvertToInt32RoundToEven(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToInt32RoundToEvenScalar(value: IVector64<Single>): IVector64<Integer>;
		{ class } function ConvertToInt32RoundToNegativeInfinity(value: IVector64<Single>): IVector64<Integer>; overload;
		{ class } function ConvertToInt32RoundToNegativeInfinity(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToInt32RoundToNegativeInfinityScalar(value: IVector64<Single>): IVector64<Integer>;
		{ class } function ConvertToInt32RoundToPositiveInfinity(value: IVector64<Single>): IVector64<Integer>; overload;
		{ class } function ConvertToInt32RoundToPositiveInfinity(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToInt32RoundToPositiveInfinityScalar(value: IVector64<Single>): IVector64<Integer>;
		{ class } function ConvertToInt32RoundToZero(value: IVector64<Single>): IVector64<Integer>; overload;
		{ class } function ConvertToInt32RoundToZero(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToInt32RoundToZeroScalar(value: IVector64<Single>): IVector64<Integer>;
		{ class } function ConvertToSingle(value: IVector64<Integer>): IVector64<Single>; overload;
		{ class } function ConvertToSingle(value: IVector64<longword>): IVector64<Single>; overload;
		{ class } function ConvertToSingle(value: IVector128<Integer>): IVector128<Single>; overload;
		{ class } function ConvertToSingle(value: IVector128<longword>): IVector128<Single>; overload;
		{ class } function ConvertToSingleScalar(value: IVector64<Integer>): IVector64<Single>; overload;
		{ class } function ConvertToSingleScalar(value: IVector64<longword>): IVector64<Single>; overload;
		{ class } function ConvertToUInt32RoundAwayFromZero(value: IVector64<Single>): IVector64<longword>; overload;
		{ class } function ConvertToUInt32RoundAwayFromZero(value: IVector128<Single>): IVector128<longword>; overload;
		{ class } function ConvertToUInt32RoundAwayFromZeroScalar(value: IVector64<Single>): IVector64<longword>;
		{ class } function ConvertToUInt32RoundToEven(value: IVector64<Single>): IVector64<longword>; overload;
		{ class } function ConvertToUInt32RoundToEven(value: IVector128<Single>): IVector128<longword>; overload;
		{ class } function ConvertToUInt32RoundToEvenScalar(value: IVector64<Single>): IVector64<longword>;
		{ class } function ConvertToUInt32RoundToNegativeInfinity(value: IVector64<Single>): IVector64<longword>; overload;
		{ class } function ConvertToUInt32RoundToNegativeInfinity(value: IVector128<Single>): IVector128<longword>; overload;
		{ class } function ConvertToUInt32RoundToNegativeInfinityScalar(value: IVector64<Single>): IVector64<longword>;
		{ class } function ConvertToUInt32RoundToPositiveInfinity(value: IVector64<Single>): IVector64<longword>; overload;
		{ class } function ConvertToUInt32RoundToPositiveInfinity(value: IVector128<Single>): IVector128<longword>; overload;
		{ class } function ConvertToUInt32RoundToPositiveInfinityScalar(value: IVector64<Single>): IVector64<longword>;
		{ class } function ConvertToUInt32RoundToZero(value: IVector64<Single>): IVector64<longword>; overload;
		{ class } function ConvertToUInt32RoundToZero(value: IVector128<Single>): IVector128<longword>; overload;
		{ class } function ConvertToUInt32RoundToZeroScalar(value: IVector64<Single>): IVector64<longword>;
		{ class } function DivideScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function DivideScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<Byte>; index: Byte): IVector128<Byte>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<SmallInt>; index: Byte): IVector128<SmallInt>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<Integer>; index: Byte): IVector128<Integer>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<Single>; index: Byte): IVector128<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<Shortint>; index: Byte): IVector128<Shortint>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<Word>; index: Byte): IVector128<Word>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector64<longword>; index: Byte): IVector128<longword>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Byte>; index: Byte): IVector128<Byte>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<SmallInt>; index: Byte): IVector128<SmallInt>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Integer>; index: Byte): IVector128<Integer>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Single>; index: Byte): IVector128<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Shortint>; index: Byte): IVector128<Shortint>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Word>; index: Byte): IVector128<Word>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<longword>; index: Byte): IVector128<longword>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<Byte>; index: Byte): IVector64<Byte>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<SmallInt>; index: Byte): IVector64<SmallInt>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<Integer>; index: Byte): IVector64<Integer>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<Single>; index: Byte): IVector64<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<Shortint>; index: Byte): IVector64<Shortint>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<Word>; index: Byte): IVector64<Word>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector64<longword>; index: Byte): IVector64<longword>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<Byte>; index: Byte): IVector64<Byte>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<SmallInt>; index: Byte): IVector64<SmallInt>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<Integer>; index: Byte): IVector64<Integer>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<Single>; index: Byte): IVector64<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<Shortint>; index: Byte): IVector64<Shortint>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<Word>; index: Byte): IVector64<Word>; overload;
		{ class } function DuplicateSelectedScalarToVector64(value: IVector128<longword>; index: Byte): IVector64<longword>; overload;
		{ class } function DuplicateToVector128(value: Byte): IVector128<Byte>; overload;
		{ class } function DuplicateToVector128(value: SmallInt): IVector128<SmallInt>; overload;
		{ class } function DuplicateToVector128(value: Integer): IVector128<Integer>; overload;
		{ class } function DuplicateToVector128(value: Shortint): IVector128<Shortint>; overload;
		{ class } function DuplicateToVector128(value: Single): IVector128<Single>; overload;
		{ class } function DuplicateToVector128(value: Word): IVector128<Word>; overload;
		{ class } function DuplicateToVector128(value: longword): IVector128<longword>; overload;
		{ class } function DuplicateToVector64(value: Byte): IVector64<Byte>; overload;
		{ class } function DuplicateToVector64(value: SmallInt): IVector64<SmallInt>; overload;
		{ class } function DuplicateToVector64(value: Integer): IVector64<Integer>; overload;
		{ class } function DuplicateToVector64(value: Shortint): IVector64<Shortint>; overload;
		{ class } function DuplicateToVector64(value: Single): IVector64<Single>; overload;
		{ class } function DuplicateToVector64(value: Word): IVector64<Word>; overload;
		{ class } function DuplicateToVector64(value: longword): IVector64<longword>; overload;
		{ class } function Extract(vector: IVector128<Byte>; index: Byte): Byte; overload;
		{ class } function Extract(vector: IVector128<Double>; index: Byte): Double; overload;
		{ class } function Extract(vector: IVector128<SmallInt>; index: Byte): SmallInt; overload;
		{ class } function Extract(vector: IVector128<Integer>; index: Byte): Integer; overload;
		{ class } function Extract(vector: IVector128<Int64>; index: Byte): Int64; overload;
		{ class } function Extract(vector: IVector128<Shortint>; index: Byte): Shortint; overload;
		{ class } function Extract(vector: IVector128<Single>; index: Byte): Single; overload;
		{ class } function Extract(vector: IVector128<Word>; index: Byte): Word; overload;
		{ class } function Extract(vector: IVector128<longword>; index: Byte): longword; overload;
		{ class } function Extract(vector: IVector128<UInt64>; index: Byte): UInt64; overload;
		{ class } function Extract(vector: IVector64<Byte>; index: Byte): Byte; overload;
		{ class } function Extract(vector: IVector64<SmallInt>; index: Byte): SmallInt; overload;
		{ class } function Extract(vector: IVector64<Integer>; index: Byte): Integer; overload;
		{ class } function Extract(vector: IVector64<Shortint>; index: Byte): Shortint; overload;
		{ class } function Extract(vector: IVector64<Single>; index: Byte): Single; overload;
		{ class } function Extract(vector: IVector64<Word>; index: Byte): Word; overload;
		{ class } function Extract(vector: IVector64<longword>; index: Byte): longword; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<longword>): IVector64<Word>; overload;
		{ class } function ExtractNarrowingLower(value: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<longword>): IVector64<Word>; overload;
		{ class } function ExtractNarrowingSaturateLower(value: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedLower(value: IVector128<SmallInt>): IVector64<Byte>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedLower(value: IVector128<Integer>): IVector64<Word>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedLower(value: IVector128<Int64>): IVector64<longword>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedUpper(lower: IVector64<Byte>; value: IVector128<SmallInt>): IVector128<Byte>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedUpper(lower: IVector64<Word>; value: IVector128<Integer>): IVector128<Word>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedUpper(lower: IVector64<longword>; value: IVector128<Int64>): IVector128<longword>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<Byte>; value: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<Integer>; value: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<Word>; value: IVector128<longword>): IVector128<Word>; overload;
		{ class } function ExtractNarrowingSaturateUpper(lower: IVector64<longword>; value: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<Byte>; value: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<Integer>; value: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<Word>; value: IVector128<longword>): IVector128<Word>; overload;
		{ class } function ExtractNarrowingUpper(lower: IVector64<longword>; value: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function ExtractVector128(upper: IVector128<Byte>; lower: IVector128<Byte>; index: Byte): IVector128<Byte>; overload;
		{ class } function ExtractVector128(upper: IVector128<Double>; lower: IVector128<Double>; index: Byte): IVector128<Double>; overload;
		{ class } function ExtractVector128(upper: IVector128<SmallInt>; lower: IVector128<SmallInt>; index: Byte): IVector128<SmallInt>; overload;
		{ class } function ExtractVector128(upper: IVector128<Integer>; lower: IVector128<Integer>; index: Byte): IVector128<Integer>; overload;
		{ class } function ExtractVector128(upper: IVector128<Int64>; lower: IVector128<Int64>; index: Byte): IVector128<Int64>; overload;
		{ class } function ExtractVector128(upper: IVector128<Shortint>; lower: IVector128<Shortint>; index: Byte): IVector128<Shortint>; overload;
		{ class } function ExtractVector128(upper: IVector128<Single>; lower: IVector128<Single>; index: Byte): IVector128<Single>; overload;
		{ class } function ExtractVector128(upper: IVector128<Word>; lower: IVector128<Word>; index: Byte): IVector128<Word>; overload;
		{ class } function ExtractVector128(upper: IVector128<longword>; lower: IVector128<longword>; index: Byte): IVector128<longword>; overload;
		{ class } function ExtractVector128(upper: IVector128<UInt64>; lower: IVector128<UInt64>; index: Byte): IVector128<UInt64>; overload;
		{ class } function ExtractVector64(upper: IVector64<Byte>; lower: IVector64<Byte>; index: Byte): IVector64<Byte>; overload;
		{ class } function ExtractVector64(upper: IVector64<SmallInt>; lower: IVector64<SmallInt>; index: Byte): IVector64<SmallInt>; overload;
		{ class } function ExtractVector64(upper: IVector64<Integer>; lower: IVector64<Integer>; index: Byte): IVector64<Integer>; overload;
		{ class } function ExtractVector64(upper: IVector64<Shortint>; lower: IVector64<Shortint>; index: Byte): IVector64<Shortint>; overload;
		{ class } function ExtractVector64(upper: IVector64<Single>; lower: IVector64<Single>; index: Byte): IVector64<Single>; overload;
		{ class } function ExtractVector64(upper: IVector64<Word>; lower: IVector64<Word>; index: Byte): IVector64<Word>; overload;
		{ class } function ExtractVector64(upper: IVector64<longword>; lower: IVector64<longword>; index: Byte): IVector64<longword>; overload;
		{ class } function Floor(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Floor(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function FloorScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function FloorScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedAddHalving(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function FusedAddHalving(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function FusedAddHalving(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function FusedAddHalving(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function FusedAddHalving(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function FusedAddHalving(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function FusedAddHalving(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function FusedAddHalving(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function FusedAddHalving(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function FusedAddHalving(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function FusedAddHalving(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function FusedAddHalving(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function FusedAddRoundedHalving(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function FusedMultiplyAdd(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplyAdd(addend: IVector128<Single>; left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function FusedMultiplyAddNegatedScalar(addend: IVector64<Double>; left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function FusedMultiplyAddNegatedScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplyAddScalar(addend: IVector64<Double>; left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function FusedMultiplyAddScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtract(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtract(minuend: IVector128<Single>; left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function FusedMultiplySubtractNegatedScalar(minuend: IVector64<Double>; left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function FusedMultiplySubtractNegatedScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtractScalar(minuend: IVector64<Double>; left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function FusedMultiplySubtractScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function FusedSubtractHalving(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function FusedSubtractHalving(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Insert(vector: IVector64<Byte>; index: Byte; data: Byte): IVector64<Byte>; overload;
		{ class } function Insert(vector: IVector64<SmallInt>; index: Byte; data: SmallInt): IVector64<SmallInt>; overload;
		{ class } function Insert(vector: IVector64<Integer>; index: Byte; data: Integer): IVector64<Integer>; overload;
		{ class } function Insert(vector: IVector64<Shortint>; index: Byte; data: Shortint): IVector64<Shortint>; overload;
		{ class } function Insert(vector: IVector64<Single>; index: Byte; data: Single): IVector64<Single>; overload;
		{ class } function Insert(vector: IVector64<Word>; index: Byte; data: Word): IVector64<Word>; overload;
		{ class } function Insert(vector: IVector64<longword>; index: Byte; data: longword): IVector64<longword>; overload;
		{ class } function Insert(vector: IVector128<Byte>; index: Byte; data: Byte): IVector128<Byte>; overload;
		{ class } function Insert(vector: IVector128<Double>; index: Byte; data: Double): IVector128<Double>; overload;
		{ class } function Insert(vector: IVector128<SmallInt>; index: Byte; data: SmallInt): IVector128<SmallInt>; overload;
		{ class } function Insert(vector: IVector128<Integer>; index: Byte; data: Integer): IVector128<Integer>; overload;
		{ class } function Insert(vector: IVector128<Int64>; index: Byte; data: Int64): IVector128<Int64>; overload;
		{ class } function Insert(vector: IVector128<Shortint>; index: Byte; data: Shortint): IVector128<Shortint>; overload;
		{ class } function Insert(vector: IVector128<Single>; index: Byte; data: Single): IVector128<Single>; overload;
		{ class } function Insert(vector: IVector128<Word>; index: Byte; data: Word): IVector128<Word>; overload;
		{ class } function Insert(vector: IVector128<longword>; index: Byte; data: longword): IVector128<longword>; overload;
		{ class } function Insert(vector: IVector128<UInt64>; index: Byte; data: UInt64): IVector128<UInt64>; overload;
		{ class } function InsertScalar(result_: IVector128<Double>; resultIndex: Byte; value: IVector64<Double>): IVector128<Double>; overload;
		{ class } function InsertScalar(result_: IVector128<Int64>; resultIndex: Byte; value: IVector64<Int64>): IVector128<Int64>; overload;
		{ class } function InsertScalar(result_: IVector128<UInt64>; resultIndex: Byte; value: IVector64<UInt64>): IVector128<UInt64>; overload;
		{ class } function LeadingSignCount(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function LeadingSignCount(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function LeadingSignCount(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function LeadingSignCount(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function LeadingSignCount(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function LeadingSignCount(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function LeadingZeroCount(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function LeadingZeroCount(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function LeadingZeroCount(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function LeadingZeroCount(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function LeadingZeroCount(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function LeadingZeroCount(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function LeadingZeroCount(value: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function LeadingZeroCount(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function LeadingZeroCount(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function LeadingZeroCount(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function LeadingZeroCount(value: IVector128<Word>): IVector128<Word>; overload;
		{ class } function LeadingZeroCount(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<Byte>; index: Byte; address: ICoreClrInstance): IVector64<Byte>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<SmallInt>; index: Byte; address: ICoreClrInstance): IVector64<SmallInt>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<Integer>; index: Byte; address: ICoreClrInstance): IVector64<Integer>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<Shortint>; index: Byte; address: ICoreClrInstance): IVector64<Shortint>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<Single>; index: Byte; address: ICoreClrInstance): IVector64<Single>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<Word>; index: Byte; address: ICoreClrInstance): IVector64<Word>; overload;
		{ class } function LoadAndInsertScalar(value: IVector64<longword>; index: Byte; address: ICoreClrInstance): IVector64<longword>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Byte>; index: Byte; address: ICoreClrInstance): IVector128<Byte>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Double>; index: Byte; address: ICoreClrInstance): IVector128<Double>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<SmallInt>; index: Byte; address: ICoreClrInstance): IVector128<SmallInt>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Integer>; index: Byte; address: ICoreClrInstance): IVector128<Integer>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Int64>; index: Byte; address: ICoreClrInstance): IVector128<Int64>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Shortint>; index: Byte; address: ICoreClrInstance): IVector128<Shortint>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Single>; index: Byte; address: ICoreClrInstance): IVector128<Single>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<Word>; index: Byte; address: ICoreClrInstance): IVector128<Word>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<longword>; index: Byte; address: ICoreClrInstance): IVector128<longword>; overload;
		{ class } function LoadAndInsertScalar(value: IVector128<UInt64>; index: Byte; address: ICoreClrInstance): IVector128<UInt64>; overload;
		{ class } function LoadAndReplicateToVector128(address: ICoreClrInstance): IVector128<Byte>;
		{ class } function LoadAndReplicateToVector64(address: ICoreClrInstance): IVector64<longword>;
		{ class } function LoadVector128(address: ICoreClrInstance): IVector128<Byte>;
		{ class } function LoadVector64(address: ICoreClrInstance): IVector64<Byte>;
		{ class } function Max(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function Max(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Max(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Max(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Max(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Max(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function Max(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Max(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Max(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Max(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Max(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Max(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Max(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Max(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MaxNumber(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxNumber(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MaxNumberScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MaxNumberScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxPairwise(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MaxPairwise(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MaxPairwise(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MaxPairwise(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MaxPairwise(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxPairwise(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MaxPairwise(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Min(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function Min(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Min(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Min(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Min(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Min(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function Min(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Min(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Min(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Min(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Min(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Min(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Min(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Min(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MinNumber(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinNumber(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MinNumberScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MinNumberScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinPairwise(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MinPairwise(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MinPairwise(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MinPairwise(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MinPairwise(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinPairwise(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MinPairwise(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Multiply(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Multiply(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Multiply(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Multiply(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Multiply(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Multiply(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Multiply(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Multiply(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function Multiply(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Multiply(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Multiply(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Multiply(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Multiply(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function Multiply(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplyAdd(addend: IVector64<Byte>; left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MultiplyAdd(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyAdd(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyAdd(addend: IVector64<Shortint>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MultiplyAdd(addend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MultiplyAdd(addend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplyAdd(addend: IVector128<Byte>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function MultiplyAdd(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyAdd(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyAdd(addend: IVector128<Shortint>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function MultiplyAdd(addend: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MultiplyAdd(addend: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector128<Word>; left: IVector128<Word>; right: IVector64<Word>): IVector128<Word>; overload;
		{ class } function MultiplyAddByScalar(addend: IVector128<longword>; left: IVector128<longword>; right: IVector64<longword>): IVector128<longword>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<Word>; left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector64<longword>; left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<Word>; left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<longword>; left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyAddBySelectedScalar(addend: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyByScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyByScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyByScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MultiplyByScalar(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MultiplyByScalar(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplyByScalar(left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyByScalar(left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyByScalar(left: IVector128<Single>; right: IVector64<Single>): IVector128<Single>; overload;
		{ class } function MultiplyByScalar(left: IVector128<Word>; right: IVector64<Word>): IVector128<Word>; overload;
		{ class } function MultiplyByScalar(left: IVector128<longword>; right: IVector64<longword>): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Single>; right: IVector64<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Single>; right: IVector128<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalar(left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLower(left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<longword>; left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<longword>; left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<UInt64>; left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<UInt64>; left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndAdd(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<longword>; left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<longword>; left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<UInt64>; left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningLowerAndSubtract(minuend: IVector128<UInt64>; left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpper(left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<longword>; left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<longword>; left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<UInt64>; left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndAdd(addend: IVector128<UInt64>; left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<longword>; left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<longword>; left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<UInt64>; left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyBySelectedScalarWideningUpperAndSubtract(minuend: IVector128<UInt64>; left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<UInt64>; overload;
		{ class } function MultiplyDoublingByScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingByScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingByScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyDoublingByScalarSaturateHigh(left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingBySelectedScalarSaturateHigh(left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingSaturateHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyDoublingSaturateHigh(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerAndAddSaturate(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerAndAddSaturate(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerByScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerByScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateLower(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerByScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerByScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerBySelectedScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerBySelectedScalar(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerBySelectedScalar(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateLowerBySelectedScalar(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpper(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperByScalar(left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperByScalar(left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperBySelectedScalar(left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperBySelectedScalar(left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperBySelectedScalar(left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateUpperBySelectedScalar(left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperAndAddSaturate(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperAndAddSaturate(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperByScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperByScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Int64>; overload;
		{ class } function MultiplyRoundedDoublingByScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingByScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingByScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingByScalarSaturateHigh(left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHigh(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MultiplyScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MultiplyScalarBySelectedScalar(left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyScalarBySelectedScalar(left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<Byte>; left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<Shortint>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MultiplySubtract(minuend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<Byte>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<Shortint>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MultiplySubtract(minuend: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector128<Word>; left: IVector128<Word>; right: IVector64<Word>): IVector128<Word>; overload;
		{ class } function MultiplySubtractByScalar(minuend: IVector128<longword>; left: IVector128<longword>; right: IVector64<longword>): IVector128<longword>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<Word>; left: IVector64<Word>; right: IVector64<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<Word>; left: IVector64<Word>; right: IVector128<Word>; rightIndex: Byte): IVector64<Word>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<longword>; left: IVector64<longword>; right: IVector64<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector64<longword>; left: IVector64<longword>; right: IVector128<longword>; rightIndex: Byte): IVector64<longword>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<Word>; left: IVector128<Word>; right: IVector64<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<Word>; left: IVector128<Word>; right: IVector128<Word>; rightIndex: Byte): IVector128<Word>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<longword>; left: IVector128<longword>; right: IVector64<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplySubtractBySelectedScalar(minuend: IVector128<longword>; left: IVector128<longword>; right: IVector128<longword>; rightIndex: Byte): IVector128<longword>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningLower(left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<Word>; left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<SmallInt>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<longword>; left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningLowerAndAdd(addend: IVector128<UInt64>; left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<SmallInt>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<longword>; left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<UInt64>; left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<Word>; left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningLowerAndSubtract(minuend: IVector128<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningUpper(left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<Word>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<SmallInt>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<longword>; left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningUpperAndAdd(addend: IVector128<UInt64>; left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<Word>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<Integer>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<Int64>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<SmallInt>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<longword>; left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function MultiplyWideningUpperAndSubtract(minuend: IVector128<UInt64>; left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function Negate(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Negate(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Negate(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Negate(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Negate(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Negate(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Negate(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Negate(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function NegateSaturate(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function NegateSaturate(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function NegateSaturate(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function NegateSaturate(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function NegateSaturate(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function NegateSaturate(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function NegateScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function NegateScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function &Not(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function &Not(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function &Not(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function &Not(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function &Not(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function &Not(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function &Not(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function &Not(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function &Not(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function &Not(value: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function &Not(value: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &Not(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function &Not(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &Not(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &Not(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &Not(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &Not(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function &Not(value: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &Not(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &Not(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function &Or(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function &Or(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function &Or(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function &Or(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function &Or(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function &Or(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function &Or(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function &Or(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function &Or(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function &Or(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function &Or(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &Or(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function &Or(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &Or(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &Or(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &Or(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &Or(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function &Or(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &Or(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &Or(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function OrNot(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function OrNot(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function OrNot(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function OrNot(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function OrNot(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function OrNot(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function OrNot(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function OrNot(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function OrNot(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function OrNot(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function OrNot(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function OrNot(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function OrNot(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function OrNot(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function OrNot(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function OrNot(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function OrNot(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function OrNot(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function OrNot(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function OrNot(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function PolynomialMultiply(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function PolynomialMultiply(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function PolynomialMultiply(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function PolynomialMultiply(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function PolynomialMultiplyWideningLower(left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function PolynomialMultiplyWideningLower(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function PolynomialMultiplyWideningUpper(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function PolynomialMultiplyWideningUpper(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function PopCount(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function PopCount(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function PopCount(value: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function PopCount(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ReciprocalEstimate(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalEstimate(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ReciprocalEstimate(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalEstimate(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ReciprocalSquareRootEstimate(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalSquareRootEstimate(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ReciprocalSquareRootEstimate(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalSquareRootEstimate(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ReciprocalSquareRootStep(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalSquareRootStep(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalStep(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalStep(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReverseElement16(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ReverseElement16(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ReverseElement16(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ReverseElement16(value: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function ReverseElement16(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ReverseElement16(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ReverseElement16(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ReverseElement16(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ReverseElement32(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ReverseElement32(value: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function ReverseElement32(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ReverseElement32(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ReverseElement8(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ReverseElement8(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ReverseElement8(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ReverseElement8(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function ReverseElement8(value: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ReverseElement8(value: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function ReverseElement8(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ReverseElement8(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ReverseElement8(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ReverseElement8(value: IVector128<Word>): IVector128<Word>; overload;
		{ class } function ReverseElement8(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ReverseElement8(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function RoundAwayFromZero(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundAwayFromZero(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundAwayFromZeroScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function RoundAwayFromZeroScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToNearest(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToNearest(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNearestScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function RoundToNearestScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNegativeInfinityScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function RoundToNegativeInfinityScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToPositiveInfinityScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function RoundToPositiveInfinityScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToZero(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function RoundToZero(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToZeroScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function RoundToZeroScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ShiftArithmetic(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftArithmetic(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftArithmetic(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftArithmetic(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmetic(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmetic(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftArithmetic(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftArithmeticRounded(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftArithmeticRoundedSaturate(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftArithmeticRoundedSaturateScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>;
		{ class } function ShiftArithmeticRoundedScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>;
		{ class } function ShiftArithmeticSaturate(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftArithmeticSaturate(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftArithmeticSaturateScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>;
		{ class } function ShiftArithmeticScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>;
		{ class } function ShiftLeftAndInsert(left: IVector64<Byte>; right: IVector64<Byte>; shift: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector64<SmallInt>; right: IVector64<SmallInt>; shift: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector64<Integer>; right: IVector64<Integer>; shift: Byte): IVector64<Integer>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector64<Shortint>; right: IVector64<Shortint>; shift: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector64<Word>; right: IVector64<Word>; shift: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector64<longword>; right: IVector64<longword>; shift: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<Byte>; right: IVector128<Byte>; shift: Byte): IVector128<Byte>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<SmallInt>; right: IVector128<SmallInt>; shift: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<Integer>; right: IVector128<Integer>; shift: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<Int64>; right: IVector128<Int64>; shift: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<Shortint>; right: IVector128<Shortint>; shift: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<Word>; right: IVector128<Word>; shift: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<longword>; right: IVector128<longword>; shift: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftAndInsert(left: IVector128<UInt64>; right: IVector128<UInt64>; shift: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftAndInsertScalar(left: IVector64<Int64>; right: IVector64<Int64>; shift: Byte): IVector64<Int64>; overload;
		{ class } function ShiftLeftAndInsertScalar(left: IVector64<UInt64>; right: IVector64<UInt64>; shift: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogicalSaturate(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector64<SmallInt>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector64<Integer>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector64<Shortint>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector128<SmallInt>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector128<Integer>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector128<Int64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsigned(value: IVector128<Shortint>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsignedScalar(value: IVector64<Int64>; count: Byte): IVector64<UInt64>;
		{ class } function ShiftLeftLogicalScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftLeftLogicalScalar(value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<Integer>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<Shortint>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<Word>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<longword>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<Byte>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogicalWideningLower(value: IVector64<SmallInt>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<Byte>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<SmallInt>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<Integer>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<Shortint>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<Word>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogicalWideningUpper(value: IVector128<longword>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLogical(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogical(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogical(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogical(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogical(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogical(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftLogical(value: IVector128<Byte>; count: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function ShiftLogical(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftLogical(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftLogical(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftLogical(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftLogical(value: IVector128<Word>; count: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function ShiftLogical(value: IVector128<longword>; count: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function ShiftLogical(value: IVector128<UInt64>; count: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogicalRounded(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<Byte>; count: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<Word>; count: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<longword>; count: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function ShiftLogicalRounded(value: IVector128<UInt64>; count: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<Byte>; count: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<Word>; count: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<longword>; count: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function ShiftLogicalRoundedSaturate(value: IVector128<UInt64>; count: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<UInt64>; count: IVector64<Int64>): IVector64<UInt64>; overload;
		{ class } function ShiftLogicalRoundedScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ShiftLogicalRoundedScalar(value: IVector64<UInt64>; count: IVector64<Int64>): IVector64<UInt64>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<Byte>; count: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<Shortint>; count: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<Word>; count: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<longword>; count: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function ShiftLogicalSaturate(value: IVector128<UInt64>; count: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<UInt64>; count: IVector64<Int64>): IVector64<UInt64>; overload;
		{ class } function ShiftLogicalScalar(value: IVector64<Int64>; count: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function ShiftLogicalScalar(value: IVector64<UInt64>; count: IVector64<Int64>): IVector64<UInt64>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<Word>; right: IVector128<Word>; shift: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<longword>; right: IVector128<longword>; shift: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<UInt64>; right: IVector128<UInt64>; shift: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<Byte>; right: IVector64<Byte>; shift: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<SmallInt>; right: IVector64<SmallInt>; shift: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<Integer>; right: IVector64<Integer>; shift: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<Shortint>; right: IVector64<Shortint>; shift: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<Word>; right: IVector64<Word>; shift: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightAndInsert(left: IVector64<longword>; right: IVector64<longword>; shift: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<Byte>; right: IVector128<Byte>; shift: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<SmallInt>; right: IVector128<SmallInt>; shift: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<Integer>; right: IVector128<Integer>; shift: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<Int64>; right: IVector128<Int64>; shift: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightAndInsert(left: IVector128<Shortint>; right: IVector128<Shortint>; shift: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightAndInsertScalar(left: IVector64<Int64>; right: IVector64<Int64>; shift: Byte): IVector64<Int64>; overload;
		{ class } function ShiftRightAndInsertScalar(left: IVector64<UInt64>; right: IVector64<UInt64>; shift: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftRightArithmetic(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmetic(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector64<SmallInt>; value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector64<Integer>; value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector64<Shortint>; value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector128<SmallInt>; value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector128<Integer>; value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector128<Int64>; value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightArithmeticAdd(addend: IVector128<Shortint>; value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticAddScalar(addend: IVector64<Int64>; value: IVector64<Int64>; count: Byte): IVector64<Int64>;
		{ class } function ShiftRightArithmeticNarrowingSaturateLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedLower(value: IVector128<SmallInt>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedLower(value: IVector128<Integer>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedLower(value: IVector128<Int64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedUpper(lower: IVector64<Byte>; value: IVector128<SmallInt>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedUpper(lower: IVector64<Word>; value: IVector128<Integer>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedUpper(lower: IVector64<longword>; value: IVector128<Int64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightArithmeticRounded(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector64<SmallInt>; value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector64<Integer>; value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector64<Shortint>; value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector128<SmallInt>; value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector128<Integer>; value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector128<Int64>; value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightArithmeticRoundedAdd(addend: IVector128<Shortint>; value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedAddScalar(addend: IVector64<Int64>; value: IVector64<Int64>; count: Byte): IVector64<Int64>;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(value: IVector128<SmallInt>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(value: IVector128<Integer>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(value: IVector128<Int64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(lower: IVector64<Byte>; value: IVector128<SmallInt>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(lower: IVector64<Word>; value: IVector128<Integer>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(lower: IVector64<longword>; value: IVector128<Int64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>;
		{ class } function ShiftRightArithmeticScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>;
		{ class } function ShiftRightLogical(value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogical(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogical(value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogical(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<Shortint>; value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<Word>; value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<longword>; value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<UInt64>; value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<Byte>; value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<SmallInt>; value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<Integer>; value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<Shortint>; value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<Word>; value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector64<longword>; value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<Byte>; value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<SmallInt>; value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<Integer>; value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalAdd(addend: IVector128<Int64>; value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogicalAddScalar(addend: IVector64<Int64>; value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftRightLogicalAddScalar(addend: IVector64<UInt64>; value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalNarrowingLower(value: IVector128<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateLower(value: IVector128<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<Byte>; value: IVector128<Word>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<Word>; value: IVector128<longword>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateUpper(lower: IVector64<longword>; value: IVector128<UInt64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<Byte>; value: IVector128<Word>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<Word>; value: IVector128<longword>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalNarrowingUpper(lower: IVector64<longword>; value: IVector128<UInt64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalRounded(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<Byte>; value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<SmallInt>; value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<Integer>; value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<Shortint>; value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<Word>; value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector64<longword>; value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<Byte>; value: IVector128<Byte>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<SmallInt>; value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<Integer>; value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<Int64>; value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<Shortint>; value: IVector128<Shortint>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<Word>; value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<longword>; value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalRoundedAdd(addend: IVector128<UInt64>; value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogicalRoundedAddScalar(addend: IVector64<Int64>; value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftRightLogicalRoundedAddScalar(addend: IVector64<UInt64>; value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingLower(value: IVector128<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateLower(value: IVector128<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<Byte>; value: IVector128<Word>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<Word>; value: IVector128<longword>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateUpper(lower: IVector64<longword>; value: IVector128<UInt64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<Byte>; value: IVector128<Word>; count: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<SmallInt>; value: IVector128<Integer>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<Integer>; value: IVector128<Int64>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<Shortint>; value: IVector128<SmallInt>; count: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<Word>; value: IVector128<longword>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingUpper(lower: IVector64<longword>; value: IVector128<UInt64>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalRoundedScalar(value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function ShiftRightLogicalRoundedScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftRightLogicalScalar(value: IVector64<Int64>; count: Byte): IVector64<Int64>; overload;
		{ class } function ShiftRightLogicalScalar(value: IVector64<UInt64>; count: Byte): IVector64<UInt64>; overload;
		{ class } function SignExtendWideningLower(value: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function SignExtendWideningLower(value: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function SignExtendWideningLower(value: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SignExtendWideningUpper(value: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function SignExtendWideningUpper(value: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function SignExtendWideningUpper(value: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SqrtScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function SqrtScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Byte>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Double>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<SmallInt>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Integer>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Int64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Shortint>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Single>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<Word>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<longword>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector64<UInt64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Byte>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Double>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<SmallInt>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Integer>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Int64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Shortint>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Single>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Word>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<longword>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<UInt64>); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<Byte>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<SmallInt>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<Integer>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<Shortint>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<Single>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<Word>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector64<longword>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Byte>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Double>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<SmallInt>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Integer>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Int64>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Shortint>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Single>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<Word>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<longword>; index: Byte); overload;
		{ class } procedure StoreSelectedScalar(address: ICoreClrInstance; value: IVector128<UInt64>; index: Byte); overload;
		{ class } function Subtract(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function Subtract(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function Subtract(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function Subtract(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function Subtract(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Subtract(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function Subtract(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Subtract(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Subtract(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Subtract(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Subtract(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function Subtract(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Subtract(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Subtract(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Subtract(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Subtract(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<Word>; right: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<Integer>; right: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<Int64>; right: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<longword>; right: IVector128<longword>): IVector64<Word>; overload;
		{ class } function SubtractHighNarrowingLower(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<Byte>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<SmallInt>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<Integer>; left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<Shortint>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<Word>; left: IVector128<longword>; right: IVector128<longword>): IVector128<Word>; overload;
		{ class } function SubtractHighNarrowingUpper(lower: IVector64<longword>; left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<Word>; right: IVector128<Word>): IVector64<Byte>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<Integer>; right: IVector128<Integer>): IVector64<SmallInt>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<Int64>; right: IVector128<Int64>): IVector64<Integer>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector64<Shortint>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<longword>; right: IVector128<longword>): IVector64<Word>; overload;
		{ class } function SubtractRoundedHighNarrowingLower(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector64<longword>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<Shortint>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<Word>; left: IVector128<longword>; right: IVector128<longword>): IVector128<Word>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<longword>; left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<longword>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<Byte>; left: IVector128<Word>; right: IVector128<Word>): IVector128<Byte>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<SmallInt>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function SubtractRoundedHighNarrowingUpper(lower: IVector64<Integer>; left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Integer>; overload;
		{ class } function SubtractSaturate(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function SubtractSaturate(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function SubtractSaturate(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function SubtractSaturate(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function SubtractSaturate(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function SubtractSaturate(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function SubtractSaturate(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function SubtractSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function SubtractSaturate(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function SubtractSaturate(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function SubtractSaturate(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function SubtractSaturate(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function SubtractSaturate(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function SubtractSaturate(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function SubtractScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function SubtractScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function SubtractScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function SubtractScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function SubtractWideningLower(left: IVector64<Byte>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function SubtractWideningLower(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function SubtractWideningLower(left: IVector64<Integer>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function SubtractWideningLower(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SubtractWideningLower(left: IVector64<Word>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function SubtractWideningLower(left: IVector64<longword>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function SubtractWideningLower(left: IVector128<SmallInt>; right: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SubtractWideningLower(left: IVector128<Integer>; right: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function SubtractWideningLower(left: IVector128<Int64>; right: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function SubtractWideningLower(left: IVector128<Word>; right: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function SubtractWideningLower(left: IVector128<longword>; right: IVector64<Word>): IVector128<longword>; overload;
		{ class } function SubtractWideningLower(left: IVector128<UInt64>; right: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<SmallInt>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Integer>; right: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Int64>; right: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Word>; right: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<Word>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<longword>; right: IVector128<Word>): IVector128<longword>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function SubtractWideningUpper(left: IVector128<UInt64>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function VectorTableLookup(table: IVector128<Byte>; byteIndexes: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function VectorTableLookup(table: IVector128<Shortint>; byteIndexes: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function VectorTableLookupExtension(defaultValues: IVector64<Byte>; table: IVector128<Byte>; byteIndexes: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function VectorTableLookupExtension(defaultValues: IVector64<Shortint>; table: IVector128<Shortint>; byteIndexes: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function &Xor(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function &Xor(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function &Xor(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function &Xor(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function &Xor(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function &Xor(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function &Xor(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function &Xor(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function &Xor(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function &Xor(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function &Xor(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &Xor(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function &Xor(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &Xor(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &Xor(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &Xor(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &Xor(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function &Xor(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &Xor(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &Xor(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<Byte>): IVector128<Word>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<SmallInt>): IVector128<Integer>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<Integer>): IVector128<Int64>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<Shortint>): IVector128<SmallInt>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<Word>): IVector128<longword>; overload;
		{ class } function ZeroExtendWideningLower(value: IVector64<longword>): IVector128<UInt64>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<Byte>): IVector128<Word>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<Word>): IVector128<longword>; overload;
		{ class } function ZeroExtendWideningUpper(value: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	{$ENDIF}
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ADVSIMD)]
	IAdvSimd = interface(IArmBase)
	['{C639D2A7-E122-4983-8565-6FA5BCD0A2E4}']
	end;

	IArm64_2Class = interface(ICoreClrClass)
	['{A95A1C85-BC0E-4418-BCE4-5EAC5305515E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function LeadingSignCount(value: Integer): Integer; overload;
		{ class } function LeadingSignCount(value: Int64): Integer; overload;
		{ class } function LeadingZeroCount(value: Int64): Integer; overload;
		{ class } function LeadingZeroCount(value: UInt64): Integer; overload;
		{ class } function ReverseElementBits(value: Int64): Int64; overload;
		{ class } function ReverseElementBits(value: UInt64): UInt64; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_3)]
	IArm64_2 = interface(IObject)
	['{919FDAF5-AD71-4EF4-9BC2-A154EB9A5EF7}']
	end;

	IArm64Class = interface(ICoreClrClass)
	['{D9A9AE89-FC55-4D82-86E5-1B4ED2647380}']
	{$IFDEF DELPHI_XE8_UP}
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Abs(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Abs(value: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function AbsoluteCompareGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AbsoluteCompareGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AbsoluteCompareGreaterThanOrEqualScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsoluteCompareGreaterThanOrEqualScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareGreaterThanScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsoluteCompareGreaterThanScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AbsoluteCompareLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AbsoluteCompareLessThanOrEqualScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsoluteCompareLessThanOrEqualScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteCompareLessThanScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsoluteCompareLessThanScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsoluteDifference(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AbsoluteDifferenceScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function AbsoluteDifferenceScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AbsSaturate(value: IVector128<Int64>): IVector128<Int64>;
		{ class } function AbsSaturateScalar(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AbsSaturateScalar(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AbsSaturateScalar(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function AbsSaturateScalar(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AbsScalar(value: IVector64<Int64>): IVector64<UInt64>;
		{ class } function Add(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function AddAcross(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AddAcross(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AddAcross(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AddAcross(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AddAcross(value: IVector128<Byte>): IVector64<Byte>; overload;
		{ class } function AddAcross(value: IVector128<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AddAcross(value: IVector128<Integer>): IVector64<Integer>; overload;
		{ class } function AddAcross(value: IVector128<Shortint>): IVector64<Shortint>; overload;
		{ class } function AddAcross(value: IVector128<Word>): IVector64<Word>; overload;
		{ class } function AddAcross(value: IVector128<longword>): IVector64<longword>; overload;
		{ class } function AddAcrossWidening(value: IVector64<Byte>): IVector64<Word>; overload;
		{ class } function AddAcrossWidening(value: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function AddAcrossWidening(value: IVector64<Shortint>): IVector64<SmallInt>; overload;
		{ class } function AddAcrossWidening(value: IVector64<Word>): IVector64<longword>; overload;
		{ class } function AddAcrossWidening(value: IVector128<Byte>): IVector64<Word>; overload;
		{ class } function AddAcrossWidening(value: IVector128<SmallInt>): IVector64<Integer>; overload;
		{ class } function AddAcrossWidening(value: IVector128<Integer>): IVector64<Int64>; overload;
		{ class } function AddAcrossWidening(value: IVector128<Shortint>): IVector64<SmallInt>; overload;
		{ class } function AddAcrossWidening(value: IVector128<Word>): IVector64<longword>; overload;
		{ class } function AddAcrossWidening(value: IVector128<longword>): IVector64<UInt64>; overload;
		{ class } function AddPairwise(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AddPairwise(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function AddPairwise(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AddPairwise(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AddPairwise(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function AddPairwise(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AddPairwise(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AddPairwise(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AddPairwise(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function AddPairwise(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function AddPairwiseScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function AddPairwiseScalar(value: IVector128<Double>): IVector64<Double>; overload;
		{ class } function AddPairwiseScalar(value: IVector128<Int64>): IVector64<Int64>; overload;
		{ class } function AddPairwiseScalar(value: IVector128<UInt64>): IVector64<UInt64>; overload;
		{ class } function AddSaturate(left: IVector64<Byte>; right: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function AddSaturate(left: IVector64<SmallInt>; right: IVector64<Word>): IVector64<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector64<Integer>; right: IVector64<longword>): IVector64<Integer>; overload;
		{ class } function AddSaturate(left: IVector64<Shortint>; right: IVector64<Byte>): IVector64<Shortint>; overload;
		{ class } function AddSaturate(left: IVector64<Word>; right: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function AddSaturate(left: IVector64<longword>; right: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function AddSaturate(left: IVector128<Byte>; right: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function AddSaturate(left: IVector128<SmallInt>; right: IVector128<Word>): IVector128<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector128<Integer>; right: IVector128<longword>): IVector128<Integer>; overload;
		{ class } function AddSaturate(left: IVector128<Int64>; right: IVector128<UInt64>): IVector128<Int64>; overload;
		{ class } function AddSaturate(left: IVector128<Shortint>; right: IVector128<Byte>): IVector128<Shortint>; overload;
		{ class } function AddSaturate(left: IVector128<Word>; right: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function AddSaturate(left: IVector128<longword>; right: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function AddSaturate(left: IVector128<UInt64>; right: IVector128<Int64>): IVector128<UInt64>; overload;
		{ class } function AddSaturateScalar(left: IVector64<longword>; right: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function AddSaturateScalar(left: IVector64<UInt64>; right: IVector64<Int64>): IVector64<UInt64>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Byte>; right: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function AddSaturateScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function AddSaturateScalar(left: IVector64<SmallInt>; right: IVector64<Word>): IVector64<SmallInt>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Integer>; right: IVector64<longword>): IVector64<Integer>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Int64>; right: IVector64<UInt64>): IVector64<Int64>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Shortint>; right: IVector64<Byte>): IVector64<Shortint>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function AddSaturateScalar(left: IVector64<Word>; right: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function AddSaturateScalar(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function Ceiling(value: IVector128<Double>): IVector128<Double>;
		{ class } function CompareEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareEqual(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareEqual(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareEqualScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareEqualScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareEqualScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareEqualScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareGreaterThan(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareGreaterThanOrEqualScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareGreaterThanOrEqualScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareGreaterThanOrEqualScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareGreaterThanOrEqualScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function CompareGreaterThanScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareGreaterThanScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareGreaterThanScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareGreaterThanScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function CompareLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareLessThan(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareLessThan(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareLessThanOrEqualScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareLessThanOrEqualScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareLessThanOrEqualScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareLessThanOrEqualScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function CompareLessThanScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareLessThanScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareLessThanScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function CompareLessThanScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function CompareTest(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareTest(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareTest(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function CompareTestScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function CompareTestScalar(left: IVector64<Int64>; right: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function CompareTestScalar(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector64<UInt64>; overload;
		{ class } function ConvertToDouble(value: IVector64<Single>): IVector128<Double>; overload;
		{ class } function ConvertToDouble(value: IVector128<Int64>): IVector128<Double>; overload;
		{ class } function ConvertToDouble(value: IVector128<UInt64>): IVector128<Double>; overload;
		{ class } function ConvertToDoubleScalar(value: IVector64<Int64>): IVector64<Double>; overload;
		{ class } function ConvertToDoubleScalar(value: IVector64<UInt64>): IVector64<Double>; overload;
		{ class } function ConvertToDoubleUpper(value: IVector128<Single>): IVector128<Double>;
		{ class } function ConvertToInt64RoundAwayFromZero(value: IVector128<Double>): IVector128<Int64>;
		{ class } function ConvertToInt64RoundAwayFromZeroScalar(value: IVector64<Double>): IVector64<Int64>;
		{ class } function ConvertToInt64RoundToEven(value: IVector128<Double>): IVector128<Int64>;
		{ class } function ConvertToInt64RoundToEvenScalar(value: IVector64<Double>): IVector64<Int64>;
		{ class } function ConvertToInt64RoundToNegativeInfinity(value: IVector128<Double>): IVector128<Int64>;
		{ class } function ConvertToInt64RoundToNegativeInfinityScalar(value: IVector64<Double>): IVector64<Int64>;
		{ class } function ConvertToInt64RoundToPositiveInfinity(value: IVector128<Double>): IVector128<Int64>;
		{ class } function ConvertToInt64RoundToPositiveInfinityScalar(value: IVector64<Double>): IVector64<Int64>;
		{ class } function ConvertToInt64RoundToZero(value: IVector128<Double>): IVector128<Int64>;
		{ class } function ConvertToInt64RoundToZeroScalar(value: IVector64<Double>): IVector64<Int64>;
		{ class } function ConvertToSingleLower(value: IVector128<Double>): IVector64<Single>;
		{ class } function ConvertToSingleRoundToOddLower(value: IVector128<Double>): IVector64<Single>;
		{ class } function ConvertToSingleRoundToOddUpper(lower: IVector64<Single>; value: IVector128<Double>): IVector128<Single>;
		{ class } function ConvertToSingleUpper(lower: IVector64<Single>; value: IVector128<Double>): IVector128<Single>;
		{ class } function ConvertToUInt64RoundAwayFromZero(value: IVector128<Double>): IVector128<UInt64>;
		{ class } function ConvertToUInt64RoundAwayFromZeroScalar(value: IVector64<Double>): IVector64<UInt64>;
		{ class } function ConvertToUInt64RoundToEven(value: IVector128<Double>): IVector128<UInt64>;
		{ class } function ConvertToUInt64RoundToEvenScalar(value: IVector64<Double>): IVector64<UInt64>;
		{ class } function ConvertToUInt64RoundToNegativeInfinity(value: IVector128<Double>): IVector128<UInt64>;
		{ class } function ConvertToUInt64RoundToNegativeInfinityScalar(value: IVector64<Double>): IVector64<UInt64>;
		{ class } function ConvertToUInt64RoundToPositiveInfinity(value: IVector128<Double>): IVector128<UInt64>;
		{ class } function ConvertToUInt64RoundToPositiveInfinityScalar(value: IVector64<Double>): IVector64<UInt64>;
		{ class } function ConvertToUInt64RoundToZero(value: IVector128<Double>): IVector128<UInt64>;
		{ class } function ConvertToUInt64RoundToZeroScalar(value: IVector64<Double>): IVector64<UInt64>;
		{ class } function Divide(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Divide(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Divide(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Double>; index: Byte): IVector128<Double>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<Int64>; index: Byte): IVector128<Int64>; overload;
		{ class } function DuplicateSelectedScalarToVector128(value: IVector128<UInt64>; index: Byte): IVector128<UInt64>; overload;
		{ class } function DuplicateToVector128(value: Double): IVector128<Double>; overload;
		{ class } function DuplicateToVector128(value: Int64): IVector128<Int64>; overload;
		{ class } function DuplicateToVector128(value: UInt64): IVector128<UInt64>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<Int64>): IVector64<Integer>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<SmallInt>): IVector64<Shortint>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<longword>): IVector64<Word>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<UInt64>): IVector64<longword>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<Word>): IVector64<Byte>; overload;
		{ class } function ExtractNarrowingSaturateScalar(value: IVector64<Integer>): IVector64<SmallInt>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedScalar(value: IVector64<SmallInt>): IVector64<Byte>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedScalar(value: IVector64<Integer>): IVector64<Word>; overload;
		{ class } function ExtractNarrowingSaturateUnsignedScalar(value: IVector64<Int64>): IVector64<longword>; overload;
		{ class } function Floor(value: IVector128<Double>): IVector128<Double>;
		{ class } function FusedMultiplyAdd(addend: IVector128<Double>; left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function FusedMultiplyAddByScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplyAddByScalar(addend: IVector128<Double>; left: IVector128<Double>; right: IVector64<Double>): IVector128<Double>; overload;
		{ class } function FusedMultiplyAddByScalar(addend: IVector128<Single>; left: IVector128<Single>; right: IVector64<Single>): IVector128<Single>; overload;
		{ class } function FusedMultiplyAddBySelectedScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplyAddBySelectedScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplyAddBySelectedScalar(addend: IVector128<Double>; left: IVector128<Double>; right: IVector128<Double>; rightIndex: Byte): IVector128<Double>; overload;
		{ class } function FusedMultiplyAddBySelectedScalar(addend: IVector128<Single>; left: IVector128<Single>; right: IVector64<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function FusedMultiplyAddBySelectedScalar(addend: IVector128<Single>; left: IVector128<Single>; right: IVector128<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function FusedMultiplyAddScalarBySelectedScalar(addend: IVector64<Double>; left: IVector64<Double>; right: IVector128<Double>; rightIndex: Byte): IVector64<Double>; overload;
		{ class } function FusedMultiplyAddScalarBySelectedScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplyAddScalarBySelectedScalar(addend: IVector64<Single>; left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtract(minuend: IVector128<Double>; left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function FusedMultiplySubtractByScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtractByScalar(minuend: IVector128<Double>; left: IVector128<Double>; right: IVector64<Double>): IVector128<Double>; overload;
		{ class } function FusedMultiplySubtractByScalar(minuend: IVector128<Single>; left: IVector128<Single>; right: IVector64<Single>): IVector128<Single>; overload;
		{ class } function FusedMultiplySubtractBySelectedScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtractBySelectedScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtractBySelectedScalar(minuend: IVector128<Double>; left: IVector128<Double>; right: IVector128<Double>; rightIndex: Byte): IVector128<Double>; overload;
		{ class } function FusedMultiplySubtractBySelectedScalar(minuend: IVector128<Single>; left: IVector128<Single>; right: IVector64<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function FusedMultiplySubtractBySelectedScalar(minuend: IVector128<Single>; left: IVector128<Single>; right: IVector128<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function FusedMultiplySubtractScalarBySelectedScalar(minuend: IVector64<Double>; left: IVector64<Double>; right: IVector128<Double>; rightIndex: Byte): IVector64<Double>; overload;
		{ class } function FusedMultiplySubtractScalarBySelectedScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function FusedMultiplySubtractScalarBySelectedScalar(minuend: IVector64<Single>; left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Byte>; resultIndex: Byte; value: IVector64<Byte>; valueIndex: Byte): IVector64<Byte>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Byte>; resultIndex: Byte; value: IVector128<Byte>; valueIndex: Byte): IVector64<Byte>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<SmallInt>; resultIndex: Byte; value: IVector64<SmallInt>; valueIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<SmallInt>; resultIndex: Byte; value: IVector128<SmallInt>; valueIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Integer>; resultIndex: Byte; value: IVector64<Integer>; valueIndex: Byte): IVector64<Integer>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Integer>; resultIndex: Byte; value: IVector128<Integer>; valueIndex: Byte): IVector64<Integer>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Shortint>; resultIndex: Byte; value: IVector64<Shortint>; valueIndex: Byte): IVector64<Shortint>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Shortint>; resultIndex: Byte; value: IVector128<Shortint>; valueIndex: Byte): IVector64<Shortint>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Single>; resultIndex: Byte; value: IVector64<Single>; valueIndex: Byte): IVector64<Single>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Single>; resultIndex: Byte; value: IVector128<Single>; valueIndex: Byte): IVector64<Single>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Word>; resultIndex: Byte; value: IVector64<Word>; valueIndex: Byte): IVector64<Word>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<Word>; resultIndex: Byte; value: IVector128<Word>; valueIndex: Byte): IVector64<Word>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<longword>; resultIndex: Byte; value: IVector64<longword>; valueIndex: Byte): IVector64<longword>; overload;
		{ class } function InsertSelectedScalar(result_: IVector64<longword>; resultIndex: Byte; value: IVector128<longword>; valueIndex: Byte): IVector64<longword>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Byte>; resultIndex: Byte; value: IVector64<Byte>; valueIndex: Byte): IVector128<Byte>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Byte>; resultIndex: Byte; value: IVector128<Byte>; valueIndex: Byte): IVector128<Byte>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Double>; resultIndex: Byte; value: IVector128<Double>; valueIndex: Byte): IVector128<Double>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<SmallInt>; resultIndex: Byte; value: IVector64<SmallInt>; valueIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<SmallInt>; resultIndex: Byte; value: IVector128<SmallInt>; valueIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Integer>; resultIndex: Byte; value: IVector64<Integer>; valueIndex: Byte): IVector128<Integer>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Integer>; resultIndex: Byte; value: IVector128<Integer>; valueIndex: Byte): IVector128<Integer>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Int64>; resultIndex: Byte; value: IVector128<Int64>; valueIndex: Byte): IVector128<Int64>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Shortint>; resultIndex: Byte; value: IVector64<Shortint>; valueIndex: Byte): IVector128<Shortint>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Shortint>; resultIndex: Byte; value: IVector128<Shortint>; valueIndex: Byte): IVector128<Shortint>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Single>; resultIndex: Byte; value: IVector64<Single>; valueIndex: Byte): IVector128<Single>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Single>; resultIndex: Byte; value: IVector128<Single>; valueIndex: Byte): IVector128<Single>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Word>; resultIndex: Byte; value: IVector64<Word>; valueIndex: Byte): IVector128<Word>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<Word>; resultIndex: Byte; value: IVector128<Word>; valueIndex: Byte): IVector128<Word>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<longword>; resultIndex: Byte; value: IVector64<longword>; valueIndex: Byte): IVector128<longword>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<longword>; resultIndex: Byte; value: IVector128<longword>; valueIndex: Byte): IVector128<longword>; overload;
		{ class } function InsertSelectedScalar(result_: IVector128<UInt64>; resultIndex: Byte; value: IVector128<UInt64>; valueIndex: Byte): IVector128<UInt64>; overload;
		{ class } function LoadAndReplicateToVector128(address: ICoreClrInstance): IVector128<Double>;
		{ class } function Max(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MaxAcross(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MaxAcross(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MaxAcross(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MaxAcross(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MaxAcross(value: IVector128<Byte>): IVector64<Byte>; overload;
		{ class } function MaxAcross(value: IVector128<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MaxAcross(value: IVector128<Integer>): IVector64<Integer>; overload;
		{ class } function MaxAcross(value: IVector128<Shortint>): IVector64<Shortint>; overload;
		{ class } function MaxAcross(value: IVector128<Single>): IVector64<Single>; overload;
		{ class } function MaxAcross(value: IVector128<Word>): IVector64<Word>; overload;
		{ class } function MaxAcross(value: IVector128<longword>): IVector64<longword>; overload;
		{ class } function MaxNumber(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MaxNumberAcross(value: IVector128<Single>): IVector64<Single>;
		{ class } function MaxNumberPairwise(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxNumberPairwise(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MaxNumberPairwise(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MaxNumberPairwiseScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxNumberPairwiseScalar(value: IVector128<Double>): IVector64<Double>; overload;
		{ class } function MaxPairwise(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function MaxPairwise(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MaxPairwise(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MaxPairwise(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MaxPairwise(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function MaxPairwise(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MaxPairwise(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MaxPairwise(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MaxPairwiseScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MaxPairwiseScalar(value: IVector128<Double>): IVector64<Double>; overload;
		{ class } function MaxScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MaxScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Min(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MinAcross(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function MinAcross(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MinAcross(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function MinAcross(value: IVector64<Word>): IVector64<Word>; overload;
		{ class } function MinAcross(value: IVector128<Byte>): IVector64<Byte>; overload;
		{ class } function MinAcross(value: IVector128<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MinAcross(value: IVector128<Integer>): IVector64<Integer>; overload;
		{ class } function MinAcross(value: IVector128<Shortint>): IVector64<Shortint>; overload;
		{ class } function MinAcross(value: IVector128<Single>): IVector64<Single>; overload;
		{ class } function MinAcross(value: IVector128<Word>): IVector64<Word>; overload;
		{ class } function MinAcross(value: IVector128<longword>): IVector64<longword>; overload;
		{ class } function MinNumber(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MinNumberAcross(value: IVector128<Single>): IVector64<Single>;
		{ class } function MinNumberPairwise(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinNumberPairwise(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MinNumberPairwise(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MinNumberPairwiseScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinNumberPairwiseScalar(value: IVector128<Double>): IVector64<Double>; overload;
		{ class } function MinPairwise(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function MinPairwise(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MinPairwise(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MinPairwise(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MinPairwise(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function MinPairwise(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MinPairwise(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MinPairwise(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MinPairwiseScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MinPairwiseScalar(value: IVector128<Double>): IVector64<Double>; overload;
		{ class } function MinScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MinScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function Multiply(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MultiplyByScalar(left: IVector128<Double>; right: IVector64<Double>): IVector128<Double>;
		{ class } function MultiplyBySelectedScalar(left: IVector128<Double>; right: IVector128<Double>; rightIndex: Byte): IVector128<Double>;
		{ class } function MultiplyDoublingSaturateHighScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingSaturateHighScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningAndAddSaturateScalar(addend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningAndAddSaturateScalar(addend: IVector64<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningAndSubtractSaturateScalar(minuend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningAndSubtractSaturateScalar(minuend: IVector64<Int64>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalarBySelectedScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalarBySelectedScalar(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalarBySelectedScalar(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningSaturateScalarBySelectedScalar(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend: IVector64<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend: IVector64<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend: IVector64<Integer>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend: IVector64<Int64>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend: IVector64<Int64>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Int64>; overload;
		{ class } function MultiplyExtended(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MultiplyExtended(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyExtended(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyExtendedByScalar(left: IVector128<Double>; right: IVector64<Double>): IVector128<Double>;
		{ class } function MultiplyExtendedBySelectedScalar(left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyExtendedBySelectedScalar(left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyExtendedBySelectedScalar(left: IVector128<Double>; right: IVector128<Double>; rightIndex: Byte): IVector128<Double>; overload;
		{ class } function MultiplyExtendedBySelectedScalar(left: IVector128<Single>; right: IVector64<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function MultiplyExtendedBySelectedScalar(left: IVector128<Single>; right: IVector128<Single>; rightIndex: Byte): IVector128<Single>; overload;
		{ class } function MultiplyExtendedScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function MultiplyExtendedScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function MultiplyExtendedScalarBySelectedScalar(left: IVector64<Double>; right: IVector128<Double>; rightIndex: Byte): IVector64<Double>; overload;
		{ class } function MultiplyExtendedScalarBySelectedScalar(left: IVector64<Single>; right: IVector64<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyExtendedScalarBySelectedScalar(left: IVector64<Single>; right: IVector128<Single>; rightIndex: Byte): IVector64<Single>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHighScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingSaturateHighScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyScalarBySelectedScalar(left: IVector64<Double>; right: IVector128<Double>; rightIndex: Byte): IVector64<Double>;
		{ class } function Negate(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Negate(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function NegateSaturate(value: IVector128<Int64>): IVector128<Int64>;
		{ class } function NegateSaturateScalar(value: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function NegateSaturateScalar(value: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function NegateSaturateScalar(value: IVector64<Int64>): IVector64<Int64>; overload;
		{ class } function NegateSaturateScalar(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function NegateScalar(value: IVector64<Int64>): IVector64<Int64>;
		{ class } function ReciprocalEstimate(value: IVector128<Double>): IVector128<Double>;
		{ class } function ReciprocalEstimateScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function ReciprocalEstimateScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalExponentScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function ReciprocalExponentScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalSquareRootEstimate(value: IVector128<Double>): IVector128<Double>;
		{ class } function ReciprocalSquareRootEstimateScalar(value: IVector64<Double>): IVector64<Double>; overload;
		{ class } function ReciprocalSquareRootEstimateScalar(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalSquareRootStep(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function ReciprocalSquareRootStepScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function ReciprocalSquareRootStepScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReciprocalStep(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function ReciprocalStepScalar(left: IVector64<Double>; right: IVector64<Double>): IVector64<Double>; overload;
		{ class } function ReciprocalStepScalar(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ReverseElementBits(value: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function ReverseElementBits(value: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ReverseElementBits(value: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function ReverseElementBits(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function RoundAwayFromZero(value: IVector128<Double>): IVector128<Double>;
		{ class } function RoundToNearest(value: IVector128<Double>): IVector128<Double>;
		{ class } function RoundToNegativeInfinity(value: IVector128<Double>): IVector128<Double>;
		{ class } function RoundToPositiveInfinity(value: IVector128<Double>): IVector128<Double>;
		{ class } function RoundToZero(value: IVector128<Double>): IVector128<Double>;
		{ class } function ShiftArithmeticRoundedSaturateScalar(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmeticRoundedSaturateScalar(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmeticRoundedSaturateScalar(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftArithmeticSaturateScalar(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftArithmeticSaturateScalar(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftArithmeticSaturateScalar(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<Byte>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<SmallInt>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<Integer>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<Shortint>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<Word>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftLogicalSaturateScalar(value: IVector64<longword>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsignedScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsignedScalar(value: IVector64<Integer>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftLeftLogicalSaturateUnsignedScalar(value: IVector64<Shortint>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogicalRoundedSaturateScalar(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<Byte>; count: IVector64<Shortint>): IVector64<Byte>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<SmallInt>; count: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<Integer>; count: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<Shortint>; count: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<Word>; count: IVector64<SmallInt>): IVector64<Word>; overload;
		{ class } function ShiftLogicalSaturateScalar(value: IVector64<longword>; count: IVector64<Integer>): IVector64<longword>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateScalar(value: IVector64<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateScalar(value: IVector64<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedScalar(value: IVector64<Integer>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightArithmeticNarrowingSaturateUnsignedScalar(value: IVector64<Int64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateScalar(value: IVector64<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateScalar(value: IVector64<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(value: IVector64<Integer>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(value: IVector64<Int64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalNarrowingSaturateScalar(value: IVector64<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<Word>; count: Byte): IVector64<Byte>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<Integer>; count: Byte): IVector64<SmallInt>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<Int64>; count: Byte): IVector64<Integer>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<SmallInt>; count: Byte): IVector64<Shortint>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<longword>; count: Byte): IVector64<Word>; overload;
		{ class } function ShiftRightLogicalRoundedNarrowingSaturateScalar(value: IVector64<UInt64>; count: Byte): IVector64<longword>; overload;
		{ class } function Sqrt(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Sqrt(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Sqrt(value: IVector64<Single>): IVector64<Single>; overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Byte>; value2: IVector64<Byte>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Double>; value2: IVector64<Double>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<SmallInt>; value2: IVector64<SmallInt>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Integer>; value2: IVector64<Integer>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Int64>; value2: IVector64<Int64>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Shortint>; value2: IVector64<Shortint>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Single>; value2: IVector64<Single>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<Word>; value2: IVector64<Word>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<longword>; value2: IVector64<longword>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector64<UInt64>; value2: IVector64<UInt64>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Byte>; value2: IVector128<Byte>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Double>; value2: IVector128<Double>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<SmallInt>; value2: IVector128<SmallInt>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Integer>; value2: IVector128<Integer>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Int64>; value2: IVector128<Int64>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Shortint>; value2: IVector128<Shortint>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Single>; value2: IVector128<Single>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<Word>; value2: IVector128<Word>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<longword>; value2: IVector128<longword>); overload;
		{ class } procedure StorePair(address: ICoreClrInstance; value1: IVector128<UInt64>; value2: IVector128<UInt64>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Byte>; value2: IVector64<Byte>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Double>; value2: IVector64<Double>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<SmallInt>; value2: IVector64<SmallInt>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Integer>; value2: IVector64<Integer>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Int64>; value2: IVector64<Int64>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Shortint>; value2: IVector64<Shortint>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Single>; value2: IVector64<Single>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<Word>; value2: IVector64<Word>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<longword>; value2: IVector64<longword>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector64<UInt64>; value2: IVector64<UInt64>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Byte>; value2: IVector128<Byte>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Double>; value2: IVector128<Double>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<SmallInt>; value2: IVector128<SmallInt>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Integer>; value2: IVector128<Integer>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Int64>; value2: IVector128<Int64>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Shortint>; value2: IVector128<Shortint>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Single>; value2: IVector128<Single>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<Word>; value2: IVector128<Word>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<longword>; value2: IVector128<longword>); overload;
		{ class } procedure StorePairNonTemporal(address: ICoreClrInstance; value1: IVector128<UInt64>; value2: IVector128<UInt64>); overload;
		{ class } procedure StorePairScalar(address: ICoreClrInstance; value1: IVector64<Integer>; value2: IVector64<Integer>); overload;
		{ class } procedure StorePairScalar(address: ICoreClrInstance; value1: IVector64<Single>; value2: IVector64<Single>); overload;
		{ class } procedure StorePairScalar(address: ICoreClrInstance; value1: IVector64<longword>; value2: IVector64<longword>); overload;
		{ class } procedure StorePairScalarNonTemporal(address: ICoreClrInstance; value1: IVector64<Integer>; value2: IVector64<Integer>); overload;
		{ class } procedure StorePairScalarNonTemporal(address: ICoreClrInstance; value1: IVector64<Single>; value2: IVector64<Single>); overload;
		{ class } procedure StorePairScalarNonTemporal(address: ICoreClrInstance; value1: IVector64<longword>; value2: IVector64<longword>); overload;
		{ class } function Subtract(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function SubtractSaturateScalar(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function SubtractSaturateScalar(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function TransposeEven(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function TransposeEven(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function TransposeEven(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function TransposeEven(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function TransposeEven(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function TransposeEven(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function TransposeEven(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function TransposeEven(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function TransposeEven(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function TransposeEven(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function TransposeEven(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function TransposeEven(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function TransposeEven(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function TransposeEven(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function TransposeEven(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function TransposeEven(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function TransposeEven(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function TransposeOdd(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function TransposeOdd(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function TransposeOdd(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function TransposeOdd(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function TransposeOdd(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function TransposeOdd(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function TransposeOdd(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function TransposeOdd(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function TransposeOdd(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function TransposeOdd(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function TransposeOdd(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function TransposeOdd(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function TransposeOdd(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function TransposeOdd(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function TransposeOdd(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function TransposeOdd(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function TransposeOdd(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function UnzipEven(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function UnzipEven(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function UnzipEven(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function UnzipEven(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function UnzipEven(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function UnzipEven(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function UnzipEven(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function UnzipEven(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function UnzipEven(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function UnzipEven(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function UnzipEven(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function UnzipEven(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function UnzipEven(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function UnzipEven(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function UnzipEven(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function UnzipEven(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function UnzipEven(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function UnzipOdd(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function UnzipOdd(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function UnzipOdd(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function UnzipOdd(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function UnzipOdd(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function UnzipOdd(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function UnzipOdd(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function UnzipOdd(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function UnzipOdd(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function UnzipOdd(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function UnzipOdd(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function UnzipOdd(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function UnzipOdd(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function UnzipOdd(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function UnzipOdd(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function UnzipOdd(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function UnzipOdd(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function VectorTableLookup(table: IVector128<Byte>; byteIndexes: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function VectorTableLookup(table: IVector128<Shortint>; byteIndexes: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function VectorTableLookupExtension(defaultValues: IVector128<Byte>; table: IVector128<Byte>; byteIndexes: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function VectorTableLookupExtension(defaultValues: IVector128<Shortint>; table: IVector128<Shortint>; byteIndexes: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ZipHigh(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function ZipHigh(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ZipHigh(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ZipHigh(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ZipHigh(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ZipHigh(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function ZipHigh(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ZipHigh(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function ZipHigh(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function ZipHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ZipHigh(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ZipHigh(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ZipHigh(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ZipHigh(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ZipHigh(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function ZipHigh(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ZipHigh(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ZipLow(left: IVector64<Byte>; right: IVector64<Byte>): IVector64<Byte>; overload;
		{ class } function ZipLow(left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function ZipLow(left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function ZipLow(left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Shortint>; overload;
		{ class } function ZipLow(left: IVector64<Single>; right: IVector64<Single>): IVector64<Single>; overload;
		{ class } function ZipLow(left: IVector64<Word>; right: IVector64<Word>): IVector64<Word>; overload;
		{ class } function ZipLow(left: IVector64<longword>; right: IVector64<longword>): IVector64<longword>; overload;
		{ class } function ZipLow(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function ZipLow(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function ZipLow(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ZipLow(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ZipLow(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ZipLow(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function ZipLow(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ZipLow(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function ZipLow(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ZipLow(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	{$ENDIF}
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64)]
	IArm64 = interface(IArm64_2)
	['{372C936E-E46F-4A15-BAEB-C72355E6AAEC}']
	end;

	IAesClass = interface(ICoreClrClass)
	['{D3EA375B-34D1-4CBA-A3F1-52E646989615}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Decrypt(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function Encrypt(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function InverseMixColumns(value: IVector128<Byte>): IVector128<Byte>;
		{ class } function MixColumns(value: IVector128<Byte>): IVector128<Byte>;
		{ class } function PolynomialMultiplyWideningLower(left: IVector64<Int64>; right: IVector64<Int64>): IVector128<Int64>; overload;
		{ class } function PolynomialMultiplyWideningLower(left: IVector64<UInt64>; right: IVector64<UInt64>): IVector128<UInt64>; overload;
		{ class } function PolynomialMultiplyWideningUpper(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function PolynomialMultiplyWideningUpper(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_AES)]
	IAes = interface(IArmBase)
	['{1CBED1ED-3B31-4C75-8687-61EF01EC0B3C}']
	end;

	IArm64_1Class = interface(ICoreClrClass)
	['{0B675533-A086-40BF-BDD6-6BF4AA3E03B5}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_2)]
	IArm64_1 = interface(IArm64_2)
	['{931E0348-E876-435C-B76D-A3C066BB1368}']
	end;

	IX86BaseClass = interface(ICoreClrClass)
	['{9FF7CEBA-AAC0-4561-9AE6-E414B86C455A}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function CpuId(functionId: Integer; subFunctionId: Integer): IValueTuple<Integer, Integer, Integer, Integer>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X86BASE)]
	IX86Base = interface(IObject)
	['{5C53C6CB-CCC3-4FB1-A3D9-65CD8CCF47C0}']
	end;

	ISseClass = interface(ICoreClrClass)
	['{799FC81C-2267-451C-A143-A8722435AD7B}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Add(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function AddScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function &And(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function AndNot(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareNotEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareNotGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareNotGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareNotLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareNotLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareOrdered(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarNotEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarNotGreaterThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarNotGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarNotLessThan(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarNotLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarOrdered(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarOrderedEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarOrderedGreaterThan(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarOrderedGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarOrderedLessThan(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarOrderedLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarOrderedNotEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnordered(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function CompareScalarUnorderedEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnorderedGreaterThan(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnorderedGreaterThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnorderedLessThan(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnorderedLessThanOrEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareScalarUnorderedNotEqual(left: IVector128<Single>; right: IVector128<Single>): Boolean;
		{ class } function CompareUnordered(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function ConvertScalarToVector128Single(upper: IVector128<Single>; value: Integer): IVector128<Single>;
		{ class } function ConvertToInt32(value: IVector128<Single>): Integer;
		{ class } function ConvertToInt32WithTruncation(value: IVector128<Single>): Integer;
		{ class } function Divide(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function DivideScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function LoadAlignedVector128(address: ICoreClrInstance): IVector128<Single>;
		{ class } function LoadHigh(lower: IVector128<Single>; address: ICoreClrInstance): IVector128<Single>;
		{ class } function LoadLow(upper: IVector128<Single>; address: ICoreClrInstance): IVector128<Single>;
		{ class } function LoadScalarVector128(address: ICoreClrInstance): IVector128<Single>;
		{ class } function LoadVector128(address: ICoreClrInstance): IVector128<Single>;
		{ class } function Max(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MaxScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function Min(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MinScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MoveHighToLow(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MoveLowToHigh(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MoveMask(value: IVector128<Single>): Integer;
		{ class } function MoveScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>;
		{ class } function Multiply(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function MultiplyScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function &Or(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } procedure Prefetch0(address: ICoreClrInstance);
		{ class } procedure Prefetch1(address: ICoreClrInstance);
		{ class } procedure Prefetch2(address: ICoreClrInstance);
		{ class } procedure PrefetchNonTemporal(address: ICoreClrInstance);
		{ class } function Reciprocal(value: IVector128<Single>): IVector128<Single>;
		{ class } function ReciprocalScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalSqrt(value: IVector128<Single>): IVector128<Single>;
		{ class } function ReciprocalSqrtScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function ReciprocalSqrtScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Shuffle(left: IVector128<Single>; right: IVector128<Single>; control: Byte): IVector128<Single>;
		{ class } function Sqrt(value: IVector128<Single>): IVector128<Single>;
		{ class } function SqrtScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function SqrtScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } procedure StoreFence();
		{ class } procedure StoreHigh(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } procedure StoreLow(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<Single>);
		{ class } function Subtract(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function SubtractScalar(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function UnpackHigh(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function UnpackLow(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } function &Xor(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSE)]
	ISse = interface(IX86Base)
	['{ECD52C77-EFE6-434B-86D1-24BB0C1F3809}']
	end;

	ISse2Class = interface(ICoreClrClass)
	['{C73F6694-2AC7-49CC-B461-C5A142648561}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Add(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Add(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Add(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Add(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Add(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Add(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Add(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function Add(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function Add(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function AddSaturate(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AddSaturate(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AddSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AddScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function &And(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &And(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &And(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &And(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &And(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &And(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &And(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &And(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function &And(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function AndNot(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function AndNot(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function AndNot(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function AndNot(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function AndNot(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function AndNot(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function AndNot(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function AndNot(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function AndNot(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Average(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Average(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareEqual(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareEqual(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function CompareEqual(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareEqual(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function CompareEqual(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareEqual(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function CompareEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareGreaterThan(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareLessThan(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function CompareLessThan(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function CompareLessThan(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function CompareLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareNotEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareNotGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareNotGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareNotLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareNotLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareOrdered(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarNotEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarNotGreaterThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarNotGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarNotLessThan(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarNotLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarOrdered(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarOrderedEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarOrderedGreaterThan(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarOrderedGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarOrderedLessThan(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarOrderedLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarOrderedNotEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnordered(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function CompareScalarUnorderedEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnorderedGreaterThan(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnorderedGreaterThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnorderedLessThan(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnorderedLessThanOrEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareScalarUnorderedNotEqual(left: IVector128<Double>; right: IVector128<Double>): Boolean;
		{ class } function CompareUnordered(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function ConvertScalarToVector128Double(upper: IVector128<Double>; value: Integer): IVector128<Double>; overload;
		{ class } function ConvertScalarToVector128Double(upper: IVector128<Double>; value: IVector128<Single>): IVector128<Double>; overload;
		{ class } function ConvertScalarToVector128Int32(value: Integer): IVector128<Integer>;
		{ class } function ConvertScalarToVector128Single(upper: IVector128<Single>; value: IVector128<Double>): IVector128<Single>;
		{ class } function ConvertScalarToVector128UInt32(value: longword): IVector128<longword>;
		{ class } function ConvertToInt32(value: IVector128<Double>): Integer; overload;
		{ class } function ConvertToInt32(value: IVector128<Integer>): Integer; overload;
		{ class } function ConvertToInt32WithTruncation(value: IVector128<Double>): Integer;
		{ class } function ConvertToUInt32(value: IVector128<longword>): longword;
		{ class } function ConvertToVector128Double(value: IVector128<Integer>): IVector128<Double>; overload;
		{ class } function ConvertToVector128Double(value: IVector128<Single>): IVector128<Double>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<Double>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32WithTruncation(value: IVector128<Single>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32WithTruncation(value: IVector128<Double>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Single(value: IVector128<Integer>): IVector128<Single>; overload;
		{ class } function ConvertToVector128Single(value: IVector128<Double>): IVector128<Single>; overload;
		{ class } function Divide(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function DivideScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function Extract(value: IVector128<Word>; index: Byte): Word;
		{ class } function Insert(value: IVector128<SmallInt>; data: SmallInt; index: Byte): IVector128<SmallInt>; overload;
		{ class } function Insert(value: IVector128<Word>; data: Word; index: Byte): IVector128<Word>; overload;
		{ class } function LoadAlignedVector128(address: ICoreClrInstance): IVector128<Shortint>;
		{ class } procedure LoadFence();
		{ class } function LoadHigh(lower: IVector128<Double>; address: ICoreClrInstance): IVector128<Double>;
		{ class } function LoadLow(upper: IVector128<Double>; address: ICoreClrInstance): IVector128<Double>;
		{ class } function LoadScalarVector128(address: ICoreClrInstance): IVector128<Double>;
		{ class } function LoadVector128(address: ICoreClrInstance): IVector128<Shortint>;
		{ class } procedure MaskMove(source: IVector128<Shortint>; mask: IVector128<Shortint>; address: ICoreClrInstance); overload;
		{ class } procedure MaskMove(source: IVector128<Byte>; mask: IVector128<Byte>; address: ICoreClrInstance); overload;
		{ class } function Max(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Max(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Max(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MaxScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } procedure MemoryFence();
		{ class } function Min(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Min(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Min(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MinScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function MoveMask(value: IVector128<Shortint>): Integer; overload;
		{ class } function MoveMask(value: IVector128<Byte>): Integer; overload;
		{ class } function MoveMask(value: IVector128<Double>): Integer; overload;
		{ class } function MoveScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MoveScalar(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function MoveScalar(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function Multiply(left: IVector128<longword>; right: IVector128<longword>): IVector128<UInt64>; overload;
		{ class } function Multiply(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAddAdjacent(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Integer>;
		{ class } function MultiplyHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyHigh(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MultiplyLow(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyLow(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function MultiplyScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function &Or(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &Or(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &Or(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &Or(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &Or(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &Or(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &Or(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &Or(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function &Or(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function PackSignedSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Shortint>; overload;
		{ class } function PackSignedSaturate(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<SmallInt>; overload;
		{ class } function PackUnsignedSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<Byte>;
		{ class } function ShiftLeftLogical(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Word>; count: IVector128<Word>): IVector128<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<longword>; count: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<UInt64>; count: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogical(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<Shortint>; numBytes: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<Byte>; numBytes: Byte): IVector128<Byte>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<SmallInt>; numBytes: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<Word>; numBytes: Byte): IVector128<Word>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<Integer>; numBytes: Byte): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<longword>; numBytes: Byte): IVector128<longword>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<Int64>; numBytes: Byte): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector128<UInt64>; numBytes: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector128<SmallInt>; count: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Word>; count: IVector128<Word>): IVector128<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Integer>; count: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector128<longword>; count: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Int64>; count: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function ShiftRightLogical(value: IVector128<UInt64>; count: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogical(value: IVector128<SmallInt>; count: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Word>; count: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Integer>; count: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector128<longword>; count: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector128<Int64>; count: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogical(value: IVector128<UInt64>; count: Byte): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<Shortint>; numBytes: Byte): IVector128<Shortint>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<Byte>; numBytes: Byte): IVector128<Byte>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<SmallInt>; numBytes: Byte): IVector128<SmallInt>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<Word>; numBytes: Byte): IVector128<Word>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<Integer>; numBytes: Byte): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<longword>; numBytes: Byte): IVector128<longword>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<Int64>; numBytes: Byte): IVector128<Int64>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector128<UInt64>; numBytes: Byte): IVector128<UInt64>; overload;
		{ class } function Shuffle(value: IVector128<longword>; control: Byte): IVector128<longword>; overload;
		{ class } function Shuffle(value: IVector128<Integer>; control: Byte): IVector128<Integer>; overload;
		{ class } function Shuffle(left: IVector128<Double>; right: IVector128<Double>; control: Byte): IVector128<Double>; overload;
		{ class } function ShuffleHigh(value: IVector128<SmallInt>; control: Byte): IVector128<SmallInt>; overload;
		{ class } function ShuffleHigh(value: IVector128<Word>; control: Byte): IVector128<Word>; overload;
		{ class } function ShuffleLow(value: IVector128<SmallInt>; control: Byte): IVector128<SmallInt>; overload;
		{ class } function ShuffleLow(value: IVector128<Word>; control: Byte): IVector128<Word>; overload;
		{ class } function Sqrt(value: IVector128<Double>): IVector128<Double>;
		{ class } function SqrtScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function SqrtScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Shortint>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Byte>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<SmallInt>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Word>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Integer>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<longword>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Int64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<UInt64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector128<Double>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Shortint>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Byte>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<SmallInt>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Word>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Integer>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<longword>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Int64>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<UInt64>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector128<Double>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Shortint>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Byte>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<SmallInt>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Word>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Integer>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<longword>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Int64>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<UInt64>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector128<Double>); overload;
		{ class } procedure StoreHigh(address: ICoreClrInstance; source: IVector128<Double>);
		{ class } procedure StoreLow(address: ICoreClrInstance; source: IVector128<Double>);
		{ class } procedure StoreNonTemporal(address: ICoreClrInstance; value: Integer); overload;
		{ class } procedure StoreNonTemporal(address: ICoreClrInstance; value: longword); overload;
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<Double>); overload;
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<Integer>); overload;
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<Int64>); overload;
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<longword>); overload;
		{ class } procedure StoreScalar(address: ICoreClrInstance; source: IVector128<UInt64>); overload;
		{ class } function Subtract(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Subtract(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Subtract(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Subtract(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Subtract(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Subtract(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Subtract(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function Subtract(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function Subtract(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function SubtractSaturate(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function SubtractSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function SubtractSaturate(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function SubtractSaturate(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function SubtractScalar(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>;
		{ class } function SumAbsoluteDifferences(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Word>;
		{ class } function UnpackHigh(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function UnpackHigh(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function UnpackHigh(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function UnpackHigh(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function UnpackHigh(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function UnpackHigh(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function UnpackHigh(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function UnpackHigh(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function UnpackHigh(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function UnpackLow(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function UnpackLow(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function UnpackLow(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function UnpackLow(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function UnpackLow(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function UnpackLow(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function UnpackLow(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function UnpackLow(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function UnpackLow(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function &Xor(left: IVector128<Byte>; right: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function &Xor(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function &Xor(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function &Xor(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function &Xor(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function &Xor(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function &Xor(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function &Xor(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function &Xor(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSE2)]
	ISse2 = interface(ISse)
	['{5F0AC880-CAE6-4731-A456-D2277235C0CA}']
	end;

	IAes_1Class = interface(ICoreClrClass)
	['{90BF33A7-6EDA-4B71-814D-B0B8CC2EE0CF}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Decrypt(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function DecryptLast(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function Encrypt(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function EncryptLast(value: IVector128<Byte>; roundKey: IVector128<Byte>): IVector128<Byte>;
		{ class } function InverseMixColumns(value: IVector128<Byte>): IVector128<Byte>;
		{ class } function KeygenAssist(value: IVector128<Byte>; control: Byte): IVector128<Byte>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_AES)]
	IAes_1 = interface(ISse2)
	['{E1228E4C-6E70-4D92-86AB-4C7C3CDA297E}']
	end;

	IX64_15Class = interface(ICoreClrClass)
	['{C444496E-3A4E-4193-81C3-03F44B0C8805}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_16)]
	IX64_15 = interface(IObject)
	['{546378CA-550C-467E-AE75-F8E3FA860D94}']
	end;

	IX64_9Class = interface(ICoreClrClass)
	['{F6F5B719-B035-48B0-B71F-75B3FC1B1304}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function ConvertScalarToVector128Single(upper: IVector128<Single>; value: Int64): IVector128<Single>;
		{ class } function ConvertToInt64(value: IVector128<Single>): Int64;
		{ class } function ConvertToInt64WithTruncation(value: IVector128<Single>): Int64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_10)]
	IX64_9 = interface(IX64_15)
	['{6472E5B6-D622-4B42-97E2-F8BCD2BB2CDE}']
	end;

	IX64_10Class = interface(ICoreClrClass)
	['{B19D8151-88B6-48E7-BA6C-4CCE3FBA4327}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function ConvertScalarToVector128Double(upper: IVector128<Double>; value: Int64): IVector128<Double>;
		{ class } function ConvertScalarToVector128Int64(value: Int64): IVector128<Int64>;
		{ class } function ConvertScalarToVector128UInt64(value: UInt64): IVector128<UInt64>;
		{ class } function ConvertToInt64(value: IVector128<Double>): Int64; overload;
		{ class } function ConvertToInt64(value: IVector128<Int64>): Int64; overload;
		{ class } function ConvertToInt64WithTruncation(value: IVector128<Double>): Int64;
		{ class } function ConvertToUInt64(value: IVector128<UInt64>): UInt64;
		{ class } procedure StoreNonTemporal(address: ICoreClrInstance; value: Int64); overload;
		{ class } procedure StoreNonTemporal(address: ICoreClrInstance; value: UInt64); overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_11)]
	IX64_10 = interface(IX64_9)
	['{44A0024D-B59C-4327-B4B1-07A093116500}']
	end;

	IX64Class = interface(ICoreClrClass)
	['{698DE7B2-29C9-430D-BB2A-3C2E93BA035E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64)]
	IX64 = interface(IX64_10)
	['{5F817410-55A8-4663-91EE-8C3703F397E2}']
	end;

	[CoreTypeSignature(SYSTEM_AGGREGATEEXCEPTION)]
	IAggregateException = interface(IException)
	['{4B0422D0-61D4-4932-9E4A-CA47A7952EA9}']
	{ private }
		function _GetProp_InnerExceptions: IReadOnlyCollection<IException>;
		function _GetProp_Message: String;
	{ public }
		function Flatten(): IAggregateException;
		function GetBaseException(): IException;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure Handle(predicate: TClrFunc<IException, Boolean>);
		property InnerExceptions: IReadOnlyCollection<IException> read _GetProp_InnerExceptions;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_ALLOWNULLATTRIBUTE)]
	IAllowNullAttribute = interface(IAttribute)
	['{F89A53BF-D38A-47D3-96CC-705381DEBB94}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_ALLOWPARTIALLYTRUSTEDCALLERSATTRIBUTE)]
	IAllowPartiallyTrustedCallersAttribute = interface(IAttribute)
	['{9E0E19C9-A304-43E7-97A3-4070DEC5A0B9}']
	{ private }
		function _GetProp_PartialTrustVisibilityLevel: TPartialTrustVisibilityLevel;
		procedure _SetProp_PartialTrustVisibilityLevel(Value: TPartialTrustVisibilityLevel);
	{ public }
		property PartialTrustVisibilityLevel: TPartialTrustVisibilityLevel read _GetProp_PartialTrustVisibilityLevel write _SetProp_PartialTrustVisibilityLevel;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ALLOWREVERSEPINVOKECALLSATTRIBUTE)]
	IAllowReversePInvokeCallsAttribute = interface(IAttribute)
	['{FAD3E59E-42E8-4A0C-A98D-C1A2FF0A21C8}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_AMBIGUOUSIMPLEMENTATIONEXCEPTION)]
	IAmbiguousImplementationException = interface(IException)
	['{F07BF6A8-39BF-403B-AAF7-F51338B25093}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_AMBIGUOUSMATCHEXCEPTION)]
	IAmbiguousMatchException = interface(ISystemException)
	['{86FDA91C-DED7-4B67-8750-31FDCBC1C8C2}']
	end;

	IAppContextClass = interface(ICoreClrClass)
	['{33067484-A2BA-4E42-9431-E87592701383}']
	{ private }
		{ class } function _GetProp_BaseDirectory: String;
		{ class } function _GetProp_TargetFrameworkName: String;
		{ class } function _GetEvt_FirstChanceException: TEventHandler<IFirstChanceExceptionEventArgs>;
		{ class } procedure _SetEvt_FirstChanceException(Value: TEventHandler<IFirstChanceExceptionEventArgs>);
		{ class } function _GetEvt_ProcessExit: TEventHandler;
		{ class } procedure _SetEvt_ProcessExit(Value: TEventHandler);
		{ class } function _GetEvt_UnhandledException: TUnhandledExceptionEventHandler;
		{ class } procedure _SetEvt_UnhandledException(Value: TUnhandledExceptionEventHandler);
	{ public }
		{ class } function GetData(name: String): Variant;
		{ class } procedure SetData(name: String; data: Variant);
		{ class } procedure SetSwitch(switchName: String; isEnabled: Boolean);
		{ class } function TryGetSwitch(switchName: String; var isEnabled: Boolean): Boolean;
		{ class } property BaseDirectory: String read _GetProp_BaseDirectory;
		{ class } property TargetFrameworkName: String read _GetProp_TargetFrameworkName;
		{ class } property FirstChanceException: TEventHandler<IFirstChanceExceptionEventArgs> read _GetEvt_FirstChanceException write _SetEvt_FirstChanceException;
		{ class } property ProcessExit: TEventHandler read _GetEvt_ProcessExit write _SetEvt_ProcessExit;
		{ class } property UnhandledException: TUnhandledExceptionEventHandler read _GetEvt_UnhandledException write _SetEvt_UnhandledException;
	end;

	[CoreTypeSignature(SYSTEM_APPCONTEXT)]
	IAppContext = interface(IObject)
	['{EDB4852B-EFE3-4005-B253-941DF58B693A}']
	end;

	IAppDomainClass = interface(ICoreClrClass)
	['{BBB454CD-A654-4934-8F8E-35059A8FEACE}']
	{ private }
		{ class } function _GetProp_CurrentDomain: IAppDomain;
		{ class } function _GetProp_MonitoringIsEnabled: Boolean;
		{ class } procedure _SetProp_MonitoringIsEnabled(Value: Boolean);
		{ class } function _GetProp_MonitoringSurvivedProcessMemorySize: Int64;
	{ public }
		{ class } function CreateDomain(friendlyName: String): IAppDomain;
		{ class } function GetCurrentThreadId(): Integer;
		{ class } procedure Unload(domain: IAppDomain);
		{ class } property CurrentDomain: IAppDomain read _GetProp_CurrentDomain;
		{ class } property MonitoringIsEnabled: Boolean read _GetProp_MonitoringIsEnabled write _SetProp_MonitoringIsEnabled;
		{ class } property MonitoringSurvivedProcessMemorySize: Int64 read _GetProp_MonitoringSurvivedProcessMemorySize;
	end;

	[CoreTypeSignature(SYSTEM_APPDOMAIN)]
	IAppDomain = interface(IMarshalByRefObject)
	['{95518AB9-39D2-4D91-8944-230096283801}']
	{ private }
		function _GetProp_BaseDirectory: String;
		function _GetProp_DynamicDirectory: String;
		function _GetProp_FriendlyName: String;
		function _GetProp_Id: Integer;
		function _GetProp_IsFullyTrusted: Boolean;
		function _GetProp_IsHomogenous: Boolean;
		function _GetProp_MonitoringSurvivedMemorySize: Int64;
		function _GetProp_MonitoringTotalAllocatedMemorySize: Int64;
		function _GetProp_MonitoringTotalProcessorTime: ITimeSpan;
		function _GetProp_PermissionSet: IPermissionSet;
		function _GetProp_RelativeSearchPath: String;
		function _GetProp_SetupInformation: IAppDomainSetup;
		function _GetProp_ShadowCopyFiles: Boolean;
		function _GetEvt_AssemblyLoad: TAssemblyLoadEventHandler;
		procedure _SetEvt_AssemblyLoad(Value: TAssemblyLoadEventHandler);
		function _GetEvt_AssemblyResolve: TResolveEventHandler;
		procedure _SetEvt_AssemblyResolve(Value: TResolveEventHandler);
		function _GetEvt_DomainUnload: TEventHandler;
		procedure _SetEvt_DomainUnload(Value: TEventHandler);
		function _GetEvt_FirstChanceException: TEventHandler<IFirstChanceExceptionEventArgs>;
		procedure _SetEvt_FirstChanceException(Value: TEventHandler<IFirstChanceExceptionEventArgs>);
		function _GetEvt_ProcessExit: TEventHandler;
		procedure _SetEvt_ProcessExit(Value: TEventHandler);
		function _GetEvt_ReflectionOnlyAssemblyResolve: TResolveEventHandler;
		procedure _SetEvt_ReflectionOnlyAssemblyResolve(Value: TResolveEventHandler);
		function _GetEvt_ResourceResolve: TResolveEventHandler;
		procedure _SetEvt_ResourceResolve(Value: TResolveEventHandler);
		function _GetEvt_TypeResolve: TResolveEventHandler;
		procedure _SetEvt_TypeResolve(Value: TResolveEventHandler);
		function _GetEvt_UnhandledException: TUnhandledExceptionEventHandler;
		procedure _SetEvt_UnhandledException(Value: TUnhandledExceptionEventHandler);
	{ public }
		procedure AppendPrivatePath(path: String);
		function ApplyPolicy(assemblyName: String): String;
		procedure ClearPrivatePath();
		procedure ClearShadowCopyPath();
		function CreateInstance(assemblyName: String; typeName: String): IObjectHandle; overload;
		function CreateInstance(assemblyName: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		function CreateInstance(assemblyName: String; typeName: String; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		function CreateInstanceAndUnwrap(assemblyName: String; typeName: String): Variant; overload;
		function CreateInstanceAndUnwrap(assemblyName: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): Variant; overload;
		function CreateInstanceAndUnwrap(assemblyName: String; typeName: String; activationAttributes: TArray<Variant>): Variant; overload;
		function CreateInstanceFrom(assemblyFile: String; typeName: String): IObjectHandle; overload;
		function CreateInstanceFrom(assemblyFile: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		function CreateInstanceFrom(assemblyFile: String; typeName: String; activationAttributes: TArray<Variant>): IObjectHandle; overload;
		function CreateInstanceFromAndUnwrap(assemblyFile: String; typeName: String): Variant; overload;
		function CreateInstanceFromAndUnwrap(assemblyFile: String; typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): Variant; overload;
		function CreateInstanceFromAndUnwrap(assemblyFile: String; typeName: String; activationAttributes: TArray<Variant>): Variant; overload;
		function ExecuteAssembly(assemblyFile: String): Integer; overload;
		function ExecuteAssembly(assemblyFile: String; args: TArray<String>): Integer; overload;
		function ExecuteAssembly(assemblyFile: String; args: TArray<String>; hashValue: TArray<Byte>; hashAlgorithm: TAssemblyHashAlgorithm): Integer; overload;
		function ExecuteAssemblyByName(assemblyName: IAssemblyName; args: TArray<String>): Integer; overload;
		function ExecuteAssemblyByName(assemblyName: String; args: TArray<String>): Integer; overload;
		function ExecuteAssemblyByName(assemblyName: String): Integer; overload;
		function GetAssemblies(): TArray<IAssembly>;
		function GetData(name: String): Variant;
		function IsCompatibilitySwitchSet(value: String): Nullable<Boolean>;
		function IsDefaultAppDomain(): Boolean;
		function IsFinalizingForUnload(): Boolean;
		function Load(rawAssembly: TArray<Byte>): IAssembly; overload;
		function Load(assemblyRef: IAssemblyName): IAssembly; overload;
		function Load(assemblyString: String): IAssembly; overload;
		function Load(rawAssembly: TArray<Byte>; rawSymbolStore: TArray<Byte>): IAssembly; overload;
		function ReflectionOnlyGetAssemblies(): TArray<IAssembly>;
		procedure SetCachePath(path: String);
		procedure SetData(name: String; data: Variant);
		procedure SetDynamicBase(path: String);
		procedure SetPrincipalPolicy(policy: TPrincipalPolicy);
		procedure SetShadowCopyFiles();
		procedure SetShadowCopyPath(path: String);
		procedure SetThreadPrincipal(principal: IIPrincipal);
		property BaseDirectory: String read _GetProp_BaseDirectory;
		property DynamicDirectory: String read _GetProp_DynamicDirectory;
		property FriendlyName: String read _GetProp_FriendlyName;
		property Id: Integer read _GetProp_Id;
		property IsFullyTrusted: Boolean read _GetProp_IsFullyTrusted;
		property IsHomogenous: Boolean read _GetProp_IsHomogenous;
		property MonitoringSurvivedMemorySize: Int64 read _GetProp_MonitoringSurvivedMemorySize;
		property MonitoringTotalAllocatedMemorySize: Int64 read _GetProp_MonitoringTotalAllocatedMemorySize;
		property MonitoringTotalProcessorTime: ITimeSpan read _GetProp_MonitoringTotalProcessorTime;
		property PermissionSet: IPermissionSet read _GetProp_PermissionSet;
		property RelativeSearchPath: String read _GetProp_RelativeSearchPath;
		property SetupInformation: IAppDomainSetup read _GetProp_SetupInformation;
		property ShadowCopyFiles: Boolean read _GetProp_ShadowCopyFiles;
		property AssemblyLoad: TAssemblyLoadEventHandler read _GetEvt_AssemblyLoad write _SetEvt_AssemblyLoad;
		property AssemblyResolve: TResolveEventHandler read _GetEvt_AssemblyResolve write _SetEvt_AssemblyResolve;
		property DomainUnload: TEventHandler read _GetEvt_DomainUnload write _SetEvt_DomainUnload;
		property FirstChanceException: TEventHandler<IFirstChanceExceptionEventArgs> read _GetEvt_FirstChanceException write _SetEvt_FirstChanceException;
		property ProcessExit: TEventHandler read _GetEvt_ProcessExit write _SetEvt_ProcessExit;
		property ReflectionOnlyAssemblyResolve: TResolveEventHandler read _GetEvt_ReflectionOnlyAssemblyResolve write _SetEvt_ReflectionOnlyAssemblyResolve;
		property ResourceResolve: TResolveEventHandler read _GetEvt_ResourceResolve write _SetEvt_ResourceResolve;
		property TypeResolve: TResolveEventHandler read _GetEvt_TypeResolve write _SetEvt_TypeResolve;
		property UnhandledException: TUnhandledExceptionEventHandler read _GetEvt_UnhandledException write _SetEvt_UnhandledException;
	end;

	[CoreTypeSignature(SYSTEM_APPDOMAINSETUP)]
	IAppDomainSetup = interface(IObject)
	['{C349379D-7AB2-43F3-97EB-FBC8BC1832B3}']
	{ private }
		function _GetProp_ApplicationBase: String;
		function _GetProp_TargetFrameworkName: String;
	{ public }
		property ApplicationBase: String read _GetProp_ApplicationBase;
		property TargetFrameworkName: String read _GetProp_TargetFrameworkName;
	end;

	[CoreTypeSignature(SYSTEM_APPDOMAINUNLOADEDEXCEPTION)]
	IAppDomainUnloadedException = interface(ISystemException)
	['{80AE6D47-5697-4B16-884C-5E97F91CAB41}']
	end;

	[CoreTypeSignature(SYSTEM_APPLICATIONEXCEPTION)]
	IApplicationException = interface(IException)
	['{29922C44-2534-4A81-AD83-EF93AD2F8051}']
	end;

	[CoreTypeSignature(SYSTEM_APPLICATIONID)]
	IApplicationId = interface(IObject)
	['{C3DE1CC0-24F2-4439-9A50-08E17716D60D}']
	{ private }
		function _GetProp_Culture: String;
		function _GetProp_Name: String;
		function _GetProp_ProcessorArchitecture: String;
		function _GetProp_PublicKeyToken: TArray<Byte>;
		function _GetProp_Version: IVersion;
	{ public }
		function Copy(): IApplicationId;
		property Culture: String read _GetProp_Culture;
		property Name: String read _GetProp_Name;
		property ProcessorArchitecture: String read _GetProp_ProcessorArchitecture;
		property PublicKeyToken: TArray<Byte> read _GetProp_PublicKeyToken;
		property Version: IVersion read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_VALUETYPE)]
	IValueType = interface(IObject)
	['{59CC1A0D-77C4-4572-80D5-DA8806658B5C}']
	end;

	[CoreTypeSignature(SYSTEM_ARGITERATOR)]
	IArgIterator = interface(IValueType)
	['{0A8218C1-7ABC-432D-BD22-DBABD7A72101}']
	{ public }
		procedure &End();
		function GetNextArg(): ITypedReference; overload;
		function GetNextArg(rth: IRuntimeTypeHandle): ITypedReference; overload;
		function GetNextArgType(): IRuntimeTypeHandle;
		function GetRemainingCount(): Integer;
	end;

	[CoreTypeSignature(SYSTEM_ARGUMENTEXCEPTION)]
	IArgumentException = interface(ISystemException)
	['{2FD4CAC6-5FFD-4006-A346-C6358C42FC3E}']
	{ private }
		function _GetProp_Message: String;
		function _GetProp_ParamName: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
		property ParamName: String read _GetProp_ParamName;
	end;

	[CoreTypeSignature(SYSTEM_ARGUMENTNULLEXCEPTION)]
	IArgumentNullException = interface(IArgumentException)
	['{81B3590B-36CE-4561-8516-EEB5FBB42A90}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_ARGUMENTOUTOFRANGEEXCEPTION)]
	IArgumentOutOfRangeException = interface(IArgumentException)
	['{12D922CE-639B-416E-AB4E-ED291E44E455}']
	{ private }
		function _GetProp_ActualValue: Variant;
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property ActualValue: Variant read _GetProp_ActualValue;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_ARITHMETICEXCEPTION)]
	IArithmeticException = interface(ISystemException)
	['{7616CA8D-2892-462B-8CF8-EECAB0550AB1}']
	end;

	IArm64_3Class = interface(ICoreClrClass)
	['{F6EE1D06-3193-41FC-9AF4-1CB87EEB17D5}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function ComputeCrc32(crc: longword; data: UInt64): longword;
		{ class } function ComputeCrc32C(crc: longword; data: UInt64): longword;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_4)]
	IArm64_3 = interface(IArm64_2)
	['{A49590D7-AAA0-49BD-A4E3-C28B5DAD05CF}']
	end;

	IArm64_4Class = interface(ICoreClrClass)
	['{D586AF58-CE44-41C9-8D34-B322DAA80982}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_5)]
	IArm64_4 = interface(IArm64)
	['{5D0A5F8D-ADAA-4857-B79C-A6C567E49F3E}']
	end;

	IArm64_5Class = interface(ICoreClrClass)
	['{376075E8-D6CE-4269-B295-EB31C73A9BFC}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function MultiplyRoundedDoublingAndAddSaturateHighScalar(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndAddSaturateHighScalar(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHighScalar(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHighScalar(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndAddSaturateHigh(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndAddSaturateHigh(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndAddSaturateHigh(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndAddSaturateHigh(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingScalarBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_6)]
	IArm64_5 = interface(IArm64)
	['{F8259EE0-5938-4DEB-8438-32F8D279B4E3}']
	end;

	IArm64_6Class = interface(ICoreClrClass)
	['{2A6D5120-0AC7-40AC-BEB5-AF9F265155F5}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_7)]
	IArm64_6 = interface(IArm64_2)
	['{AD0CC66A-56A9-4231-9A63-86AF544F932E}']
	end;

	IArm64_7Class = interface(ICoreClrClass)
	['{668098A7-FCD8-4455-967E-CDAB3CC2E579}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_ARM64_8)]
	IArm64_7 = interface(IArm64_2)
	['{A191ADA2-76C3-4E14-85F5-EA50C7819220}']
	end;

	IArrayClass = interface(ICoreClrClass)
	['{1730224A-56AA-460F-AC15-9245EF8E8915}']
	{ public }
		{ class } function AsReadOnly(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>): IReadOnlyCollection<Variant{T}>;
		{ class } function BinarySearch(array_: IArray; value: Variant): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function BinarySearch(array_: IArray; index: Integer; length: Integer; value: Variant): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; length: Integer; value: Variant{T}): Integer; overload;
		{ class } function BinarySearch(array_: IArray; value: Variant; comparer: IIComparer): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; comparer: IIComparer<Variant{T}>): Integer; overload;
		{ class } function BinarySearch(array_: IArray; index: Integer; length: Integer; value: Variant; comparer: IIComparer): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; length: Integer; value: Variant{T}; comparer: IIComparer<Variant{T}>): Integer; overload;
		{ class } procedure Clear(array_: IArray; index: Integer; length: Integer);
		{ class } procedure ConstrainedCopy(sourceArray: IArray; sourceIndex: Integer; destinationArray: IArray; destinationIndex: Integer; length: Integer);
		{ class } function ConvertAll(TInput: PTypeInfo; TOutput: PTypeInfo; array_: ICoreClrBridgeArray<Variant{TInput}>; converter: TConverter<Variant{TInput}, Variant{TOutput}>): ICoreClrBridgeArray<Variant{TOutput}>;
		{ class } procedure Copy(sourceArray: IArray; destinationArray: IArray; length: Integer); overload;
		{ class } procedure Copy(sourceArray: IArray; destinationArray: IArray; length: Int64); overload;
		{ class } procedure Copy(sourceArray: IArray; sourceIndex: Integer; destinationArray: IArray; destinationIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(sourceArray: IArray; sourceIndex: Int64; destinationArray: IArray; destinationIndex: Int64; length: Int64); overload;
		{ class } function CreateInstance(elementType: IType; length: Integer): IArray; overload;
		{ class } function CreateInstance(elementType: IType; lengths: TArray<Integer>): IArray; overload;
		{ class } function CreateInstance(elementType: IType; lengths: TArray<Int64>): IArray; overload;
		{ class } function CreateInstance(elementType: IType; length1: Integer; length2: Integer): IArray; overload;
		{ class } function CreateInstance(elementType: IType; lengths: TArray<Integer>; lowerBounds: TArray<Integer>): IArray; overload;
		{ class } function CreateInstance(elementType: IType; length1: Integer; length2: Integer; length3: Integer): IArray; overload;
		{ class } function Empty(T: PTypeInfo): ICoreClrBridgeArray<Variant{T}>;

		{ class } function Exists(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Boolean;
		{ class } procedure Fill(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}); overload;
		{ class } procedure Fill(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; startIndex: Integer; count: Integer); overload;
		{ class } function Find(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Variant{T};
		{ class } function FindAll(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): ICoreClrBridgeArray<Variant{T}>;
		{ class } function FindIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } function FindIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: Integer; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } function FindIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: Integer; count: Integer; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } function FindLast(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Variant{T};
		{ class } function FindLastIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } function FindLastIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: Integer; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } function FindLastIndex(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: Integer; count: Integer; match: TClrPredicate<Variant{T}>): Integer; overload;
		{ class } procedure ForEach(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; action: TClrAction<Variant{T}>);
		{ class } function IndexOf(array_: IArray; value: Variant): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function IndexOf(array_: IArray; value: Variant; startIndex: Integer): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; startIndex: Integer): Integer; overload;
		{ class } function IndexOf(array_: IArray; value: Variant; startIndex: Integer; count: Integer): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; startIndex: Integer; count: Integer): Integer; overload;
		{ class } function LastIndexOf(array_: IArray; value: Variant): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function LastIndexOf(array_: IArray; value: Variant; startIndex: Integer): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; startIndex: Integer): Integer; overload;
		{ class } function LastIndexOf(array_: IArray; value: Variant; startIndex: Integer; count: Integer): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; value: Variant{T}; startIndex: Integer; count: Integer): Integer; overload;
		{ class } procedure Resize(T: PTypeInfo; var array_: ICoreClrBridgeArray<Variant{T}>; newSize: Integer);
		{ class } procedure Reverse(array_: IArray); overload;
		{ class } procedure Reverse(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>); overload;
		{ class } procedure Reverse(array_: IArray; index: Integer; length: Integer); overload;
		{ class } procedure Reverse(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; length: Integer); overload;
		{ class } procedure Sort(array_: IArray); overload;
		{ class } procedure Sort(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>); overload;
		{ class } procedure Sort(keys: IArray; items: IArray); overload;
		{ class } procedure Sort(array_: IArray; comparer: IIComparer); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ICoreClrBridgeArray<Variant{TKey}>; items: ICoreClrBridgeArray<Variant{TValue}>); overload;
		{ class } procedure Sort(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; comparer: IIComparer<Variant{T}>); overload;
		{ class } procedure Sort(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; comparison: TComparison<Variant{T}>); overload;
		{ class } procedure Sort(array_: IArray; index: Integer; length: Integer); overload;
		{ class } procedure Sort(keys: IArray; items: IArray; comparer: IIComparer); overload;
		{ class } procedure Sort(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; length: Integer); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ICoreClrBridgeArray<Variant{TKey}>; items: ICoreClrBridgeArray<Variant{TValue}>; comparer: IIComparer<Variant{TKey}>); overload;
		{ class } procedure Sort(keys: IArray; items: IArray; index: Integer; length: Integer); overload;
		{ class } procedure Sort(array_: IArray; index: Integer; length: Integer; comparer: IIComparer); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ICoreClrBridgeArray<Variant{TKey}>; items: ICoreClrBridgeArray<Variant{TValue}>; index: Integer; length: Integer); overload;
		{ class } procedure Sort(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; length: Integer; comparer: IIComparer<Variant{T}>); overload;
		{ class } procedure Sort(keys: IArray; items: IArray; index: Integer; length: Integer; comparer: IIComparer); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ICoreClrBridgeArray<Variant{TKey}>; items: ICoreClrBridgeArray<Variant{TValue}>; index: Integer; length: Integer; comparer: IIComparer<Variant{TKey}>); overload;
		{ class } function TrueForAll(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; match: TClrPredicate<Variant{T}>): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_ARRAY_)]
	IArray = interface(IObject)
	['{B6950D45-61B8-4C48-B56A-68D65665126F}']
	{ private }
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_Length: Integer;
		function _GetProp_LongLength: Int64;
		function _GetProp_Rank: Integer;
		function _GetProp_SyncRoot: Variant;
	{ public }
		function Clone(): Variant;
		procedure CopyTo(array_: IArray; index: Integer); overload;
		procedure CopyTo(array_: IArray; index: Int64); overload;
		function GetEnumerator(): IIEnumerator;
		function GetLength(dimension: Integer): Integer;
		function GetLongLength(dimension: Integer): Int64;
		function GetLowerBound(dimension: Integer): Integer;
		function GetUpperBound(dimension: Integer): Integer;
		function GetValue(indices: TArray<Integer>): Variant; overload;
		function GetValue(index: Integer): Variant; overload;
		function GetValue(index: Int64): Variant; overload;
		function GetValue(indices: TArray<Int64>): Variant; overload;
		function GetValue(index1: Integer; index2: Integer): Variant; overload;
		function GetValue(index1: Int64; index2: Int64): Variant; overload;
		function GetValue(index1: Integer; index2: Integer; index3: Integer): Variant; overload;
		function GetValue(index1: Int64; index2: Int64; index3: Int64): Variant; overload;
		procedure Initialize();
		procedure SetValue(value: Variant; index: Integer); overload;
		procedure SetValue(value: Variant; indices: TArray<Integer>); overload;
		procedure SetValue(value: Variant; index: Int64); overload;
		procedure SetValue(value: Variant; indices: TArray<Int64>); overload;
		procedure SetValue(value: Variant; index1: Integer; index2: Integer); overload;
		procedure SetValue(value: Variant; index1: Int64; index2: Int64); overload;
		procedure SetValue(value: Variant; index1: Integer; index2: Integer; index3: Integer); overload;
		procedure SetValue(value: Variant; index1: Int64; index2: Int64; index3: Int64); overload;
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property Length: Integer read _GetProp_Length;
		property LongLength: Int64 read _GetProp_LongLength;
		property Rank: Integer read _GetProp_Rank;
		property SyncRoot: Variant read _GetProp_SyncRoot;
	end;

	IArrayListClass = interface(ICoreClrClass)
	['{80CB2D1F-F376-475D-BBA2-D22249140F6B}']
	{ public }
		{ class } function Adapter(list: IIList): IArrayList;
		{ class } function FixedSize(list: IIList): IIList; overload;
		{ class } function FixedSize(list: IArrayList): IArrayList; overload;
		{ class } function &ReadOnly(list: IIList): IIList; overload;
		{ class } function &ReadOnly(list: IArrayList): IArrayList; overload;
		{ class } function &Repeat(value: Variant; count: Integer): IArrayList;
		{ class } function Synchronized(list: IIList): IIList; overload;
		{ class } function Synchronized(list: IArrayList): IArrayList; overload;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ARRAYLIST)]
	IArrayList = interface(IObject)
	['{DBB5D5CE-6926-48F7-B6F6-D064F008C1E8}']
	{ private }
		function _GetProp_Capacity: Integer;
		procedure _SetProp_Capacity(Value: Integer);
		function _GetProp_Count: Integer;
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_Item(index: Integer): Variant;
		procedure _SetProp_Item(index: Integer; Value: Variant);
		function _GetProp_SyncRoot: Variant;
	{ public }
		function Add(value: Variant): Integer;
		procedure AddRange(c: IICollection);
		function BinarySearch(index: Integer; count: Integer; value: Variant; comparer: IIComparer): Integer; overload;
		function BinarySearch(value: Variant): Integer; overload;
		function BinarySearch(value: Variant; comparer: IIComparer): Integer; overload;
		procedure Clear();
		function Clone(): Variant;
		function Contains(item: Variant): Boolean;
		procedure CopyTo(array_: IArray); overload;
		procedure CopyTo(array_: IArray; arrayIndex: Integer); overload;
		procedure CopyTo(index: Integer; array_: IArray; arrayIndex: Integer; count: Integer); overload;
		function GetEnumerator(): IIEnumerator; overload;
		function GetEnumerator(index: Integer; count: Integer): IIEnumerator; overload;
		function GetRange(index: Integer; count: Integer): IArrayList;
		function IndexOf(value: Variant): Integer; overload;
		function IndexOf(value: Variant; startIndex: Integer): Integer; overload;
		function IndexOf(value: Variant; startIndex: Integer; count: Integer): Integer; overload;
		procedure Insert(index: Integer; value: Variant);
		procedure InsertRange(index: Integer; c: IICollection);
		function LastIndexOf(value: Variant): Integer; overload;
		function LastIndexOf(value: Variant; startIndex: Integer): Integer; overload;
		function LastIndexOf(value: Variant; startIndex: Integer; count: Integer): Integer; overload;
		procedure Remove(obj: Variant);
		procedure RemoveAt(index: Integer);
		procedure RemoveRange(index: Integer; count: Integer);
		procedure Reverse(); overload;
		procedure Reverse(index: Integer; count: Integer); overload;
		procedure SetRange(index: Integer; c: IICollection);
		procedure Sort(); overload;
		procedure Sort(comparer: IIComparer); overload;
		procedure Sort(index: Integer; count: Integer; comparer: IIComparer); overload;
		function ToArray(): TArray<Variant>; overload;
		function ToArray(type_: IType): IArray; overload;
		procedure TrimToSize();
		property Capacity: Integer read _GetProp_Capacity write _SetProp_Capacity;
		property Count: Integer read _GetProp_Count;
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property Item[index: Integer]: Variant read _GetProp_Item write _SetProp_Item; default;
		property SyncRoot: Variant read _GetProp_SyncRoot;
	end;

	IArrayPoolClass<T> = interface(ICoreClrClass)
	['{CA189AF6-9B51-4491-B60B-657121BC3265}']
	{ private }
		{ class } function _GetProp_Shared: IArrayPool<T>;
	{ public }
		{ class } function Create(): IArrayPool<T>; overload;
		{ class } function Create(maxArrayLength: Integer; maxArraysPerBucket: Integer): IArrayPool<T>; overload;
		{ class } property Shared: IArrayPool<T> read _GetProp_Shared;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_ARRAYPOOL_1)]
	IArrayPool<T> = interface(IObject)
	['{915967BA-D688-4271-B056-45B3346FB2AD}']
	{ public }
		function Rent(minimumLength: Integer): TArray<T>;
		procedure Return(array_: ICoreClrBridgeArray<T>; clearArray: Boolean);
	end;

	IArraySegmentClass<T> = interface(ICoreClrClass)
	['{A6E8C6E0-B98F-4547-BD5C-57B59B2095EC}']
	{ private }
		{ class } function _GetProp_Empty: IArraySegment<T>;
	{ public }
		{ class } property Empty: IArraySegment<T> read _GetProp_Empty;
	end;

	[CoreTypeSignature(SYSTEM_ARRAYSEGMENT_1)]
	IArraySegment<T> = interface(IValueType)
	['{3E67BD96-DBCA-4237-ADB1-D4D526C280F5}']
	{ private }
		function _GetProp_Array: TArray<T>;
		function _GetProp_Count: Integer;
		function _GetProp_Item(index: Integer): T;
		procedure _SetProp_Item(index: Integer; Value: T);
		function _GetProp_Offset: Integer;
	{ public }
		procedure CopyTo(destination: ICoreClrBridgeArray<T>); overload;
		procedure CopyTo(destination: IArraySegment<T>); overload;
		procedure CopyTo(destination: ICoreClrBridgeArray<T>; destinationIndex: Integer); overload;
		function Equals(obj: IArraySegment<T>): Boolean;
		function GetEnumerator(): IArraySegment_Enumerator<T>;
		function Slice(index: Integer): IArraySegment<T>; overload;
		function Slice(index: Integer; count: Integer): IArraySegment<T>; overload;
		function ToArray(): TArray<T>;
		property &Array: TArray<T> read _GetProp_Array;
		property Count: Integer read _GetProp_Count;
		property Item[index: Integer]: T read _GetProp_Item write _SetProp_Item; default;
		property Offset: Integer read _GetProp_Offset;
	end;

	[CoreTypeSignature(SYSTEM_ENUMERATOR)]
	IArraySegment_Enumerator<T> = interface(IValueType)
	['{49237DCD-A820-4B65-B993-5587A3E5E1B3}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_ARRAYTYPEMISMATCHEXCEPTION)]
	IArrayTypeMismatchException = interface(ISystemException)
	['{30473619-8C6B-44B7-83FC-83C42771C5A9}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ARRAYWITHOFFSET)]
	IArrayWithOffset = interface(IValueType)
	['{BFFA5BEE-9921-489D-8002-6C7B5E1B421D}']
	{ public }
		function Equals(obj: IArrayWithOffset): Boolean;
		function GetArray(): Variant;
		function GetOffset(): Integer;
	end;

	[CoreTypeSignature(SYSTEM_ICLONEABLE)]
	IICloneable = interface(IObject)
	['{48CB2519-ABC5-4CBA-939A-ECED5AC46574}']
	{ public }
		function Clone(): Variant;
	end;

	IEncodingClass = interface(ICoreClrClass)
	['{6C0D0FE3-75BF-4699-B772-F4ED62E830E6}']
	{ private }
		{ class } function _GetProp_ASCII: IEncoding;
		{ class } function _GetProp_BigEndianUnicode: IEncoding;
		{ class } function _GetProp_Default: IEncoding;
		{ class } function _GetProp_Latin1: IEncoding;
		{ class } function _GetProp_Unicode: IEncoding;
		{ class } function _GetProp_UTF32: IEncoding;
		{ class } function _GetProp_UTF7: IEncoding;
		{ class } function _GetProp_UTF8: IEncoding;
	{ public }
		{ class } function Convert(srcEncoding: IEncoding; dstEncoding: IEncoding; bytes: TArray<Byte>): TArray<Byte>; overload;
		{ class } function Convert(srcEncoding: IEncoding; dstEncoding: IEncoding; bytes: TArray<Byte>; index: Integer; count: Integer): TArray<Byte>; overload;
		{ class } function CreateTranscodingStream(innerStream: IStream; innerStreamEncoding: IEncoding; outerStreamEncoding: IEncoding; leaveOpen: Boolean): IStream;
		{ class } function GetEncoding(codepage: Integer): IEncoding; overload;
		{ class } function GetEncoding(name: String): IEncoding; overload;
		{ class } function GetEncoding(codepage: Integer; encoderFallback: IEncoderFallback; decoderFallback: IDecoderFallback): IEncoding; overload;
		{ class } function GetEncoding(name: String; encoderFallback: IEncoderFallback; decoderFallback: IDecoderFallback): IEncoding; overload;
		{ class } function GetEncodings(): TArray<IEncodingInfo>;
		{ class } procedure RegisterProvider(provider: IEncodingProvider);
		{ class } property ASCII: IEncoding read _GetProp_ASCII;
		{ class } property BigEndianUnicode: IEncoding read _GetProp_BigEndianUnicode;
		{ class } property &Default: IEncoding read _GetProp_Default;
		{ class } property Latin1: IEncoding read _GetProp_Latin1;
		{ class } property Unicode: IEncoding read _GetProp_Unicode;
		{ class } property UTF32: IEncoding read _GetProp_UTF32;
		{ class } property UTF7: IEncoding read _GetProp_UTF7;
		{ class } property UTF8: IEncoding read _GetProp_UTF8;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODING)]
	IEncoding = interface(IICloneable)
	['{1D38E786-DE42-4897-9566-A168BA5C8D14}']
	{ private }
		function _GetProp_BodyName: String;
		function _GetProp_CodePage: Integer;
		function _GetProp_DecoderFallback: IDecoderFallback;
		procedure _SetProp_DecoderFallback(Value: IDecoderFallback);
		function _GetProp_EncoderFallback: IEncoderFallback;
		procedure _SetProp_EncoderFallback(Value: IEncoderFallback);
		function _GetProp_EncodingName: String;
		function _GetProp_HeaderName: String;
		function _GetProp_IsBrowserDisplay: Boolean;
		function _GetProp_IsBrowserSave: Boolean;
		function _GetProp_IsMailNewsDisplay: Boolean;
		function _GetProp_IsMailNewsSave: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSingleByte: Boolean;
		function _GetProp_Preamble: IReadOnlySpan<Byte>;
		function _GetProp_WebName: String;
		function _GetProp_WindowsCodePage: Integer;
	{ public }
		function Clone(): Variant;
		function GetByteCount(chars: TArray<Char>): Integer; overload;
		function GetByteCount(s: String): Integer; overload;
		function GetByteCount(chars: IReadOnlySpan<Char>): Integer; overload;
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(s: String; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>): TArray<Byte>; overload;
		function GetBytes(s: String): TArray<Byte>; overload;
		function GetBytes(chars: TArray<Char>; index: Integer; count: Integer): TArray<Byte>; overload;
		function GetBytes(s: String; index: Integer; count: Integer): TArray<Byte>; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(s: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetBytes(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>): Integer; overload;
		function GetCharCount(bytes: IReadOnlySpan<Byte>): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetChars(bytes: TArray<Byte>): TArray<Char>; overload;
		function GetChars(bytes: TArray<Byte>; index: Integer; count: Integer): TArray<Char>; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetChars(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetPreamble(): TArray<Byte>;
		function GetString(bytes: ICoreClrInstance; byteCount: Integer): String; overload;
		function GetString(bytes: IReadOnlySpan<Byte>): String; overload;
		function GetString(bytes: TArray<Byte>): String; overload;
		function GetString(bytes: TArray<Byte>; index: Integer; count: Integer): String; overload;
		function IsAlwaysNormalized(): Boolean; overload;
		function IsAlwaysNormalized(form: TNormalizationForm): Boolean; overload;
		property BodyName: String read _GetProp_BodyName;
		property CodePage: Integer read _GetProp_CodePage;
		property DecoderFallback: IDecoderFallback read _GetProp_DecoderFallback write _SetProp_DecoderFallback;
		property EncoderFallback: IEncoderFallback read _GetProp_EncoderFallback write _SetProp_EncoderFallback;
		property EncodingName: String read _GetProp_EncodingName;
		property HeaderName: String read _GetProp_HeaderName;
		property IsBrowserDisplay: Boolean read _GetProp_IsBrowserDisplay;
		property IsBrowserSave: Boolean read _GetProp_IsBrowserSave;
		property IsMailNewsDisplay: Boolean read _GetProp_IsMailNewsDisplay;
		property IsMailNewsSave: Boolean read _GetProp_IsMailNewsSave;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSingleByte: Boolean read _GetProp_IsSingleByte;
		property Preamble: IReadOnlySpan<Byte> read _GetProp_Preamble;
		property WebName: String read _GetProp_WebName;
		property WindowsCodePage: Integer read _GetProp_WindowsCodePage;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ASCIIENCODING)]
	IASCIIEncoding = interface(IEncoding)
	['{9C7B22DE-ECAA-4A1E-B209-6EB28F917484}']
	{ private }
		function _GetProp_IsSingleByte: Boolean;
	{ public }
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(chars: String): Integer; overload;
		function GetByteCount(chars: IReadOnlySpan<Char>): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(chars: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetBytes(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetCharCount(bytes: IReadOnlySpan<Byte>): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetChars(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetString(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer): String;
		property IsSingleByte: Boolean read _GetProp_IsSingleByte;
	end;

	IAssemblyClass = interface(ICoreClrClass)
	['{D30C8C60-6335-418F-B283-060C482FFDC7}']
	{ public }
		{ class } function CreateQualifiedName(assemblyName: String; typeName: String): String;
		{ class } function GetAssembly(type_: IType): IAssembly;
		{ class } function GetCallingAssembly(): IAssembly;
		{ class } function GetEntryAssembly(): IAssembly;
		{ class } function GetExecutingAssembly(): IAssembly;
		{ class } function Load(assemblyString: String): IAssembly; overload;
		{ class } function Load(assemblyRef: IAssemblyName): IAssembly; overload;
		{ class } function Load(rawAssembly: TArray<Byte>): IAssembly; overload;
		{ class } function Load(rawAssembly: TArray<Byte>; rawSymbolStore: TArray<Byte>): IAssembly; overload;
		{ class } function LoadFile(path: String): IAssembly;
		{ class } function LoadFrom(assemblyFile: String): IAssembly; overload;
		{ class } function LoadFrom(assemblyFile: String; hashValue: TArray<Byte>; hashAlgorithm: TAssemblyHashAlgorithm): IAssembly; overload;
		{ class } function LoadWithPartialName(partialName: String): IAssembly;
		{ class } function ReflectionOnlyLoad(rawAssembly: TArray<Byte>): IAssembly; overload;
		{ class } function ReflectionOnlyLoad(assemblyString: String): IAssembly; overload;
		{ class } function ReflectionOnlyLoadFrom(assemblyFile: String): IAssembly;
		{ class } function UnsafeLoadFrom(assemblyFile: String): IAssembly;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLY)]
	IAssembly = interface(IObject)
	['{D8F3E0D9-5E66-4127-954A-5532833F48A2}']
	{ private }
		function _GetProp_CodeBase: String;
		function _GetProp_CustomAttributes: IIEnumerable<ICustomAttributeData>;
		function _GetProp_DefinedTypes: IIEnumerable<ITypeInfo>;
		function _GetProp_EntryPoint: IMethodInfo;
		function _GetProp_EscapedCodeBase: String;
		function _GetProp_ExportedTypes: IIEnumerable<IType>;
		function _GetProp_FullName: String;
		function _GetProp_GlobalAssemblyCache: Boolean;
		function _GetProp_HostContext: Int64;
		function _GetProp_ImageRuntimeVersion: String;
		function _GetProp_IsCollectible: Boolean;
		function _GetProp_IsDynamic: Boolean;
		function _GetProp_IsFullyTrusted: Boolean;
		function _GetProp_Location: String;
		function _GetProp_ManifestModule: IModule;
		function _GetProp_Modules: IIEnumerable<IModule>;
		function _GetProp_ReflectionOnly: Boolean;
		function _GetProp_SecurityRuleSet: TSecurityRuleSet;
		function _GetEvt_ModuleResolve: TModuleResolveEventHandler;
		procedure _SetEvt_ModuleResolve(Value: TModuleResolveEventHandler);
	{ public }
		function CreateInstance(typeName: String): Variant; overload;
		function CreateInstance(typeName: String; ignoreCase: Boolean): Variant; overload;
		function CreateInstance(typeName: String; ignoreCase: Boolean; bindingAttr: TBindingFlags_Set; binder: IBinder; args: TArray<Variant>; culture: ICultureInfo; activationAttributes: TArray<Variant>): Variant; overload;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function GetExportedTypes(): TArray<IType>;
		function GetFile(name: String): IFileStream;
		function GetFiles(): TArray<IFileStream>; overload;
		function GetFiles(getResourceModules: Boolean): TArray<IFileStream>; overload;
		function GetForwardedTypes(): TArray<IType>;
		function GetLoadedModules(): TArray<IModule>; overload;
		function GetLoadedModules(getResourceModules: Boolean): TArray<IModule>; overload;
		function GetManifestResourceInfo(resourceName: String): IManifestResourceInfo;
		function GetManifestResourceNames(): TArray<String>;
		function GetManifestResourceStream(name: String): IStream; overload;
		function GetManifestResourceStream(type_: IType; name: String): IStream; overload;
		function GetModule(name: String): IModule;
		function GetModules(): TArray<IModule>; overload;
		function GetModules(getResourceModules: Boolean): TArray<IModule>; overload;
		function GetName(): IAssemblyName; overload;
		function GetName(copiedName: Boolean): IAssemblyName; overload;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		function GetReferencedAssemblies(): TArray<IAssemblyName>;
		function GetSatelliteAssembly(culture: ICultureInfo): IAssembly; overload;
		function GetSatelliteAssembly(culture: ICultureInfo; version: IVersion): IAssembly; overload;
		function GetType(name: String): IType; overload;
		function GetType(name: String; throwOnError: Boolean): IType; overload;
		function GetType(name: String; throwOnError: Boolean; ignoreCase: Boolean): IType; overload;
		function GetTypes(): TArray<IType>;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function LoadModule(moduleName: String; rawModule: TArray<Byte>): IModule; overload;
		function LoadModule(moduleName: String; rawModule: TArray<Byte>; rawSymbolStore: TArray<Byte>): IModule; overload;
		property CodeBase: String read _GetProp_CodeBase;
		property CustomAttributes: IIEnumerable<ICustomAttributeData> read _GetProp_CustomAttributes;
		property DefinedTypes: IIEnumerable<ITypeInfo> read _GetProp_DefinedTypes;
		property EntryPoint: IMethodInfo read _GetProp_EntryPoint;
		property EscapedCodeBase: String read _GetProp_EscapedCodeBase;
		property ExportedTypes: IIEnumerable<IType> read _GetProp_ExportedTypes;
		property FullName: String read _GetProp_FullName;
		property GlobalAssemblyCache: Boolean read _GetProp_GlobalAssemblyCache;
		property HostContext: Int64 read _GetProp_HostContext;
		property ImageRuntimeVersion: String read _GetProp_ImageRuntimeVersion;
		property IsCollectible: Boolean read _GetProp_IsCollectible;
		property IsDynamic: Boolean read _GetProp_IsDynamic;
		property IsFullyTrusted: Boolean read _GetProp_IsFullyTrusted;
		property Location: String read _GetProp_Location;
		property ManifestModule: IModule read _GetProp_ManifestModule;
		property Modules: IIEnumerable<IModule> read _GetProp_Modules;
		property ReflectionOnly: Boolean read _GetProp_ReflectionOnly;
		property SecurityRuleSet: TSecurityRuleSet read _GetProp_SecurityRuleSet;
		property ModuleResolve: TModuleResolveEventHandler read _GetEvt_ModuleResolve write _SetEvt_ModuleResolve;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYALGORITHMIDATTRIBUTE)]
	IAssemblyAlgorithmIdAttribute = interface(IAttribute)
	['{64482535-1212-44E4-ACF1-959C5E0E1307}']
	{ private }
		function _GetProp_AlgorithmId: longword;
	{ public }
		property AlgorithmId: longword read _GetProp_AlgorithmId;
	end;

	IAssemblyBuilderClass = interface(ICoreClrClass)
	['{AD497722-9F9A-435C-B743-9907AD7592F0}']
	{ public }
		{ class } function DefineDynamicAssembly(name: IAssemblyName; access: TAssemblyBuilderAccess_Set): IAssemblyBuilder; overload;
		{ class } function DefineDynamicAssembly(name: IAssemblyName; access: TAssemblyBuilderAccess_Set; assemblyAttributes: IIEnumerable<ICustomAttributeBuilder>): IAssemblyBuilder; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_ASSEMBLYBUILDER)]
	IAssemblyBuilder = interface(IAssembly)
	['{33AC7097-A028-4E2A-B36E-D3E2B35A87D0}']
	{ private }
		function _GetProp_CodeBase: String;
		function _GetProp_EntryPoint: IMethodInfo;
		function _GetProp_FullName: String;
		function _GetProp_GlobalAssemblyCache: Boolean;
		function _GetProp_HostContext: Int64;
		function _GetProp_ImageRuntimeVersion: String;
		function _GetProp_IsCollectible: Boolean;
		function _GetProp_IsDynamic: Boolean;
		function _GetProp_Location: String;
		function _GetProp_ManifestModule: IModule;
		function _GetProp_ReflectionOnly: Boolean;
	{ public }
		function DefineDynamicModule(name: String): IModuleBuilder; overload;
		function DefineDynamicModule(name: String; emitSymbolInfo: Boolean): IModuleBuilder; overload;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function GetDynamicModule(name: String): IModuleBuilder;
		function GetExportedTypes(): TArray<IType>;
		function GetFile(name: String): IFileStream;
		function GetFiles(getResourceModules: Boolean): TArray<IFileStream>;
		function GetLoadedModules(getResourceModules: Boolean): TArray<IModule>;
		function GetManifestResourceInfo(resourceName: String): IManifestResourceInfo;
		function GetManifestResourceNames(): TArray<String>;
		function GetManifestResourceStream(type_: IType; name: String): IStream; overload;
		function GetManifestResourceStream(name: String): IStream; overload;
		function GetModule(name: String): IModule;
		function GetModules(getResourceModules: Boolean): TArray<IModule>;
		function GetName(copiedName: Boolean): IAssemblyName;
		function GetReferencedAssemblies(): TArray<IAssemblyName>;
		function GetSatelliteAssembly(culture: ICultureInfo): IAssembly; overload;
		function GetSatelliteAssembly(culture: ICultureInfo; version: IVersion): IAssembly; overload;
		function GetType(name: String; throwOnError: Boolean; ignoreCase: Boolean): IType;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		property CodeBase: String read _GetProp_CodeBase;
		property EntryPoint: IMethodInfo read _GetProp_EntryPoint;
		property FullName: String read _GetProp_FullName;
		property GlobalAssemblyCache: Boolean read _GetProp_GlobalAssemblyCache;
		property HostContext: Int64 read _GetProp_HostContext;
		property ImageRuntimeVersion: String read _GetProp_ImageRuntimeVersion;
		property IsCollectible: Boolean read _GetProp_IsCollectible;
		property IsDynamic: Boolean read _GetProp_IsDynamic;
		property Location: String read _GetProp_Location;
		property ManifestModule: IModule read _GetProp_ManifestModule;
		property ReflectionOnly: Boolean read _GetProp_ReflectionOnly;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYCOMPANYATTRIBUTE)]
	IAssemblyCompanyAttribute = interface(IAttribute)
	['{6E10A836-1FB3-4B20-B5F3-27346FA06A5C}']
	{ private }
		function _GetProp_Company: String;
	{ public }
		property Company: String read _GetProp_Company;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYCONFIGURATIONATTRIBUTE)]
	IAssemblyConfigurationAttribute = interface(IAttribute)
	['{15BE7599-977A-43D5-BC2D-B9B2A3C66592}']
	{ private }
		function _GetProp_Configuration: String;
	{ public }
		property Configuration: String read _GetProp_Configuration;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYCOPYRIGHTATTRIBUTE)]
	IAssemblyCopyrightAttribute = interface(IAttribute)
	['{47C8097E-359F-40C4-8C42-B5B6177FD3EE}']
	{ private }
		function _GetProp_Copyright: String;
	{ public }
		property Copyright: String read _GetProp_Copyright;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYCULTUREATTRIBUTE)]
	IAssemblyCultureAttribute = interface(IAttribute)
	['{E85CABA6-6521-4BE0-91A1-7386FFD467C2}']
	{ private }
		function _GetProp_Culture: String;
	{ public }
		property Culture: String read _GetProp_Culture;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYDEFAULTALIASATTRIBUTE)]
	IAssemblyDefaultAliasAttribute = interface(IAttribute)
	['{244CEAE1-3BE1-4E6C-BF45-1BE382C3B7A6}']
	{ private }
		function _GetProp_DefaultAlias: String;
	{ public }
		property DefaultAlias: String read _GetProp_DefaultAlias;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYDELAYSIGNATTRIBUTE)]
	IAssemblyDelaySignAttribute = interface(IAttribute)
	['{AF604014-CDA5-4800-B5A0-79F55342D63A}']
	{ private }
		function _GetProp_DelaySign: Boolean;
	{ public }
		property DelaySign: Boolean read _GetProp_DelaySign;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_LOADER_ASSEMBLYDEPENDENCYRESOLVER)]
	IAssemblyDependencyResolver = interface(IObject)
	['{89B6D582-2009-4852-91B9-9662AE8740B2}']
	{ public }
		function ResolveAssemblyToPath(assemblyName: IAssemblyName): String;
		function ResolveUnmanagedDllToPath(unmanagedDllName: String): String;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYDESCRIPTIONATTRIBUTE)]
	IAssemblyDescriptionAttribute = interface(IAttribute)
	['{E9E87E71-9482-4B70-9A80-C1CA20EE780E}']
	{ private }
		function _GetProp_Description: String;
	{ public }
		property Description: String read _GetProp_Description;
	end;

	IAssemblyExtensionsClass = interface(ICoreClrClass)
	['{EDB9029D-1056-4E22-AA54-7D3931E7246C}']
	{ public }
		{ class } function TryGetRawMetadata(assembly: IAssembly; var blob: ICoreClrInstance; var length: Integer): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_METADATA_ASSEMBLYEXTENSIONS)]
	IAssemblyExtensions = interface(IObject)
	['{E1207957-E49A-468E-AAAF-A39939A6DD41}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYFILEVERSIONATTRIBUTE)]
	IAssemblyFileVersionAttribute = interface(IAttribute)
	['{64989EF3-50D2-4E7D-B981-2D9FDB7C36A1}']
	{ private }
		function _GetProp_Version: String;
	{ public }
		property Version: String read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYFLAGSATTRIBUTE)]
	IAssemblyFlagsAttribute = interface(IAttribute)
	['{27D8C983-4E8D-46CF-8EA9-2CBAE3D9A208}']
	{ private }
		function _GetProp_AssemblyFlags: Integer;
		function _GetProp_Flags: longword;
	{ public }
		property AssemblyFlags: Integer read _GetProp_AssemblyFlags;
		property Flags: longword read _GetProp_Flags;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYINFORMATIONALVERSIONATTRIBUTE)]
	IAssemblyInformationalVersionAttribute = interface(IAttribute)
	['{DD6BAA98-2CE5-4F53-8367-60F84FA6F7CC}']
	{ private }
		function _GetProp_InformationalVersion: String;
	{ public }
		property InformationalVersion: String read _GetProp_InformationalVersion;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYKEYFILEATTRIBUTE)]
	IAssemblyKeyFileAttribute = interface(IAttribute)
	['{976DD672-26CB-47EC-B522-9009D2980140}']
	{ private }
		function _GetProp_KeyFile: String;
	{ public }
		property KeyFile: String read _GetProp_KeyFile;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYKEYNAMEATTRIBUTE)]
	IAssemblyKeyNameAttribute = interface(IAttribute)
	['{AA7ACF7E-CF07-4DF0-BA83-11CF8AF89F06}']
	{ private }
		function _GetProp_KeyName: String;
	{ public }
		property KeyName: String read _GetProp_KeyName;
	end;

	IAssemblyLoadContextClass = interface(ICoreClrClass)
	['{50A974F9-9FBA-4904-BF11-76DD364E9669}']
	{ private }
		{ class } function _GetProp_All: IIEnumerable<IAssemblyLoadContext>;
		{ class } function _GetProp_CurrentContextualReflectionContext: IAssemblyLoadContext;
		{ class } function _GetProp_Default: IAssemblyLoadContext;
	{ public }
		{ class } function EnterContextualReflection(activating: IAssembly): IContextualReflectionScope;
		{ class } function GetAssemblyName(assemblyPath: String): IAssemblyName;
		{ class } function GetLoadContext(assembly: IAssembly): IAssemblyLoadContext;
		{ class } property All: IIEnumerable<IAssemblyLoadContext> read _GetProp_All;
		{ class } property CurrentContextualReflectionContext: IAssemblyLoadContext read _GetProp_CurrentContextualReflectionContext;
		{ class } property &Default: IAssemblyLoadContext read _GetProp_Default;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_LOADER_ASSEMBLYLOADCONTEXT)]
	IAssemblyLoadContext = interface(IObject)
	['{8D68FA27-D2F3-468A-9458-14D022A82C91}']
	{ private }
		function _GetProp_Assemblies: IIEnumerable<IAssembly>;
		function _GetProp_IsCollectible: Boolean;
		function _GetProp_Name: String;
		function _GetEvt_Resolving: TClrFunc<IAssemblyLoadContext, IAssemblyName, IAssembly>;
		procedure _SetEvt_Resolving(Value: TClrFunc<IAssemblyLoadContext, IAssemblyName, IAssembly>);
		function _GetEvt_ResolvingUnmanagedDll: TClrFunc<IAssembly, String, IIntPtr>;
		procedure _SetEvt_ResolvingUnmanagedDll(Value: TClrFunc<IAssembly, String, IIntPtr>);
		function _GetEvt_Unloading: TClrAction<IAssemblyLoadContext>;
		procedure _SetEvt_Unloading(Value: TClrAction<IAssemblyLoadContext>);
	{ public }
		function EnterContextualReflection(): IContextualReflectionScope;
		function LoadFromAssemblyName(assemblyName: IAssemblyName): IAssembly;
		function LoadFromAssemblyPath(assemblyPath: String): IAssembly;
		function LoadFromNativeImagePath(nativeImagePath: String; assemblyPath: String): IAssembly;
		function LoadFromStream(assembly: IStream): IAssembly; overload;
		function LoadFromStream(assembly: IStream; assemblySymbols: IStream): IAssembly; overload;
		procedure SetProfileOptimizationRoot(directoryPath: String);
		procedure StartProfileOptimization(profile: String);
		procedure Unload();
		property Assemblies: IIEnumerable<IAssembly> read _GetProp_Assemblies;
		property IsCollectible: Boolean read _GetProp_IsCollectible;
		property Name: String read _GetProp_Name;
		property Resolving: TClrFunc<IAssemblyLoadContext, IAssemblyName, IAssembly> read _GetEvt_Resolving write _SetEvt_Resolving;
		property ResolvingUnmanagedDll: TClrFunc<IAssembly, String, IIntPtr> read _GetEvt_ResolvingUnmanagedDll write _SetEvt_ResolvingUnmanagedDll;
		property Unloading: TClrAction<IAssemblyLoadContext> read _GetEvt_Unloading write _SetEvt_Unloading;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_LOADER_CONTEXTUALREFLECTIONSCOPE)]
	IContextualReflectionScope = interface(IValueType)
	['{201B6BB1-8CB8-4ED6-A053-A6472E4FE262}']
	{ public }
		procedure Dispose();
	end;

	IEventArgsClass = interface(ICoreClrClass)
	['{39309D92-A4C4-42E8-B788-19E1FAF1D537}']
	{ private }
		{ class } function _GetFld_Empty: IEventArgs;
	{ public }
		{ class } property Empty: IEventArgs read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_EVENTARGS)]
	IEventArgs = interface(IObject)
	['{0B0A338A-A9B8-4F72-9EE2-6396E7225B07}']
	end;

	[CoreTypeSignature(SYSTEM_ASSEMBLYLOADEVENTARGS)]
	IAssemblyLoadEventArgs = interface(IEventArgs)
	['{6109F136-B29C-48BC-AEA6-342AE8ACD195}']
	{ private }
		function _GetProp_LoadedAssembly: IAssembly;
	{ public }
		property LoadedAssembly: IAssembly read _GetProp_LoadedAssembly;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYMETADATAATTRIBUTE)]
	IAssemblyMetadataAttribute = interface(IAttribute)
	['{226DA8FA-7B4B-46EA-BEB2-0BEF94D2FD2B}']
	{ private }
		function _GetProp_Key: String;
		function _GetProp_Value: String;
	{ public }
		property Key: String read _GetProp_Key;
		property Value: String read _GetProp_Value;
	end;

	IAssemblyNameClass = interface(ICoreClrClass)
	['{00FA391A-F640-4E9F-BD65-1DD33957FCA0}']
	{ public }
		{ class } function GetAssemblyName(assemblyFile: String): IAssemblyName;
		{ class } function ReferenceMatchesDefinition(reference: IAssemblyName; definition: IAssemblyName): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYNAME)]
	IAssemblyName = interface(IObject)
	['{02878A92-5E51-436B-AB8A-D3A424E71988}']
	{ private }
		function _GetProp_CodeBase: String;
		procedure _SetProp_CodeBase(Value: String);
		function _GetProp_ContentType: TAssemblyContentType;
		procedure _SetProp_ContentType(Value: TAssemblyContentType);
		function _GetProp_CultureInfo: ICultureInfo;
		procedure _SetProp_CultureInfo(Value: ICultureInfo);
		function _GetProp_CultureName: String;
		procedure _SetProp_CultureName(Value: String);
		function _GetProp_EscapedCodeBase: String;
		function _GetProp_Flags: TAssemblyNameFlags_Set;
		procedure _SetProp_Flags(Value: TAssemblyNameFlags_Set);
		function _GetProp_FullName: String;
		function _GetProp_HashAlgorithm: TAssemblyHashAlgorithm;
		procedure _SetProp_HashAlgorithm(Value: TAssemblyHashAlgorithm);
		function _GetProp_KeyPair: IStrongNameKeyPair;
		procedure _SetProp_KeyPair(Value: IStrongNameKeyPair);
		function _GetProp_Name: String;
		procedure _SetProp_Name(Value: String);
		function _GetProp_ProcessorArchitecture: TProcessorArchitecture;
		procedure _SetProp_ProcessorArchitecture(Value: TProcessorArchitecture);
		function _GetProp_Version: IVersion;
		procedure _SetProp_Version(Value: IVersion);
		function _GetProp_VersionCompatibility: TAssemblyVersionCompatibility;
		procedure _SetProp_VersionCompatibility(Value: TAssemblyVersionCompatibility);
	{ public }
		function Clone(): Variant;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		function GetPublicKey(): TArray<Byte>;
		function GetPublicKeyToken(): TArray<Byte>;
		procedure OnDeserialization(sender: Variant);
		procedure SetPublicKey(publicKey: TArray<Byte>);
		procedure SetPublicKeyToken(publicKeyToken: TArray<Byte>);
		property CodeBase: String read _GetProp_CodeBase write _SetProp_CodeBase;
		property ContentType: TAssemblyContentType read _GetProp_ContentType write _SetProp_ContentType;
		property CultureInfo: ICultureInfo read _GetProp_CultureInfo write _SetProp_CultureInfo;
		property CultureName: String read _GetProp_CultureName write _SetProp_CultureName;
		property EscapedCodeBase: String read _GetProp_EscapedCodeBase;
		property Flags: TAssemblyNameFlags_Set read _GetProp_Flags write _SetProp_Flags;
		property FullName: String read _GetProp_FullName;
		property HashAlgorithm: TAssemblyHashAlgorithm read _GetProp_HashAlgorithm write _SetProp_HashAlgorithm;
		property KeyPair: IStrongNameKeyPair read _GetProp_KeyPair write _SetProp_KeyPair;
		property Name: String read _GetProp_Name write _SetProp_Name;
		property ProcessorArchitecture: TProcessorArchitecture read _GetProp_ProcessorArchitecture write _SetProp_ProcessorArchitecture;
		property Version: IVersion read _GetProp_Version write _SetProp_Version;
		property VersionCompatibility: TAssemblyVersionCompatibility read _GetProp_VersionCompatibility write _SetProp_VersionCompatibility;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYNAMEPROXY)]
	IAssemblyNameProxy = interface(IMarshalByRefObject)
	['{257F334F-61C8-479B-8E83-A47841B3901D}']
	{ public }
		function GetAssemblyName(assemblyFile: String): IAssemblyName;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYPRODUCTATTRIBUTE)]
	IAssemblyProductAttribute = interface(IAttribute)
	['{5BFCC95C-2927-4A3F-8DB6-CD097BCB9CB1}']
	{ private }
		function _GetProp_Product: String;
	{ public }
		property Product: String read _GetProp_Product;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYSIGNATUREKEYATTRIBUTE)]
	IAssemblySignatureKeyAttribute = interface(IAttribute)
	['{19CB17E2-83E8-45B6-8971-48AEF3B894A8}']
	{ private }
		function _GetProp_Countersignature: String;
		function _GetProp_PublicKey: String;
	{ public }
		property Countersignature: String read _GetProp_Countersignature;
		property PublicKey: String read _GetProp_PublicKey;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_ASSEMBLYTARGETEDPATCHBANDATTRIBUTE)]
	IAssemblyTargetedPatchBandAttribute = interface(IAttribute)
	['{1D32F4C2-4DA4-4F7D-9F31-0C4788099470}']
	{ private }
		function _GetProp_TargetedPatchBand: String;
	{ public }
		property TargetedPatchBand: String read _GetProp_TargetedPatchBand;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYTITLEATTRIBUTE)]
	IAssemblyTitleAttribute = interface(IAttribute)
	['{DAD4679A-D2B7-4FBA-811B-14331C337205}']
	{ private }
		function _GetProp_Title: String;
	{ public }
		property Title: String read _GetProp_Title;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYTRADEMARKATTRIBUTE)]
	IAssemblyTrademarkAttribute = interface(IAttribute)
	['{15A0BA51-6AA7-451A-865D-1D12E76D4B3E}']
	{ private }
		function _GetProp_Trademark: String;
	{ public }
		property Trademark: String read _GetProp_Trademark;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ASSEMBLYVERSIONATTRIBUTE)]
	IAssemblyVersionAttribute = interface(IAttribute)
	['{DD4FE8E6-9229-4284-8481-B0314ED81D98}']
	{ private }
		function _GetProp_Version: String;
	{ public }
		property Version: String read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_ASYNCFLOWCONTROL)]
	IAsyncFlowControl = interface(IValueType)
	['{1803CF90-E3D6-492B-8843-E9E397703B40}']
	{ public }
		procedure Dispose();
		function Equals(obj: IAsyncFlowControl): Boolean;
		procedure Undo();
	end;

	IAsyncIteratorMethodBuilderClass = interface(ICoreClrClass)
	['{38F6293C-F7F8-4E0E-9C9B-0FD4364D378A}']
	{ public }
		{ class } function Create(): IAsyncIteratorMethodBuilder;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCITERATORMETHODBUILDER)]
	IAsyncIteratorMethodBuilder = interface(IValueType)
	['{337EC4BB-3C1B-4350-9A2F-33DD9E784D62}']
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure Complete();
		procedure MoveNext(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_STATEMACHINEATTRIBUTE)]
	IStateMachineAttribute = interface(IAttribute)
	['{AD472667-8B1D-4EA3-9848-0901CF33E608}']
	{ private }
		function _GetProp_StateMachineType: IType;
	{ public }
		property StateMachineType: IType read _GetProp_StateMachineType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCITERATORSTATEMACHINEATTRIBUTE)]
	IAsyncIteratorStateMachineAttribute = interface(IStateMachineAttribute)
	['{9D33DE28-228D-4B0E-8D47-23AEC45A1853}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_ASYNCLOCAL_1)]
	IAsyncLocal<T> = interface(IIAsyncLocal)
	['{DE853AC0-BD56-4722-B84F-AF01BF4224AB}']
	{ private }
		function _GetProp_Value: T;
		procedure _SetProp_Value(Value: T);
	{ public }
		property Value: T read _GetProp_Value write _SetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_ASYNCLOCALVALUECHANGEDARGS_1)]
	IAsyncLocalValueChangedArgs<T> = interface(IValueType)
	['{DD67AF97-93B2-4FC3-93B6-1756FF3D526D}']
	{ private }
		function _GetProp_CurrentValue: T;
		function _GetProp_PreviousValue: T;
		function _GetProp_ThreadContextChanged: Boolean;
	{ public }
		property CurrentValue: T read _GetProp_CurrentValue;
		property PreviousValue: T read _GetProp_PreviousValue;
		property ThreadContextChanged: Boolean read _GetProp_ThreadContextChanged;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCMETHODBUILDERATTRIBUTE)]
	IAsyncMethodBuilderAttribute = interface(IAttribute)
	['{9C41CC8B-7FC7-4D9A-9B4B-043AE64FE26F}']
	{ private }
		function _GetProp_BuilderType: IType;
	{ public }
		property BuilderType: IType read _GetProp_BuilderType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCSTATEMACHINEATTRIBUTE)]
	IAsyncStateMachineAttribute = interface(IStateMachineAttribute)
	['{75888055-CE39-48D3-A4D2-E14EB0394B0D}']
	end;

	IAsyncTaskMethodBuilderClass = interface(ICoreClrClass)
	['{EFD6B127-5440-4B50-BC95-74A81609576D}']
	{ public }
		{ class } function Create(): IAsyncTaskMethodBuilder;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCTASKMETHODBUILDER)]
	IAsyncTaskMethodBuilder = interface(IValueType)
	['{4AD11408-AF35-4992-A447-8D98E6F655B1}']
	{ private }
		function _GetProp_Task: ITask;
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure SetException(exception: IException);
		procedure SetResult();
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
		procedure Start(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
		property Task: ITask read _GetProp_Task;
	end;

	IAsyncTaskMethodBuilderClass<TResult> = interface(ICoreClrClass)
	['{FC838F6C-D119-454B-A20B-0DFA3A6E8593}']
	{ public }
		{ class } function Create(): IAsyncTaskMethodBuilder<TResult>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCTASKMETHODBUILDER_1)]
	IAsyncTaskMethodBuilder<TResult> = interface(IValueType)
	['{4CBC31F0-2F29-48C0-87EF-EA8ECD81C0A4}']
	{ private }
		function _GetProp_Task: ITask<TResult>;
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure SetException(exception: IException);
		procedure SetResult(result_: TResult);
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
		procedure Start(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
		property Task: ITask<TResult> read _GetProp_Task;
	end;

	IAsyncValueTaskMethodBuilderClass = interface(ICoreClrClass)
	['{F992FE0E-BAA7-491A-834C-1C5320411EBE}']
	{ public }
		{ class } function Create(): IAsyncValueTaskMethodBuilder;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCVALUETASKMETHODBUILDER)]
	IAsyncValueTaskMethodBuilder = interface(IValueType)
	['{47CEE7DE-ED5E-4A3F-AD12-5A2663BF2DC7}']
	{ private }
		function _GetProp_Task: IValueTask;
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure SetException(exception: IException);
		procedure SetResult();
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
		procedure Start(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
		property Task: IValueTask read _GetProp_Task;
	end;

	IAsyncValueTaskMethodBuilderClass<TResult> = interface(ICoreClrClass)
	['{DD9DFB09-240D-4889-A591-EC0BB2D725B3}']
	{ public }
		{ class } function Create(): IAsyncValueTaskMethodBuilder<TResult>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCVALUETASKMETHODBUILDER_1)]
	IAsyncValueTaskMethodBuilder<TResult> = interface(IValueType)
	['{6C19F2A0-27B1-4D5F-ACDB-31A05326ADCB}']
	{ private }
		function _GetProp_Task: IValueTask<TResult>;
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure SetException(exception: IException);
		procedure SetResult(result_: TResult);
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
		procedure Start(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
		property Task: IValueTask<TResult> read _GetProp_Task;
	end;

	IAsyncVoidMethodBuilderClass = interface(ICoreClrClass)
	['{E8A5743F-9A24-448C-8E7C-018C6BFBDB57}']
	{ public }
		{ class } function Create(): IAsyncVoidMethodBuilder;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCVOIDMETHODBUILDER)]
	IAsyncVoidMethodBuilder = interface(IValueType)
	['{0083A2A2-1F38-4B46-B70C-85486AABEE7C}']
	{ public }
		procedure AwaitOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure AwaitUnsafeOnCompleted(TAwaiter: PTypeInfo; TStateMachine: PTypeInfo; var awaiter: Variant{TAwaiter}; var stateMachine: Variant{TStateMachine});
		procedure SetException(exception: IException);
		procedure SetResult();
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
		procedure Start(TStateMachine: PTypeInfo; var stateMachine: Variant{TStateMachine});
	end;

	[CoreTypeSignature(SYSTEM_ATTRIBUTEUSAGEATTRIBUTE)]
	IAttributeUsageAttribute = interface(IAttribute)
	['{DAF59F5C-753E-4901-8B98-0D1EF1D99C1E}']
	{ private }
		function _GetProp_AllowMultiple: Boolean;
		procedure _SetProp_AllowMultiple(Value: Boolean);
		function _GetProp_Inherited: Boolean;
		procedure _SetProp_Inherited(Value: Boolean);
		function _GetProp_ValidOn: TAttributeTargets_Set;
	{ public }
		property AllowMultiple: Boolean read _GetProp_AllowMultiple write _SetProp_AllowMultiple;
		property &Inherited: Boolean read _GetProp_Inherited write _SetProp_Inherited;
		property ValidOn: TAttributeTargets_Set read _GetProp_ValidOn;
	end;

	IWaitHandleClass = interface(ICoreClrClass)
	['{FDB43B86-5BF8-41D8-8372-F39C470F0DF5}']
	{ private }
		{ class } function _GetFld_WaitTimeout: Integer;
	{ public }
		{ class } function SignalAndWait(toSignal: IWaitHandle; toWaitOn: IWaitHandle): Boolean; overload;
		{ class } function SignalAndWait(toSignal: IWaitHandle; toWaitOn: IWaitHandle; timeout: ITimeSpan; exitContext: Boolean): Boolean; overload;
		{ class } function SignalAndWait(toSignal: IWaitHandle; toWaitOn: IWaitHandle; millisecondsTimeout: Integer; exitContext: Boolean): Boolean; overload;
		{ class } function WaitAll(waitHandles: ICoreClrBridgeArray<IWaitHandle>; millisecondsTimeout: Integer): Boolean; overload;
		{ class } function WaitAll(waitHandles: ICoreClrBridgeArray<IWaitHandle>; timeout: ITimeSpan): Boolean; overload;
		{ class } function WaitAll(waitHandles: ICoreClrBridgeArray<IWaitHandle>): Boolean; overload;
		{ class } function WaitAll(waitHandles: ICoreClrBridgeArray<IWaitHandle>; millisecondsTimeout: Integer; exitContext: Boolean): Boolean; overload;
		{ class } function WaitAll(waitHandles: ICoreClrBridgeArray<IWaitHandle>; timeout: ITimeSpan; exitContext: Boolean): Boolean; overload;
		{ class } function WaitAny(waitHandles: ICoreClrBridgeArray<IWaitHandle>; millisecondsTimeout: Integer): Integer; overload;
		{ class } function WaitAny(waitHandles: ICoreClrBridgeArray<IWaitHandle>; timeout: ITimeSpan): Integer; overload;
		{ class } function WaitAny(waitHandles: ICoreClrBridgeArray<IWaitHandle>): Integer; overload;
		{ class } function WaitAny(waitHandles: ICoreClrBridgeArray<IWaitHandle>; millisecondsTimeout: Integer; exitContext: Boolean): Integer; overload;
		{ class } function WaitAny(waitHandles: ICoreClrBridgeArray<IWaitHandle>; timeout: ITimeSpan; exitContext: Boolean): Integer; overload;
		{ class } property WaitTimeout: Integer read _GetFld_WaitTimeout;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_WAITHANDLE)]
	IWaitHandle = interface(IMarshalByRefObject)
	['{8E785BD8-701E-42CA-A7B4-C0C3668CCD1D}']
	{ private }
		function _GetProp_Handle: IIntPtr;
		procedure _SetProp_Handle(Value: IIntPtr);
		function _GetProp_SafeWaitHandle: ISafeWaitHandle;
		procedure _SetProp_SafeWaitHandle(Value: ISafeWaitHandle);
	{ public }
		procedure Close();
		procedure Dispose();
		function WaitOne(millisecondsTimeout: Integer): Boolean; overload;
		function WaitOne(timeout: ITimeSpan): Boolean; overload;
		function WaitOne(): Boolean; overload;
		function WaitOne(millisecondsTimeout: Integer; exitContext: Boolean): Boolean; overload;
		function WaitOne(timeout: ITimeSpan; exitContext: Boolean): Boolean; overload;
		property Handle: IIntPtr read _GetProp_Handle write _SetProp_Handle;
		property SafeWaitHandle: ISafeWaitHandle read _GetProp_SafeWaitHandle write _SetProp_SafeWaitHandle;
	end;

	IEventWaitHandleClass = interface(ICoreClrClass)
	['{7C312A6A-9225-4612-9D6A-A1AA30E0B3C2}']
	{ public }
		{ class } function OpenExisting(name: String): IEventWaitHandle;
		{ class } function TryOpenExisting(name: String; var result_: IEventWaitHandle): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_EVENTWAITHANDLE)]
	IEventWaitHandle = interface(IWaitHandle)
	['{7E53EBEC-6C9B-409C-BBB0-E88CF075E328}']
	{ public }
		function Reset(): Boolean;
		function &Set(): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_AUTORESETEVENT)]
	IAutoResetEvent = interface(IEventWaitHandle)
	['{70716239-BF03-4CA4-B3DC-CC1B34E8A6E0}']
	end;

	ISse3Class = interface(ICoreClrClass)
	['{6EC5EC6D-F8C2-4E95-97DA-3AE0DB74E5CB}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function AddSubtract(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function AddSubtract(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function HorizontalAdd(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function HorizontalAdd(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function HorizontalSubtract(left: IVector128<Single>; right: IVector128<Single>): IVector128<Single>; overload;
		{ class } function HorizontalSubtract(left: IVector128<Double>; right: IVector128<Double>): IVector128<Double>; overload;
		{ class } function LoadAndDuplicateToVector128(address: ICoreClrInstance): IVector128<Double>;
		{ class } function LoadDquVector128(address: ICoreClrInstance): IVector128<Shortint>;
		{ class } function MoveAndDuplicate(source: IVector128<Double>): IVector128<Double>;
		{ class } function MoveHighAndDuplicate(source: IVector128<Single>): IVector128<Single>;
		{ class } function MoveLowAndDuplicate(source: IVector128<Single>): IVector128<Single>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSE3)]
	ISse3 = interface(ISse2)
	['{6D56408E-3F5A-454C-B210-948A28E04DE0}']
	end;

	ISsse3Class = interface(ICoreClrClass)
	['{D2D8F10F-691D-4E41-BDC0-229FAB177A37}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Abs(value: IVector128<Shortint>): IVector128<Byte>; overload;
		{ class } function Abs(value: IVector128<SmallInt>): IVector128<Word>; overload;
		{ class } function Abs(value: IVector128<Integer>): IVector128<longword>; overload;
		{ class } function AlignRight(left: IVector128<Shortint>; right: IVector128<Shortint>; mask: Byte): IVector128<Shortint>; overload;
		{ class } function AlignRight(left: IVector128<Byte>; right: IVector128<Byte>; mask: Byte): IVector128<Byte>; overload;
		{ class } function AlignRight(left: IVector128<SmallInt>; right: IVector128<SmallInt>; mask: Byte): IVector128<SmallInt>; overload;
		{ class } function AlignRight(left: IVector128<Word>; right: IVector128<Word>; mask: Byte): IVector128<Word>; overload;
		{ class } function AlignRight(left: IVector128<Integer>; right: IVector128<Integer>; mask: Byte): IVector128<Integer>; overload;
		{ class } function AlignRight(left: IVector128<longword>; right: IVector128<longword>; mask: Byte): IVector128<longword>; overload;
		{ class } function AlignRight(left: IVector128<Int64>; right: IVector128<Int64>; mask: Byte): IVector128<Int64>; overload;
		{ class } function AlignRight(left: IVector128<UInt64>; right: IVector128<UInt64>; mask: Byte): IVector128<UInt64>; overload;
		{ class } function HorizontalAdd(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function HorizontalAdd(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function HorizontalAddSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>;
		{ class } function HorizontalSubtract(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function HorizontalSubtract(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function HorizontalSubtractSaturate(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>;
		{ class } function MultiplyAddAdjacent(left: IVector128<Byte>; right: IVector128<Shortint>): IVector128<SmallInt>;
		{ class } function MultiplyHighRoundScale(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>;
		{ class } function Shuffle(value: IVector128<Shortint>; mask: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Shuffle(value: IVector128<Byte>; mask: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function Sign(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Sign(left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Sign(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSSE3)]
	ISsse3 = interface(ISse3)
	['{39487E19-B63B-4040-9735-7089D3034E86}']
	end;

	ISse41Class = interface(ICoreClrClass)
	['{02D7E323-BB4B-4396-9854-98A07E5D1A2F}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Blend(left: IVector128<SmallInt>; right: IVector128<SmallInt>; control: Byte): IVector128<SmallInt>; overload;
		{ class } function Blend(left: IVector128<Word>; right: IVector128<Word>; control: Byte): IVector128<Word>; overload;
		{ class } function Blend(left: IVector128<Single>; right: IVector128<Single>; control: Byte): IVector128<Single>; overload;
		{ class } function Blend(left: IVector128<Double>; right: IVector128<Double>; control: Byte): IVector128<Double>; overload;
		{ class } function BlendVariable(left: IVector128<Shortint>; right: IVector128<Shortint>; mask: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function BlendVariable(left: IVector128<Byte>; right: IVector128<Byte>; mask: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function BlendVariable(left: IVector128<SmallInt>; right: IVector128<SmallInt>; mask: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function BlendVariable(left: IVector128<Word>; right: IVector128<Word>; mask: IVector128<Word>): IVector128<Word>; overload;
		{ class } function BlendVariable(left: IVector128<Integer>; right: IVector128<Integer>; mask: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function BlendVariable(left: IVector128<longword>; right: IVector128<longword>; mask: IVector128<longword>): IVector128<longword>; overload;
		{ class } function BlendVariable(left: IVector128<Int64>; right: IVector128<Int64>; mask: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function BlendVariable(left: IVector128<UInt64>; right: IVector128<UInt64>; mask: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function BlendVariable(left: IVector128<Single>; right: IVector128<Single>; mask: IVector128<Single>): IVector128<Single>; overload;
		{ class } function BlendVariable(left: IVector128<Double>; right: IVector128<Double>; mask: IVector128<Double>): IVector128<Double>; overload;
		{ class } function Ceiling(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Ceiling(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CeilingScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CeilingScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CeilingScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function CeilingScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function CompareEqual(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function CompareEqual(left: IVector128<UInt64>; right: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ConvertToVector128Int16(value: IVector128<Shortint>): IVector128<SmallInt>; overload;
		{ class } function ConvertToVector128Int16(value: IVector128<Byte>): IVector128<SmallInt>; overload;
		{ class } function ConvertToVector128Int16(address: ICoreClrInstance): IVector128<SmallInt>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<Shortint>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<Byte>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<SmallInt>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32(value: IVector128<Word>): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int32(address: ICoreClrInstance): IVector128<Integer>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<Shortint>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<Byte>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<SmallInt>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<Word>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<Integer>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(value: IVector128<longword>): IVector128<Int64>; overload;
		{ class } function ConvertToVector128Int64(address: ICoreClrInstance): IVector128<Int64>; overload;
		{ class } function DotProduct(left: IVector128<Single>; right: IVector128<Single>; control: Byte): IVector128<Single>; overload;
		{ class } function DotProduct(left: IVector128<Double>; right: IVector128<Double>; control: Byte): IVector128<Double>; overload;
		{ class } function Extract(value: IVector128<Byte>; index: Byte): Byte; overload;
		{ class } function Extract(value: IVector128<Integer>; index: Byte): Integer; overload;
		{ class } function Extract(value: IVector128<longword>; index: Byte): longword; overload;
		{ class } function Extract(value: IVector128<Single>; index: Byte): Single; overload;
		{ class } function Floor(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Floor(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function FloorScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function FloorScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function FloorScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function FloorScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function Insert(value: IVector128<Shortint>; data: Shortint; index: Byte): IVector128<Shortint>; overload;
		{ class } function Insert(value: IVector128<Byte>; data: Byte; index: Byte): IVector128<Byte>; overload;
		{ class } function Insert(value: IVector128<Integer>; data: Integer; index: Byte): IVector128<Integer>; overload;
		{ class } function Insert(value: IVector128<longword>; data: longword; index: Byte): IVector128<longword>; overload;
		{ class } function Insert(value: IVector128<Single>; data: IVector128<Single>; index: Byte): IVector128<Single>; overload;
		{ class } function LoadAlignedVector128NonTemporal(address: ICoreClrInstance): IVector128<Shortint>;
		{ class } function Max(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Max(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Max(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Max(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function Min(left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function Min(left: IVector128<Word>; right: IVector128<Word>): IVector128<Word>; overload;
		{ class } function Min(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function Min(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MinHorizontal(value: IVector128<Word>): IVector128<Word>;
		{ class } function MultipleSumAbsoluteDifferences(left: IVector128<Byte>; right: IVector128<Byte>; mask: Byte): IVector128<Word>;
		{ class } function Multiply(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Int64>;
		{ class } function MultiplyLow(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyLow(left: IVector128<longword>; right: IVector128<longword>): IVector128<longword>; overload;
		{ class } function PackUnsignedSaturate(left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Word>;
		{ class } function RoundCurrentDirection(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundCurrentDirection(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundCurrentDirectionScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundCurrentDirectionScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundCurrentDirectionScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundCurrentDirectionScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNearestInteger(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNearestInteger(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNearestIntegerScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNearestIntegerScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNearestIntegerScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNearestIntegerScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNegativeInfinityScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNegativeInfinityScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToNegativeInfinityScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToNegativeInfinityScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToPositiveInfinityScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToPositiveInfinityScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToPositiveInfinityScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToPositiveInfinityScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToZero(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToZero(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToZeroScalar(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToZeroScalar(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function RoundToZeroScalar(upper: IVector128<Double>; value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function RoundToZeroScalar(upper: IVector128<Single>; value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function TestC(left: IVector128<Shortint>; right: IVector128<Shortint>): Boolean; overload;
		{ class } function TestC(left: IVector128<Byte>; right: IVector128<Byte>): Boolean; overload;
		{ class } function TestC(left: IVector128<SmallInt>; right: IVector128<SmallInt>): Boolean; overload;
		{ class } function TestC(left: IVector128<Word>; right: IVector128<Word>): Boolean; overload;
		{ class } function TestC(left: IVector128<Integer>; right: IVector128<Integer>): Boolean; overload;
		{ class } function TestC(left: IVector128<longword>; right: IVector128<longword>): Boolean; overload;
		{ class } function TestC(left: IVector128<Int64>; right: IVector128<Int64>): Boolean; overload;
		{ class } function TestC(left: IVector128<UInt64>; right: IVector128<UInt64>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Shortint>; right: IVector128<Shortint>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Byte>; right: IVector128<Byte>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<SmallInt>; right: IVector128<SmallInt>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Word>; right: IVector128<Word>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Integer>; right: IVector128<Integer>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<longword>; right: IVector128<longword>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Int64>; right: IVector128<Int64>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<UInt64>; right: IVector128<UInt64>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Shortint>; right: IVector128<Shortint>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Byte>; right: IVector128<Byte>): Boolean; overload;
		{ class } function TestZ(left: IVector128<SmallInt>; right: IVector128<SmallInt>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Word>; right: IVector128<Word>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Integer>; right: IVector128<Integer>): Boolean; overload;
		{ class } function TestZ(left: IVector128<longword>; right: IVector128<longword>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Int64>; right: IVector128<Int64>): Boolean; overload;
		{ class } function TestZ(left: IVector128<UInt64>; right: IVector128<UInt64>): Boolean; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSE41)]
	ISse41 = interface(ISsse3)
	['{10DDBA84-21C7-425A-899D-A1E440389CB2}']
	end;

	ISse42Class = interface(ICoreClrClass)
	['{8CD48EB4-798A-4DFD-9C66-5CC36A23031D}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function CompareGreaterThan(left: IVector128<Int64>; right: IVector128<Int64>): IVector128<Int64>;
		{ class } function Crc32(crc: longword; data: Byte): longword; overload;
		{ class } function Crc32(crc: longword; data: Word): longword; overload;
		{ class } function Crc32(crc: longword; data: longword): longword; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_SSE42)]
	ISse42 = interface(ISse41)
	['{E4E09CFF-D853-47CB-8C61-E408FCD346AA}']
	end;

	IAvxClass = interface(ICoreClrClass)
	['{7F4BF291-2494-4678-A14B-BE9DC804DF07}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Add(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Add(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function AddSubtract(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function AddSubtract(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function &And(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function &And(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function AndNot(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function AndNot(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function Blend(left: IVector256<Single>; right: IVector256<Single>; control: Byte): IVector256<Single>; overload;
		{ class } function Blend(left: IVector256<Double>; right: IVector256<Double>; control: Byte): IVector256<Double>; overload;
		{ class } function BlendVariable(left: IVector256<Single>; right: IVector256<Single>; mask: IVector256<Single>): IVector256<Single>; overload;
		{ class } function BlendVariable(left: IVector256<Double>; right: IVector256<Double>; mask: IVector256<Double>): IVector256<Double>; overload;
		{ class } function BroadcastScalarToVector128(source: ICoreClrInstance): IVector128<Single>;
		{ class } function BroadcastScalarToVector256(source: ICoreClrInstance): IVector256<Single>;
		{ class } function BroadcastVector128ToVector256(address: ICoreClrInstance): IVector256<Single>;
		{ class } function Ceiling(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Ceiling(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function Compare(left: IVector128<Single>; right: IVector128<Single>; mode: TFloatComparisonMode): IVector128<Single>; overload;
		{ class } function Compare(left: IVector128<Double>; right: IVector128<Double>; mode: TFloatComparisonMode): IVector128<Double>; overload;
		{ class } function Compare(left: IVector256<Single>; right: IVector256<Single>; mode: TFloatComparisonMode): IVector256<Single>; overload;
		{ class } function Compare(left: IVector256<Double>; right: IVector256<Double>; mode: TFloatComparisonMode): IVector256<Double>; overload;
		{ class } function CompareEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareGreaterThan(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareGreaterThan(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareGreaterThanOrEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareLessThan(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareLessThan(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareLessThanOrEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareNotEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareNotEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareNotGreaterThan(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareNotGreaterThan(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareNotGreaterThanOrEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareNotGreaterThanOrEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareNotLessThan(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareNotLessThan(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareNotLessThanOrEqual(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareNotLessThanOrEqual(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareOrdered(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareOrdered(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function CompareScalar(left: IVector128<Double>; right: IVector128<Double>; mode: TFloatComparisonMode): IVector128<Double>; overload;
		{ class } function CompareScalar(left: IVector128<Single>; right: IVector128<Single>; mode: TFloatComparisonMode): IVector128<Single>; overload;
		{ class } function CompareUnordered(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function CompareUnordered(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function ConvertToVector128Int32(value: IVector256<Double>): IVector128<Integer>;
		{ class } function ConvertToVector128Int32WithTruncation(value: IVector256<Double>): IVector128<Integer>;
		{ class } function ConvertToVector128Single(value: IVector256<Double>): IVector128<Single>;
		{ class } function ConvertToVector256Double(value: IVector128<Single>): IVector256<Double>; overload;
		{ class } function ConvertToVector256Double(value: IVector128<Integer>): IVector256<Double>; overload;
		{ class } function ConvertToVector256Int32(value: IVector256<Single>): IVector256<Integer>;
		{ class } function ConvertToVector256Int32WithTruncation(value: IVector256<Single>): IVector256<Integer>;
		{ class } function ConvertToVector256Single(value: IVector256<Integer>): IVector256<Single>;
		{ class } function Divide(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Divide(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function DotProduct(left: IVector256<Single>; right: IVector256<Single>; control: Byte): IVector256<Single>;
		{ class } function DuplicateEvenIndexed(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function DuplicateEvenIndexed(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function DuplicateOddIndexed(value: IVector256<Single>): IVector256<Single>;
		{ class } function ExtractVector128(value: IVector256<Byte>; index: Byte): IVector128<Byte>; overload;
		{ class } function ExtractVector128(value: IVector256<Shortint>; index: Byte): IVector128<Shortint>; overload;
		{ class } function ExtractVector128(value: IVector256<SmallInt>; index: Byte): IVector128<SmallInt>; overload;
		{ class } function ExtractVector128(value: IVector256<Word>; index: Byte): IVector128<Word>; overload;
		{ class } function ExtractVector128(value: IVector256<Integer>; index: Byte): IVector128<Integer>; overload;
		{ class } function ExtractVector128(value: IVector256<longword>; index: Byte): IVector128<longword>; overload;
		{ class } function ExtractVector128(value: IVector256<Int64>; index: Byte): IVector128<Int64>; overload;
		{ class } function ExtractVector128(value: IVector256<UInt64>; index: Byte): IVector128<UInt64>; overload;
		{ class } function ExtractVector128(value: IVector256<Single>; index: Byte): IVector128<Single>; overload;
		{ class } function ExtractVector128(value: IVector256<Double>; index: Byte): IVector128<Double>; overload;
		{ class } function Floor(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Floor(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function HorizontalAdd(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function HorizontalAdd(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function HorizontalSubtract(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function HorizontalSubtract(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function InsertVector128(value: IVector256<longword>; data: IVector128<longword>; index: Byte): IVector256<longword>; overload;
		{ class } function InsertVector128(value: IVector256<Int64>; data: IVector128<Int64>; index: Byte): IVector256<Int64>; overload;
		{ class } function InsertVector128(value: IVector256<UInt64>; data: IVector128<UInt64>; index: Byte): IVector256<UInt64>; overload;
		{ class } function InsertVector128(value: IVector256<Single>; data: IVector128<Single>; index: Byte): IVector256<Single>; overload;
		{ class } function InsertVector128(value: IVector256<Double>; data: IVector128<Double>; index: Byte): IVector256<Double>; overload;
		{ class } function InsertVector128(value: IVector256<Byte>; data: IVector128<Byte>; index: Byte): IVector256<Byte>; overload;
		{ class } function InsertVector128(value: IVector256<Shortint>; data: IVector128<Shortint>; index: Byte): IVector256<Shortint>; overload;
		{ class } function InsertVector128(value: IVector256<SmallInt>; data: IVector128<SmallInt>; index: Byte): IVector256<SmallInt>; overload;
		{ class } function InsertVector128(value: IVector256<Word>; data: IVector128<Word>; index: Byte): IVector256<Word>; overload;
		{ class } function InsertVector128(value: IVector256<Integer>; data: IVector128<Integer>; index: Byte): IVector256<Integer>; overload;
		{ class } function LoadAlignedVector256(address: ICoreClrInstance): IVector256<Shortint>;
		{ class } function LoadDquVector256(address: ICoreClrInstance): IVector256<Shortint>;
		{ class } function LoadVector256(address: ICoreClrInstance): IVector256<Shortint>;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<Double>): IVector256<Double>; overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<Single>; source: IVector128<Single>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<Double>; source: IVector128<Double>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<Single>; source: IVector256<Single>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<Double>; source: IVector256<Double>); overload;
		{ class } function Max(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Max(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function Min(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Min(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MoveMask(value: IVector256<Single>): Integer; overload;
		{ class } function MoveMask(value: IVector256<Double>): Integer; overload;
		{ class } function Multiply(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Multiply(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function &Or(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function &Or(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function Permute(value: IVector128<Single>; control: Byte): IVector128<Single>; overload;
		{ class } function Permute(value: IVector128<Double>; control: Byte): IVector128<Double>; overload;
		{ class } function Permute(value: IVector256<Single>; control: Byte): IVector256<Single>; overload;
		{ class } function Permute(value: IVector256<Double>; control: Byte): IVector256<Double>; overload;
		{ class } function Permute2x128(left: IVector256<Byte>; right: IVector256<Byte>; control: Byte): IVector256<Byte>; overload;
		{ class } function Permute2x128(left: IVector256<Shortint>; right: IVector256<Shortint>; control: Byte): IVector256<Shortint>; overload;
		{ class } function Permute2x128(left: IVector256<SmallInt>; right: IVector256<SmallInt>; control: Byte): IVector256<SmallInt>; overload;
		{ class } function Permute2x128(left: IVector256<Word>; right: IVector256<Word>; control: Byte): IVector256<Word>; overload;
		{ class } function Permute2x128(left: IVector256<Integer>; right: IVector256<Integer>; control: Byte): IVector256<Integer>; overload;
		{ class } function Permute2x128(left: IVector256<longword>; right: IVector256<longword>; control: Byte): IVector256<longword>; overload;
		{ class } function Permute2x128(left: IVector256<Int64>; right: IVector256<Int64>; control: Byte): IVector256<Int64>; overload;
		{ class } function Permute2x128(left: IVector256<UInt64>; right: IVector256<UInt64>; control: Byte): IVector256<UInt64>; overload;
		{ class } function Permute2x128(left: IVector256<Single>; right: IVector256<Single>; control: Byte): IVector256<Single>; overload;
		{ class } function Permute2x128(left: IVector256<Double>; right: IVector256<Double>; control: Byte): IVector256<Double>; overload;
		{ class } function PermuteVar(left: IVector128<Single>; control: IVector128<Integer>): IVector128<Single>; overload;
		{ class } function PermuteVar(left: IVector128<Double>; control: IVector128<Int64>): IVector128<Double>; overload;
		{ class } function PermuteVar(left: IVector256<Single>; control: IVector256<Integer>): IVector256<Single>; overload;
		{ class } function PermuteVar(left: IVector256<Double>; control: IVector256<Int64>): IVector256<Double>; overload;
		{ class } function Reciprocal(value: IVector256<Single>): IVector256<Single>;
		{ class } function ReciprocalSqrt(value: IVector256<Single>): IVector256<Single>;
		{ class } function RoundCurrentDirection(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function RoundCurrentDirection(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function RoundToNearestInteger(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function RoundToNearestInteger(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function RoundToNegativeInfinity(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function RoundToPositiveInfinity(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function RoundToZero(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function RoundToZero(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } function Shuffle(value: IVector256<Single>; right: IVector256<Single>; control: Byte): IVector256<Single>; overload;
		{ class } function Shuffle(value: IVector256<Double>; right: IVector256<Double>; control: Byte): IVector256<Double>; overload;
		{ class } function Sqrt(value: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Sqrt(value: IVector256<Double>): IVector256<Double>; overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Shortint>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Byte>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<SmallInt>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Word>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Integer>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<longword>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Int64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<UInt64>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Single>); overload;
		{ class } procedure Store(address: ICoreClrInstance; source: IVector256<Double>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Shortint>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Byte>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<SmallInt>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Word>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Integer>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<longword>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Int64>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<UInt64>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Single>); overload;
		{ class } procedure StoreAligned(address: ICoreClrInstance; source: IVector256<Double>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Shortint>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Byte>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<SmallInt>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Word>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Integer>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<longword>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Int64>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<UInt64>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Single>); overload;
		{ class } procedure StoreAlignedNonTemporal(address: ICoreClrInstance; source: IVector256<Double>); overload;
		{ class } function Subtract(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function Subtract(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function TestC(left: IVector128<Single>; right: IVector128<Single>): Boolean; overload;
		{ class } function TestC(left: IVector128<Double>; right: IVector128<Double>): Boolean; overload;
		{ class } function TestC(left: IVector256<Byte>; right: IVector256<Byte>): Boolean; overload;
		{ class } function TestC(left: IVector256<Shortint>; right: IVector256<Shortint>): Boolean; overload;
		{ class } function TestC(left: IVector256<SmallInt>; right: IVector256<SmallInt>): Boolean; overload;
		{ class } function TestC(left: IVector256<Word>; right: IVector256<Word>): Boolean; overload;
		{ class } function TestC(left: IVector256<Integer>; right: IVector256<Integer>): Boolean; overload;
		{ class } function TestC(left: IVector256<longword>; right: IVector256<longword>): Boolean; overload;
		{ class } function TestC(left: IVector256<Int64>; right: IVector256<Int64>): Boolean; overload;
		{ class } function TestC(left: IVector256<UInt64>; right: IVector256<UInt64>): Boolean; overload;
		{ class } function TestC(left: IVector256<Single>; right: IVector256<Single>): Boolean; overload;
		{ class } function TestC(left: IVector256<Double>; right: IVector256<Double>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Single>; right: IVector128<Single>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector128<Double>; right: IVector128<Double>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Byte>; right: IVector256<Byte>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Shortint>; right: IVector256<Shortint>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<SmallInt>; right: IVector256<SmallInt>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Word>; right: IVector256<Word>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Integer>; right: IVector256<Integer>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<longword>; right: IVector256<longword>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Int64>; right: IVector256<Int64>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<UInt64>; right: IVector256<UInt64>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Single>; right: IVector256<Single>): Boolean; overload;
		{ class } function TestNotZAndNotC(left: IVector256<Double>; right: IVector256<Double>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Single>; right: IVector128<Single>): Boolean; overload;
		{ class } function TestZ(left: IVector128<Double>; right: IVector128<Double>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Byte>; right: IVector256<Byte>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Shortint>; right: IVector256<Shortint>): Boolean; overload;
		{ class } function TestZ(left: IVector256<SmallInt>; right: IVector256<SmallInt>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Word>; right: IVector256<Word>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Integer>; right: IVector256<Integer>): Boolean; overload;
		{ class } function TestZ(left: IVector256<longword>; right: IVector256<longword>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Int64>; right: IVector256<Int64>): Boolean; overload;
		{ class } function TestZ(left: IVector256<UInt64>; right: IVector256<UInt64>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Single>; right: IVector256<Single>): Boolean; overload;
		{ class } function TestZ(left: IVector256<Double>; right: IVector256<Double>): Boolean; overload;
		{ class } function UnpackHigh(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function UnpackHigh(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function UnpackLow(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function UnpackLow(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } function &Xor(left: IVector256<Single>; right: IVector256<Single>): IVector256<Single>; overload;
		{ class } function &Xor(left: IVector256<Double>; right: IVector256<Double>): IVector256<Double>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_AVX)]
	IAvx = interface(ISse42)
	['{24F704FF-1E02-4003-862A-5911F94FBF76}']
	end;

	IX64_11Class = interface(ICoreClrClass)
	['{A179B6DB-1EFA-4553-9375-999E97984039}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_12)]
	IX64_11 = interface(IX64_10)
	['{F40B04D3-5E0C-4CBD-B13D-679976EF63E0}']
	end;

	IX64_14Class = interface(ICoreClrClass)
	['{B79DE56E-FDF9-4FF0-91EA-B0F9A8D8242E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_15)]
	IX64_14 = interface(IX64_11)
	['{FBC0632C-AA14-4D22-A288-D86DF85205D8}']
	end;

	IX64_12Class = interface(ICoreClrClass)
	['{36F3ACE9-8906-42B6-90F8-8BA7E6727644}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Extract(value: IVector128<Int64>; index: Byte): Int64; overload;
		{ class } function Extract(value: IVector128<UInt64>; index: Byte): UInt64; overload;
		{ class } function Insert(value: IVector128<Int64>; data: Int64; index: Byte): IVector128<Int64>; overload;
		{ class } function Insert(value: IVector128<UInt64>; data: UInt64; index: Byte): IVector128<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_13)]
	IX64_12 = interface(IX64_14)
	['{86B96725-EF6F-4AD0-82FF-0D7FE79ABBA9}']
	end;

	IX64_13Class = interface(ICoreClrClass)
	['{F9717F30-A085-46BC-9EB7-36A20FF6ECA0}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Crc32(crc: UInt64; data: UInt64): UInt64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_14)]
	IX64_13 = interface(IX64_12)
	['{1C4D3BE7-628B-429A-A68B-3E2519B632DD}']
	end;

	IX64_1Class = interface(ICoreClrClass)
	['{78E5E78E-13AA-4623-B4D8-2AC659398D2F}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_2)]
	IX64_1 = interface(IX64_13)
	['{502EA2F1-EB00-4827-88E3-5A44C64D0C42}']
	end;

	IAvx2Class = interface(ICoreClrClass)
	['{C31CDE1A-0128-4D35-BE07-9818DFBC3B1C}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function Abs(value: IVector256<Shortint>): IVector256<Byte>; overload;
		{ class } function Abs(value: IVector256<SmallInt>): IVector256<Word>; overload;
		{ class } function Abs(value: IVector256<Integer>): IVector256<longword>; overload;
		{ class } function Add(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Add(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Add(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Add(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function Add(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function Add(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function Add(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function Add(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function AddSaturate(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function AddSaturate(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function AddSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function AddSaturate(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function AlignRight(left: IVector256<Shortint>; right: IVector256<Shortint>; mask: Byte): IVector256<Shortint>; overload;
		{ class } function AlignRight(left: IVector256<Byte>; right: IVector256<Byte>; mask: Byte): IVector256<Byte>; overload;
		{ class } function AlignRight(left: IVector256<SmallInt>; right: IVector256<SmallInt>; mask: Byte): IVector256<SmallInt>; overload;
		{ class } function AlignRight(left: IVector256<Word>; right: IVector256<Word>; mask: Byte): IVector256<Word>; overload;
		{ class } function AlignRight(left: IVector256<Integer>; right: IVector256<Integer>; mask: Byte): IVector256<Integer>; overload;
		{ class } function AlignRight(left: IVector256<longword>; right: IVector256<longword>; mask: Byte): IVector256<longword>; overload;
		{ class } function AlignRight(left: IVector256<Int64>; right: IVector256<Int64>; mask: Byte): IVector256<Int64>; overload;
		{ class } function AlignRight(left: IVector256<UInt64>; right: IVector256<UInt64>; mask: Byte): IVector256<UInt64>; overload;
		{ class } function &And(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function &And(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function &And(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function &And(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function &And(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function &And(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function &And(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function &And(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function AndNot(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function AndNot(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function AndNot(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function AndNot(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function AndNot(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function AndNot(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function AndNot(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function AndNot(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function Average(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Average(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function Blend(left: IVector128<Integer>; right: IVector128<Integer>; control: Byte): IVector128<Integer>; overload;
		{ class } function Blend(left: IVector128<longword>; right: IVector128<longword>; control: Byte): IVector128<longword>; overload;
		{ class } function Blend(left: IVector256<SmallInt>; right: IVector256<SmallInt>; control: Byte): IVector256<SmallInt>; overload;
		{ class } function Blend(left: IVector256<Word>; right: IVector256<Word>; control: Byte): IVector256<Word>; overload;
		{ class } function Blend(left: IVector256<Integer>; right: IVector256<Integer>; control: Byte): IVector256<Integer>; overload;
		{ class } function Blend(left: IVector256<longword>; right: IVector256<longword>; control: Byte): IVector256<longword>; overload;
		{ class } function BlendVariable(left: IVector256<Shortint>; right: IVector256<Shortint>; mask: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function BlendVariable(left: IVector256<Byte>; right: IVector256<Byte>; mask: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function BlendVariable(left: IVector256<SmallInt>; right: IVector256<SmallInt>; mask: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function BlendVariable(left: IVector256<Word>; right: IVector256<Word>; mask: IVector256<Word>): IVector256<Word>; overload;
		{ class } function BlendVariable(left: IVector256<Integer>; right: IVector256<Integer>; mask: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function BlendVariable(left: IVector256<longword>; right: IVector256<longword>; mask: IVector256<longword>): IVector256<longword>; overload;
		{ class } function BlendVariable(left: IVector256<Int64>; right: IVector256<Int64>; mask: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function BlendVariable(left: IVector256<UInt64>; right: IVector256<UInt64>; mask: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Byte>): IVector128<Byte>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Shortint>): IVector128<Shortint>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Word>): IVector128<Word>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<longword>): IVector128<longword>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Single>): IVector128<Single>; overload;
		{ class } function BroadcastScalarToVector128(value: IVector128<Double>): IVector128<Double>; overload;
		{ class } function BroadcastScalarToVector128(source: ICoreClrInstance): IVector128<Byte>; overload;
		{ class } function BroadcastScalarToVector256(source: ICoreClrInstance): IVector256<Shortint>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Byte>): IVector256<Byte>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Shortint>): IVector256<Shortint>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Word>): IVector256<Word>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Integer>): IVector256<Integer>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<longword>): IVector256<longword>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Int64>): IVector256<Int64>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<UInt64>): IVector256<UInt64>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Single>): IVector256<Single>; overload;
		{ class } function BroadcastScalarToVector256(value: IVector128<Double>): IVector256<Double>; overload;
		{ class } function BroadcastVector128ToVector256(address: ICoreClrInstance): IVector256<Shortint>;
		{ class } function CompareEqual(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function CompareEqual(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function CompareEqual(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function CompareEqual(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function CompareEqual(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function CompareEqual(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function CompareEqual(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function CompareEqual(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function CompareGreaterThan(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function CompareGreaterThan(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function CompareGreaterThan(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function CompareGreaterThan(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function ConvertToInt32(value: IVector256<Integer>): Integer;
		{ class } function ConvertToUInt32(value: IVector256<longword>): longword;
		{ class } function ConvertToVector256Int16(value: IVector128<Shortint>): IVector256<SmallInt>; overload;
		{ class } function ConvertToVector256Int16(value: IVector128<Byte>): IVector256<SmallInt>; overload;
		{ class } function ConvertToVector256Int16(address: ICoreClrInstance): IVector256<SmallInt>; overload;
		{ class } function ConvertToVector256Int32(value: IVector128<Shortint>): IVector256<Integer>; overload;
		{ class } function ConvertToVector256Int32(value: IVector128<Byte>): IVector256<Integer>; overload;
		{ class } function ConvertToVector256Int32(value: IVector128<SmallInt>): IVector256<Integer>; overload;
		{ class } function ConvertToVector256Int32(value: IVector128<Word>): IVector256<Integer>; overload;
		{ class } function ConvertToVector256Int32(address: ICoreClrInstance): IVector256<Integer>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<Shortint>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<Byte>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<SmallInt>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<Word>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<Integer>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(value: IVector128<longword>): IVector256<Int64>; overload;
		{ class } function ConvertToVector256Int64(address: ICoreClrInstance): IVector256<Int64>; overload;
		{ class } function ExtractVector128(value: IVector256<Shortint>; index: Byte): IVector128<Shortint>; overload;
		{ class } function ExtractVector128(value: IVector256<Byte>; index: Byte): IVector128<Byte>; overload;
		{ class } function ExtractVector128(value: IVector256<SmallInt>; index: Byte): IVector128<SmallInt>; overload;
		{ class } function ExtractVector128(value: IVector256<Word>; index: Byte): IVector128<Word>; overload;
		{ class } function ExtractVector128(value: IVector256<Integer>; index: Byte): IVector128<Integer>; overload;
		{ class } function ExtractVector128(value: IVector256<longword>; index: Byte): IVector128<longword>; overload;
		{ class } function ExtractVector128(value: IVector256<Int64>; index: Byte): IVector128<Int64>; overload;
		{ class } function ExtractVector128(value: IVector256<UInt64>; index: Byte): IVector128<UInt64>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Integer>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<Integer>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherMaskVector128(source: IVector128<longword>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<longword>; scale: Byte): IVector128<longword>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Int64>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<Int64>; scale: Byte): IVector128<Int64>; overload;
		{ class } function GatherMaskVector128(source: IVector128<UInt64>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<UInt64>; scale: Byte): IVector128<UInt64>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Single>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<Single>; scale: Byte): IVector128<Single>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Double>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector128<Double>; scale: Byte): IVector128<Double>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Integer>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<Integer>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherMaskVector128(source: IVector128<longword>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<longword>; scale: Byte): IVector128<longword>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Int64>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<Int64>; scale: Byte): IVector128<Int64>; overload;
		{ class } function GatherMaskVector128(source: IVector128<UInt64>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<UInt64>; scale: Byte): IVector128<UInt64>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Single>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<Single>; scale: Byte): IVector128<Single>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Double>; baseAddress: ICoreClrInstance; index: IVector128<Int64>; mask: IVector128<Double>; scale: Byte): IVector128<Double>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Integer>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector128<Integer>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherMaskVector128(source: IVector128<longword>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector128<longword>; scale: Byte): IVector128<longword>; overload;
		{ class } function GatherMaskVector128(source: IVector128<Single>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector128<Single>; scale: Byte): IVector128<Single>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Integer>; baseAddress: ICoreClrInstance; index: IVector256<Integer>; mask: IVector256<Integer>; scale: Byte): IVector256<Integer>; overload;
		{ class } function GatherMaskVector256(source: IVector256<longword>; baseAddress: ICoreClrInstance; index: IVector256<Integer>; mask: IVector256<longword>; scale: Byte): IVector256<longword>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Int64>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector256<Int64>; scale: Byte): IVector256<Int64>; overload;
		{ class } function GatherMaskVector256(source: IVector256<UInt64>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector256<UInt64>; scale: Byte): IVector256<UInt64>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Single>; baseAddress: ICoreClrInstance; index: IVector256<Integer>; mask: IVector256<Single>; scale: Byte): IVector256<Single>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Double>; baseAddress: ICoreClrInstance; index: IVector128<Integer>; mask: IVector256<Double>; scale: Byte): IVector256<Double>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Int64>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector256<Int64>; scale: Byte): IVector256<Int64>; overload;
		{ class } function GatherMaskVector256(source: IVector256<UInt64>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector256<UInt64>; scale: Byte): IVector256<UInt64>; overload;
		{ class } function GatherMaskVector256(source: IVector256<Double>; baseAddress: ICoreClrInstance; index: IVector256<Int64>; mask: IVector256<Double>; scale: Byte): IVector256<Double>; overload;
		{ class } function GatherVector128(baseAddress: ICoreClrInstance; index: IVector128<Integer>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherVector128(baseAddress: ICoreClrInstance; index: IVector128<Int64>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherVector128(baseAddress: ICoreClrInstance; index: IVector256<Int64>; scale: Byte): IVector128<Integer>; overload;
		{ class } function GatherVector256(baseAddress: ICoreClrInstance; index: IVector256<Integer>; scale: Byte): IVector256<Integer>; overload;
		{ class } function GatherVector256(baseAddress: ICoreClrInstance; index: IVector128<Integer>; scale: Byte): IVector256<Int64>; overload;
		{ class } function GatherVector256(baseAddress: ICoreClrInstance; index: IVector256<Int64>; scale: Byte): IVector256<Int64>; overload;
		{ class } function HorizontalAdd(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function HorizontalAdd(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function HorizontalAddSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>;
		{ class } function HorizontalSubtract(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function HorizontalSubtract(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function HorizontalSubtractSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>;
		{ class } function InsertVector128(value: IVector256<Shortint>; data: IVector128<Shortint>; index: Byte): IVector256<Shortint>; overload;
		{ class } function InsertVector128(value: IVector256<Byte>; data: IVector128<Byte>; index: Byte): IVector256<Byte>; overload;
		{ class } function InsertVector128(value: IVector256<SmallInt>; data: IVector128<SmallInt>; index: Byte): IVector256<SmallInt>; overload;
		{ class } function InsertVector128(value: IVector256<Word>; data: IVector128<Word>; index: Byte): IVector256<Word>; overload;
		{ class } function InsertVector128(value: IVector256<Integer>; data: IVector128<Integer>; index: Byte): IVector256<Integer>; overload;
		{ class } function InsertVector128(value: IVector256<longword>; data: IVector128<longword>; index: Byte): IVector256<longword>; overload;
		{ class } function InsertVector128(value: IVector256<Int64>; data: IVector128<Int64>; index: Byte): IVector256<Int64>; overload;
		{ class } function InsertVector128(value: IVector256<UInt64>; data: IVector128<UInt64>; index: Byte): IVector256<UInt64>; overload;
		{ class } function LoadAlignedVector256NonTemporal(address: ICoreClrInstance): IVector256<Shortint>;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<longword>): IVector128<longword>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<Int64>): IVector128<Int64>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<longword>): IVector256<longword>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function MaskLoad(address: ICoreClrInstance; mask: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<Integer>; source: IVector128<Integer>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<longword>; source: IVector128<longword>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<Int64>; source: IVector128<Int64>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector128<UInt64>; source: IVector128<UInt64>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<Integer>; source: IVector256<Integer>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<longword>; source: IVector256<longword>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<Int64>; source: IVector256<Int64>); overload;
		{ class } procedure MaskStore(address: ICoreClrInstance; mask: IVector256<UInt64>; source: IVector256<UInt64>); overload;
		{ class } function Max(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Max(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Max(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Max(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function Max(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function Max(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function Min(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Min(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Min(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Min(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function Min(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function Min(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function MoveMask(value: IVector256<Shortint>): Integer; overload;
		{ class } function MoveMask(value: IVector256<Byte>): Integer; overload;
		{ class } function MultipleSumAbsoluteDifferences(left: IVector256<Byte>; right: IVector256<Byte>; mask: Byte): IVector256<Word>;
		{ class } function Multiply(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Int64>; overload;
		{ class } function Multiply(left: IVector256<longword>; right: IVector256<longword>): IVector256<UInt64>; overload;
		{ class } function MultiplyAddAdjacent(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<Integer>; overload;
		{ class } function MultiplyAddAdjacent(left: IVector256<Byte>; right: IVector256<Shortint>): IVector256<SmallInt>; overload;
		{ class } function MultiplyHigh(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function MultiplyHigh(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function MultiplyHighRoundScale(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>;
		{ class } function MultiplyLow(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function MultiplyLow(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function MultiplyLow(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function MultiplyLow(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function &Or(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function &Or(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function &Or(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function &Or(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function &Or(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function &Or(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function &Or(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function &Or(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function PackSignedSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<Shortint>; overload;
		{ class } function PackSignedSaturate(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<SmallInt>; overload;
		{ class } function PackUnsignedSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<Byte>; overload;
		{ class } function PackUnsignedSaturate(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Word>; overload;
		{ class } function Permute2x128(left: IVector256<Shortint>; right: IVector256<Shortint>; control: Byte): IVector256<Shortint>; overload;
		{ class } function Permute2x128(left: IVector256<Byte>; right: IVector256<Byte>; control: Byte): IVector256<Byte>; overload;
		{ class } function Permute2x128(left: IVector256<SmallInt>; right: IVector256<SmallInt>; control: Byte): IVector256<SmallInt>; overload;
		{ class } function Permute2x128(left: IVector256<Word>; right: IVector256<Word>; control: Byte): IVector256<Word>; overload;
		{ class } function Permute2x128(left: IVector256<Integer>; right: IVector256<Integer>; control: Byte): IVector256<Integer>; overload;
		{ class } function Permute2x128(left: IVector256<longword>; right: IVector256<longword>; control: Byte): IVector256<longword>; overload;
		{ class } function Permute2x128(left: IVector256<Int64>; right: IVector256<Int64>; control: Byte): IVector256<Int64>; overload;
		{ class } function Permute2x128(left: IVector256<UInt64>; right: IVector256<UInt64>; control: Byte): IVector256<UInt64>; overload;
		{ class } function Permute4x64(value: IVector256<Int64>; control: Byte): IVector256<Int64>; overload;
		{ class } function Permute4x64(value: IVector256<UInt64>; control: Byte): IVector256<UInt64>; overload;
		{ class } function Permute4x64(value: IVector256<Double>; control: Byte): IVector256<Double>; overload;
		{ class } function PermuteVar8x32(left: IVector256<Integer>; control: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function PermuteVar8x32(left: IVector256<longword>; control: IVector256<longword>): IVector256<longword>; overload;
		{ class } function PermuteVar8x32(left: IVector256<Single>; control: IVector256<Integer>): IVector256<Single>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<SmallInt>; count: IVector128<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Word>; count: IVector128<Word>): IVector256<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Integer>; count: IVector128<Integer>): IVector256<Integer>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<longword>; count: IVector128<longword>): IVector256<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Int64>; count: IVector128<Int64>): IVector256<Int64>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<UInt64>; count: IVector128<UInt64>): IVector256<UInt64>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<SmallInt>; count: Byte): IVector256<SmallInt>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Word>; count: Byte): IVector256<Word>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Integer>; count: Byte): IVector256<Integer>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<longword>; count: Byte): IVector256<longword>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<Int64>; count: Byte): IVector256<Int64>; overload;
		{ class } function ShiftLeftLogical(value: IVector256<UInt64>; count: Byte): IVector256<UInt64>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<Shortint>; numBytes: Byte): IVector256<Shortint>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<Byte>; numBytes: Byte): IVector256<Byte>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<SmallInt>; numBytes: Byte): IVector256<SmallInt>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<Word>; numBytes: Byte): IVector256<Word>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<Integer>; numBytes: Byte): IVector256<Integer>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<longword>; numBytes: Byte): IVector256<longword>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<Int64>; numBytes: Byte): IVector256<Int64>; overload;
		{ class } function ShiftLeftLogical128BitLane(value: IVector256<UInt64>; numBytes: Byte): IVector256<UInt64>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector256<Integer>; count: IVector256<longword>): IVector256<Integer>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector256<longword>; count: IVector256<longword>): IVector256<longword>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector256<Int64>; count: IVector256<UInt64>): IVector256<Int64>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector256<UInt64>; count: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector128<Integer>; count: IVector128<longword>): IVector128<Integer>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector128<longword>; count: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector128<Int64>; count: IVector128<UInt64>): IVector128<Int64>; overload;
		{ class } function ShiftLeftLogicalVariable(value: IVector128<UInt64>; count: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ShiftRightArithmetic(value: IVector256<SmallInt>; count: IVector128<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector256<Integer>; count: IVector128<Integer>): IVector256<Integer>; overload;
		{ class } function ShiftRightArithmetic(value: IVector256<SmallInt>; count: Byte): IVector256<SmallInt>; overload;
		{ class } function ShiftRightArithmetic(value: IVector256<Integer>; count: Byte): IVector256<Integer>; overload;
		{ class } function ShiftRightArithmeticVariable(value: IVector256<Integer>; count: IVector256<longword>): IVector256<Integer>; overload;
		{ class } function ShiftRightArithmeticVariable(value: IVector128<Integer>; count: IVector128<longword>): IVector128<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector256<SmallInt>; count: IVector128<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Word>; count: IVector128<Word>): IVector256<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Integer>; count: IVector128<Integer>): IVector256<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector256<longword>; count: IVector128<longword>): IVector256<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Int64>; count: IVector128<Int64>): IVector256<Int64>; overload;
		{ class } function ShiftRightLogical(value: IVector256<UInt64>; count: IVector128<UInt64>): IVector256<UInt64>; overload;
		{ class } function ShiftRightLogical(value: IVector256<SmallInt>; count: Byte): IVector256<SmallInt>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Word>; count: Byte): IVector256<Word>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Integer>; count: Byte): IVector256<Integer>; overload;
		{ class } function ShiftRightLogical(value: IVector256<longword>; count: Byte): IVector256<longword>; overload;
		{ class } function ShiftRightLogical(value: IVector256<Int64>; count: Byte): IVector256<Int64>; overload;
		{ class } function ShiftRightLogical(value: IVector256<UInt64>; count: Byte): IVector256<UInt64>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<Shortint>; numBytes: Byte): IVector256<Shortint>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<Byte>; numBytes: Byte): IVector256<Byte>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<SmallInt>; numBytes: Byte): IVector256<SmallInt>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<Word>; numBytes: Byte): IVector256<Word>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<Integer>; numBytes: Byte): IVector256<Integer>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<longword>; numBytes: Byte): IVector256<longword>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<Int64>; numBytes: Byte): IVector256<Int64>; overload;
		{ class } function ShiftRightLogical128BitLane(value: IVector256<UInt64>; numBytes: Byte): IVector256<UInt64>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector256<Int64>; count: IVector256<UInt64>): IVector256<Int64>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector256<UInt64>; count: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector128<Integer>; count: IVector128<longword>): IVector128<Integer>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector128<longword>; count: IVector128<longword>): IVector128<longword>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector128<Int64>; count: IVector128<UInt64>): IVector128<Int64>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector128<UInt64>; count: IVector128<UInt64>): IVector128<UInt64>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector256<Integer>; count: IVector256<longword>): IVector256<Integer>; overload;
		{ class } function ShiftRightLogicalVariable(value: IVector256<longword>; count: IVector256<longword>): IVector256<longword>; overload;
		{ class } function Shuffle(value: IVector256<Shortint>; mask: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Shuffle(value: IVector256<Byte>; mask: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Shuffle(value: IVector256<Integer>; control: Byte): IVector256<Integer>; overload;
		{ class } function Shuffle(value: IVector256<longword>; control: Byte): IVector256<longword>; overload;
		{ class } function ShuffleHigh(value: IVector256<SmallInt>; control: Byte): IVector256<SmallInt>; overload;
		{ class } function ShuffleHigh(value: IVector256<Word>; control: Byte): IVector256<Word>; overload;
		{ class } function ShuffleLow(value: IVector256<SmallInt>; control: Byte): IVector256<SmallInt>; overload;
		{ class } function ShuffleLow(value: IVector256<Word>; control: Byte): IVector256<Word>; overload;
		{ class } function Sign(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Sign(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Sign(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function Subtract(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function Subtract(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function Subtract(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Subtract(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function Subtract(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function Subtract(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function Subtract(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function Subtract(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function SubtractSaturate(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function SubtractSaturate(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function SubtractSaturate(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function SubtractSaturate(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function SumAbsoluteDifferences(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Word>;
		{ class } function UnpackHigh(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function UnpackHigh(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function UnpackHigh(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function UnpackHigh(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function UnpackHigh(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function UnpackHigh(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function UnpackHigh(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function UnpackHigh(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function UnpackLow(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function UnpackLow(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function UnpackLow(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function UnpackLow(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function UnpackLow(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function UnpackLow(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function UnpackLow(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function UnpackLow(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } function &Xor(left: IVector256<Shortint>; right: IVector256<Shortint>): IVector256<Shortint>; overload;
		{ class } function &Xor(left: IVector256<Byte>; right: IVector256<Byte>): IVector256<Byte>; overload;
		{ class } function &Xor(left: IVector256<SmallInt>; right: IVector256<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function &Xor(left: IVector256<Word>; right: IVector256<Word>): IVector256<Word>; overload;
		{ class } function &Xor(left: IVector256<Integer>; right: IVector256<Integer>): IVector256<Integer>; overload;
		{ class } function &Xor(left: IVector256<longword>; right: IVector256<longword>): IVector256<longword>; overload;
		{ class } function &Xor(left: IVector256<Int64>; right: IVector256<Int64>): IVector256<Int64>; overload;
		{ class } function &Xor(left: IVector256<UInt64>; right: IVector256<UInt64>): IVector256<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_AVX2)]
	IAvx2 = interface(IAvx)
	['{BA4F3B27-2914-4BA2-BBA8-0CB16BB61861}']
	end;

	IX64_2Class = interface(ICoreClrClass)
	['{EF8929C4-0FEB-4B7C-BE67-C76656A609E9}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_3)]
	IX64_2 = interface(IX64_1)
	['{26C145AB-5A0A-4C97-BF9E-320181811326}']
	end;

	[CoreTypeSignature(SYSTEM_BADIMAGEFORMATEXCEPTION)]
	IBadImageFormatException = interface(ISystemException)
	['{2283B0CA-C227-4B1D-8E7F-E066F084B501}']
	{ private }
		function _GetProp_FileName: String;
		function _GetProp_FusionLog: String;
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property FileName: String read _GetProp_FileName;
		property FusionLog: String read _GetProp_FusionLog;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_BESTFITMAPPINGATTRIBUTE)]
	IBestFitMappingAttribute = interface(IAttribute)
	['{5C6E4910-6474-424D-8D6D-EB6006F36569}']
	{ private }
		function _GetFld_ThrowOnUnmappableChar: Boolean;
		procedure _SetFld_ThrowOnUnmappableChar(Value: Boolean);
		function _GetProp_BestFitMapping: Boolean;
	{ public }
		property ThrowOnUnmappableChar: Boolean read _GetFld_ThrowOnUnmappableChar write _SetFld_ThrowOnUnmappableChar;
		property BestFitMapping: Boolean read _GetProp_BestFitMapping;
	end;

	IBinaryPrimitivesClass = interface(ICoreClrClass)
	['{2CAFD9D7-D5C0-4C41-8355-121EAD934C29}']
	{ public }
		{ class } function ReadDoubleBigEndian(source: IReadOnlySpan<Byte>): Double;
		{ class } function ReadDoubleLittleEndian(source: IReadOnlySpan<Byte>): Double;
		{ class } function ReadInt16BigEndian(source: IReadOnlySpan<Byte>): SmallInt;
		{ class } function ReadInt16LittleEndian(source: IReadOnlySpan<Byte>): SmallInt;
		{ class } function ReadInt32BigEndian(source: IReadOnlySpan<Byte>): Integer;
		{ class } function ReadInt32LittleEndian(source: IReadOnlySpan<Byte>): Integer;
		{ class } function ReadInt64BigEndian(source: IReadOnlySpan<Byte>): Int64;
		{ class } function ReadInt64LittleEndian(source: IReadOnlySpan<Byte>): Int64;
		{ class } function ReadSingleBigEndian(source: IReadOnlySpan<Byte>): Single;
		{ class } function ReadSingleLittleEndian(source: IReadOnlySpan<Byte>): Single;
		{ class } function ReadUInt16BigEndian(source: IReadOnlySpan<Byte>): Word;
		{ class } function ReadUInt16LittleEndian(source: IReadOnlySpan<Byte>): Word;
		{ class } function ReadUInt32BigEndian(source: IReadOnlySpan<Byte>): longword;
		{ class } function ReadUInt32LittleEndian(source: IReadOnlySpan<Byte>): longword;
		{ class } function ReadUInt64BigEndian(source: IReadOnlySpan<Byte>): UInt64;
		{ class } function ReadUInt64LittleEndian(source: IReadOnlySpan<Byte>): UInt64;
		{ class } function ReverseEndianness(value: Shortint): Shortint; overload;
		{ class } function ReverseEndianness(value: SmallInt): SmallInt; overload;
		{ class } function ReverseEndianness(value: Integer): Integer; overload;
		{ class } function ReverseEndianness(value: Int64): Int64; overload;
		{ class } function ReverseEndianness(value: Byte): Byte; overload;
		{ class } function ReverseEndianness(value: Word): Word; overload;
		{ class } function ReverseEndianness(value: longword): longword; overload;
		{ class } function ReverseEndianness(value: UInt64): UInt64; overload;
		{ class } function TryReadDoubleBigEndian(source: IReadOnlySpan<Byte>; var value: Double): Boolean;
		{ class } function TryReadDoubleLittleEndian(source: IReadOnlySpan<Byte>; var value: Double): Boolean;
		{ class } function TryReadInt16BigEndian(source: IReadOnlySpan<Byte>; var value: SmallInt): Boolean;
		{ class } function TryReadInt16LittleEndian(source: IReadOnlySpan<Byte>; var value: SmallInt): Boolean;
		{ class } function TryReadInt32BigEndian(source: IReadOnlySpan<Byte>; var value: Integer): Boolean;
		{ class } function TryReadInt32LittleEndian(source: IReadOnlySpan<Byte>; var value: Integer): Boolean;
		{ class } function TryReadInt64BigEndian(source: IReadOnlySpan<Byte>; var value: Int64): Boolean;
		{ class } function TryReadInt64LittleEndian(source: IReadOnlySpan<Byte>; var value: Int64): Boolean;
		{ class } function TryReadSingleBigEndian(source: IReadOnlySpan<Byte>; var value: Single): Boolean;
		{ class } function TryReadSingleLittleEndian(source: IReadOnlySpan<Byte>; var value: Single): Boolean;
		{ class } function TryReadUInt16BigEndian(source: IReadOnlySpan<Byte>; var value: Word): Boolean;
		{ class } function TryReadUInt16LittleEndian(source: IReadOnlySpan<Byte>; var value: Word): Boolean;
		{ class } function TryReadUInt32BigEndian(source: IReadOnlySpan<Byte>; var value: longword): Boolean;
		{ class } function TryReadUInt32LittleEndian(source: IReadOnlySpan<Byte>; var value: longword): Boolean;
		{ class } function TryReadUInt64BigEndian(source: IReadOnlySpan<Byte>; var value: UInt64): Boolean;
		{ class } function TryReadUInt64LittleEndian(source: IReadOnlySpan<Byte>; var value: UInt64): Boolean;
		{ class } function TryWriteDoubleBigEndian(destination: ISpan<Byte>; value: Double): Boolean;
		{ class } function TryWriteDoubleLittleEndian(destination: ISpan<Byte>; value: Double): Boolean;
		{ class } function TryWriteInt16BigEndian(destination: ISpan<Byte>; value: SmallInt): Boolean;
		{ class } function TryWriteInt16LittleEndian(destination: ISpan<Byte>; value: SmallInt): Boolean;
		{ class } function TryWriteInt32BigEndian(destination: ISpan<Byte>; value: Integer): Boolean;
		{ class } function TryWriteInt32LittleEndian(destination: ISpan<Byte>; value: Integer): Boolean;
		{ class } function TryWriteInt64BigEndian(destination: ISpan<Byte>; value: Int64): Boolean;
		{ class } function TryWriteInt64LittleEndian(destination: ISpan<Byte>; value: Int64): Boolean;
		{ class } function TryWriteSingleBigEndian(destination: ISpan<Byte>; value: Single): Boolean;
		{ class } function TryWriteSingleLittleEndian(destination: ISpan<Byte>; value: Single): Boolean;
		{ class } function TryWriteUInt16BigEndian(destination: ISpan<Byte>; value: Word): Boolean;
		{ class } function TryWriteUInt16LittleEndian(destination: ISpan<Byte>; value: Word): Boolean;
		{ class } function TryWriteUInt32BigEndian(destination: ISpan<Byte>; value: longword): Boolean;
		{ class } function TryWriteUInt32LittleEndian(destination: ISpan<Byte>; value: longword): Boolean;
		{ class } function TryWriteUInt64BigEndian(destination: ISpan<Byte>; value: UInt64): Boolean;
		{ class } function TryWriteUInt64LittleEndian(destination: ISpan<Byte>; value: UInt64): Boolean;
		{ class } procedure WriteDoubleBigEndian(destination: ISpan<Byte>; value: Double);
		{ class } procedure WriteDoubleLittleEndian(destination: ISpan<Byte>; value: Double);
		{ class } procedure WriteInt16BigEndian(destination: ISpan<Byte>; value: SmallInt);
		{ class } procedure WriteInt16LittleEndian(destination: ISpan<Byte>; value: SmallInt);
		{ class } procedure WriteInt32BigEndian(destination: ISpan<Byte>; value: Integer);
		{ class } procedure WriteInt32LittleEndian(destination: ISpan<Byte>; value: Integer);
		{ class } procedure WriteInt64BigEndian(destination: ISpan<Byte>; value: Int64);
		{ class } procedure WriteInt64LittleEndian(destination: ISpan<Byte>; value: Int64);
		{ class } procedure WriteSingleBigEndian(destination: ISpan<Byte>; value: Single);
		{ class } procedure WriteSingleLittleEndian(destination: ISpan<Byte>; value: Single);
		{ class } procedure WriteUInt16BigEndian(destination: ISpan<Byte>; value: Word);
		{ class } procedure WriteUInt16LittleEndian(destination: ISpan<Byte>; value: Word);
		{ class } procedure WriteUInt32BigEndian(destination: ISpan<Byte>; value: longword);
		{ class } procedure WriteUInt32LittleEndian(destination: ISpan<Byte>; value: longword);
		{ class } procedure WriteUInt64BigEndian(destination: ISpan<Byte>; value: UInt64);
		{ class } procedure WriteUInt64LittleEndian(destination: ISpan<Byte>; value: UInt64);
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_BINARY_BINARYPRIMITIVES)]
	IBinaryPrimitives = interface(IObject)
	['{CBBA9064-581E-4EA4-9B79-A595EC29ABDA}']
	end;

	[CoreTypeSignature(SYSTEM_IDISPOSABLE)]
	IIDisposable = interface(IObject)
	['{6A29AE62-7DB7-4C55-A16B-348CB3D0EFA7}']
	{ public }
		procedure Dispose();
	end;

	[CoreTypeSignature(SYSTEM_IO_BINARYREADER)]
	IBinaryReader = interface(IIDisposable)
	['{C4372987-5C33-41E9-96BA-8A805AC2A428}']
	{ private }
		function _GetProp_BaseStream: IStream;
	{ public }
		procedure Close();
		procedure Dispose();
		function PeekChar(): Integer;
		function Read(): Integer; overload;
		function Read(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function Read(buffer: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Char>): Integer; overload;
		function Read(buffer: ISpan<Byte>): Integer; overload;
		function Read7BitEncodedInt(): Integer;
		function Read7BitEncodedInt64(): Int64;
		function ReadBoolean(): Boolean;
		function ReadByte(): Byte;
		function ReadBytes(count: Integer): TArray<Byte>;
		function ReadChar(): Char;
		function ReadChars(count: Integer): TArray<Char>;
		function ReadDecimal(): IDecimal;
		function ReadDouble(): Double;
		function ReadInt16(): SmallInt;
		function ReadInt32(): Integer;
		function ReadInt64(): Int64;
		function ReadSByte(): Shortint;
		function ReadSingle(): Single;
		function ReadString(): String;
		function ReadUInt16(): Word;
		function ReadUInt32(): longword;
		function ReadUInt64(): UInt64;
		property BaseStream: IStream read _GetProp_BaseStream;
	end;

	IBinaryWriterClass = interface(ICoreClrClass)
	['{60BF1370-6EC6-4544-A2DA-662471D4E84C}']
	{ private }
		{ class } function _GetFld_Null: IBinaryWriter;
	{ public }
		{ class } property Null: IBinaryWriter read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_BINARYWRITER)]
	IBinaryWriter = interface(IObject)
	['{8CB57E73-A4E1-4290-BC71-9940FA64EC73}']
	{ private }
		function _GetProp_BaseStream: IStream;
	{ public }
		procedure Close();
		procedure Dispose();
		function DisposeAsync(): IValueTask;
		procedure Flush();
		function Seek(offset: Integer; origin: TSeekOrigin): Int64;
		procedure Write(value: Boolean); overload;
		procedure Write(value: Byte); overload;
		procedure Write(value: Shortint); overload;
		procedure Write(buffer: TArray<Byte>); overload;
		procedure Write(ch: Char); overload;
		procedure Write(chars: TArray<Char>); overload;
		procedure Write(value: Double); overload;
		procedure Write(value: IDecimal); overload;
		procedure Write(value: SmallInt); overload;
		procedure Write(value: Word); overload;
		procedure Write(value: Integer); overload;
		procedure Write(value: longword); overload;
		procedure Write(value: Int64); overload;
		procedure Write(value: UInt64); overload;
		procedure Write(value: Single); overload;
		procedure Write(value: String); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		procedure Write(chars: IReadOnlySpan<Char>); overload;
		procedure Write(buffer: TArray<Byte>; index: Integer; count: Integer); overload;
		procedure Write(chars: TArray<Char>; index: Integer; count: Integer); overload;
		procedure Write7BitEncodedInt(value: Integer);
		procedure Write7BitEncodedInt64(value: Int64);
		property BaseStream: IStream read _GetProp_BaseStream;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_BIND_OPTS)]
	IBIND_OPTS = interface(IValueType)
	['{209DAB2B-E4DC-41E1-A4DE-89F5A066B179}']
	{ private }
		function _GetFld_cbStruct: Integer;
		procedure _SetFld_cbStruct(Value: Integer);
		function _GetFld_dwTickCountDeadline: Integer;
		procedure _SetFld_dwTickCountDeadline(Value: Integer);
		function _GetFld_grfFlags: Integer;
		procedure _SetFld_grfFlags(Value: Integer);
		function _GetFld_grfMode: Integer;
		procedure _SetFld_grfMode(Value: Integer);
	{ public }
		property cbStruct: Integer read _GetFld_cbStruct write _SetFld_cbStruct;
		property dwTickCountDeadline: Integer read _GetFld_dwTickCountDeadline write _SetFld_dwTickCountDeadline;
		property grfFlags: Integer read _GetFld_grfFlags write _SetFld_grfFlags;
		property grfMode: Integer read _GetFld_grfMode write _SetFld_grfMode;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_BINDER)]
	IBinder = interface(IObject)
	['{F79565F6-DA53-485E-AC19-4F3EFF97DA4D}']
	{ public }
		function BindToField(bindingAttr: TBindingFlags_Set; match: ICoreClrBridgeArray<IFieldInfo>; value: Variant; culture: ICultureInfo): IFieldInfo;
		function BindToMethod(bindingAttr: TBindingFlags_Set; match: ICoreClrBridgeArray<IMethodBase>; var args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; names: TArray<String>; var state: Variant): IMethodBase;
		function ChangeType(value: Variant; type_: IType; culture: ICultureInfo): Variant;
		procedure ReorderArgumentArray(var args: TArray<Variant>; state: Variant);
		function SelectMethod(bindingAttr: TBindingFlags_Set; match: ICoreClrBridgeArray<IMethodBase>; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodBase;
		function SelectProperty(bindingAttr: TBindingFlags_Set; match: ICoreClrBridgeArray<IPropertyInfo>; returnType: IType; indexes: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IPropertyInfo;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_BINDPTR)]
	IBINDPTR = interface(IValueType)
	['{34167E71-A056-414E-99F4-5EE45FC005D0}']
	{ private }
		function _GetFld_lpfuncdesc: IIntPtr;
		procedure _SetFld_lpfuncdesc(Value: IIntPtr);
		function _GetFld_lptcomp: IIntPtr;
		procedure _SetFld_lptcomp(Value: IIntPtr);
		function _GetFld_lpvardesc: IIntPtr;
		procedure _SetFld_lpvardesc(Value: IIntPtr);
	{ public }
		property lpfuncdesc: IIntPtr read _GetFld_lpfuncdesc write _SetFld_lpfuncdesc;
		property lptcomp: IIntPtr read _GetFld_lptcomp write _SetFld_lptcomp;
		property lpvardesc: IIntPtr read _GetFld_lpvardesc write _SetFld_lpvardesc;
	end;

	IBitConverterClass = interface(ICoreClrClass)
	['{814B0ABC-2D7F-4425-ACD7-EC2282836BD1}']
	{ private }
		{ class } function _GetFld_IsLittleEndian: Boolean;
	{ public }
		{ class } function DoubleToInt64Bits(value: Double): Int64;
		{ class } function GetBytes(value: Boolean): TArray<Byte>; overload;
		{ class } function GetBytes(value: Char): TArray<Byte>; overload;
		{ class } function GetBytes(value: SmallInt): TArray<Byte>; overload;
		{ class } function GetBytes(value: Integer): TArray<Byte>; overload;
		{ class } function GetBytes(value: Int64): TArray<Byte>; overload;
		{ class } function GetBytes(value: Word): TArray<Byte>; overload;
		{ class } function GetBytes(value: longword): TArray<Byte>; overload;
		{ class } function GetBytes(value: UInt64): TArray<Byte>; overload;
		{ class } function GetBytes(value: Single): TArray<Byte>; overload;
		{ class } function GetBytes(value: Double): TArray<Byte>; overload;
		{ class } function Int32BitsToSingle(value: Integer): Single;
		{ class } function Int64BitsToDouble(value: Int64): Double;
		{ class } function SingleToInt32Bits(value: Single): Integer;
		{ class } function ToBoolean(value: TArray<Byte>; startIndex: Integer): Boolean; overload;
		{ class } function ToBoolean(value: IReadOnlySpan<Byte>): Boolean; overload;
		{ class } function ToChar(value: TArray<Byte>; startIndex: Integer): Char; overload;
		{ class } function ToChar(value: IReadOnlySpan<Byte>): Char; overload;
		{ class } function ToDouble(value: TArray<Byte>; startIndex: Integer): Double; overload;
		{ class } function ToDouble(value: IReadOnlySpan<Byte>): Double; overload;
		{ class } function ToInt16(value: TArray<Byte>; startIndex: Integer): SmallInt; overload;
		{ class } function ToInt16(value: IReadOnlySpan<Byte>): SmallInt; overload;
		{ class } function ToInt32(value: TArray<Byte>; startIndex: Integer): Integer; overload;
		{ class } function ToInt32(value: IReadOnlySpan<Byte>): Integer; overload;
		{ class } function ToInt64(value: TArray<Byte>; startIndex: Integer): Int64; overload;
		{ class } function ToInt64(value: IReadOnlySpan<Byte>): Int64; overload;
		{ class } function ToSingle(value: TArray<Byte>; startIndex: Integer): Single; overload;
		{ class } function ToSingle(value: IReadOnlySpan<Byte>): Single; overload;
		{ class } function ToString(value: TArray<Byte>; startIndex: Integer; length: Integer): String; overload;
		{ class } function ToString(value: TArray<Byte>): String; overload;
		{ class } function ToString(value: TArray<Byte>; startIndex: Integer): String; overload;
		{ class } function ToUInt16(value: TArray<Byte>; startIndex: Integer): Word; overload;
		{ class } function ToUInt16(value: IReadOnlySpan<Byte>): Word; overload;
		{ class } function ToUInt32(value: TArray<Byte>; startIndex: Integer): longword; overload;
		{ class } function ToUInt32(value: IReadOnlySpan<Byte>): longword; overload;
		{ class } function ToUInt64(value: TArray<Byte>; startIndex: Integer): UInt64; overload;
		{ class } function ToUInt64(value: IReadOnlySpan<Byte>): UInt64; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Boolean): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Char): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: SmallInt): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Integer): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Int64): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Word): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: longword): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: UInt64): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Single): Boolean; overload;
		{ class } function TryWriteBytes(destination: ISpan<Byte>; value: Double): Boolean; overload;
		{ class } property IsLittleEndian: Boolean read _GetFld_IsLittleEndian;
	end;

	[CoreTypeSignature(SYSTEM_BITCONVERTER)]
	IBitConverter = interface(IObject)
	['{81EC74CD-6D36-4A4F-9821-F4C3C021B17C}']
	end;

	IBitOperationsClass = interface(ICoreClrClass)
	['{0141FDFA-C26D-4B9A-8D0D-DD306C34145F}']
	{ public }
		{ class } function LeadingZeroCount(value: longword): Integer; overload;
		{ class } function LeadingZeroCount(value: UInt64): Integer; overload;
		{ class } function Log2(value: longword): Integer; overload;
		{ class } function Log2(value: UInt64): Integer; overload;
		{ class } function PopCount(value: longword): Integer; overload;
		{ class } function PopCount(value: UInt64): Integer; overload;
		{ class } function RotateLeft(value: longword; offset: Integer): longword; overload;
		{ class } function RotateLeft(value: UInt64; offset: Integer): UInt64; overload;
		{ class } function RotateRight(value: longword; offset: Integer): longword; overload;
		{ class } function RotateRight(value: UInt64; offset: Integer): UInt64; overload;
		{ class } function TrailingZeroCount(value: Integer): Integer; overload;
		{ class } function TrailingZeroCount(value: longword): Integer; overload;
		{ class } function TrailingZeroCount(value: Int64): Integer; overload;
		{ class } function TrailingZeroCount(value: UInt64): Integer; overload;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_BITOPERATIONS)]
	IBitOperations = interface(IObject)
	['{2220CF99-C099-46D6-B177-013DBCBFB285}']
	end;

	IBmi1Class = interface(ICoreClrClass)
	['{441DF014-648B-4A23-9FC5-FF9FBAD6664B}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function AndNot(left: longword; right: longword): longword;
		{ class } function BitFieldExtract(value: longword; start: Byte; length: Byte): longword; overload;
		{ class } function BitFieldExtract(value: longword; control: Word): longword; overload;
		{ class } function ExtractLowestSetBit(value: longword): longword;
		{ class } function GetMaskUpToLowestSetBit(value: longword): longword;
		{ class } function ResetLowestSetBit(value: longword): longword;
		{ class } function TrailingZeroCount(value: longword): longword;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_BMI1)]
	IBmi1 = interface(IX86Base)
	['{49E7B441-0D0F-4CC3-8E9C-6BC269EF8D83}']
	end;

	IX64_3Class = interface(ICoreClrClass)
	['{2D78351F-5D8A-4D13-B4FA-F821CFB37B14}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function AndNot(left: UInt64; right: UInt64): UInt64;
		{ class } function BitFieldExtract(value: UInt64; start: Byte; length: Byte): UInt64; overload;
		{ class } function BitFieldExtract(value: UInt64; control: Word): UInt64; overload;
		{ class } function ExtractLowestSetBit(value: UInt64): UInt64;
		{ class } function GetMaskUpToLowestSetBit(value: UInt64): UInt64;
		{ class } function ResetLowestSetBit(value: UInt64): UInt64;
		{ class } function TrailingZeroCount(value: UInt64): UInt64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_4)]
	IX64_3 = interface(IX64_15)
	['{B71AAAAA-DF58-4A17-BDF3-6082B8750C1B}']
	end;

	IBmi2Class = interface(ICoreClrClass)
	['{43224CC7-EA8D-4DF3-A38B-DB28D4AFD3AB}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function MultiplyNoFlags(left: longword; right: longword): longword; overload;
		{ class } function MultiplyNoFlags(left: longword; right: longword; low: ICoreClrInstance): longword; overload;
		{ class } function ParallelBitDeposit(value: longword; mask: longword): longword;
		{ class } function ParallelBitExtract(value: longword; mask: longword): longword;
		{ class } function ZeroHighBits(value: longword; index: longword): longword;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_BMI2)]
	IBmi2 = interface(IX86Base)
	['{81589884-34C8-4FE6-BBAC-8DC289EE429F}']
	end;

	IX64_4Class = interface(ICoreClrClass)
	['{6D0A732F-FE99-4076-89C7-1BEF48A53BFC}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function MultiplyNoFlags(left: UInt64; right: UInt64): UInt64; overload;
		{ class } function MultiplyNoFlags(left: UInt64; right: UInt64; low: ICoreClrInstance): UInt64; overload;
		{ class } function ParallelBitDeposit(value: UInt64; mask: UInt64): UInt64;
		{ class } function ParallelBitExtract(value: UInt64; mask: UInt64): UInt64;
		{ class } function ZeroHighBits(value: UInt64; index: UInt64): UInt64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_5)]
	IX64_4 = interface(IX64_15)
	['{6DF6C99B-5258-4687-A2EE-0BDA6547557F}']
	end;

	IBooleanClass = interface(ICoreClrClass)
	['{A0D7BE71-5474-4CA9-AF1E-5EDC9BDC0929}']
	{ private }
		{ class } function _GetFld_FalseString: String;
		{ class } function _GetFld_TrueString: String;
	{ public }
		{ class } function Parse(value: String): Boolean; overload;
		{ class } function Parse(value: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function TryParse(value: String; var result_: Boolean): Boolean; overload;
		{ class } function TryParse(value: IReadOnlySpan<Char>; var result_: Boolean): Boolean; overload;
		{ class } property FalseString: String read _GetFld_FalseString;
		{ class } property TrueString: String read _GetFld_TrueString;
	end;

	[CoreTypeSignature(SYSTEM_BOOLEAN_)]
	IBoolean = interface(IValueType)
	['{78421979-DDCB-42E0-838E-3668143EBCA6}']
	{ public }
		function CompareTo(obj: Variant): Integer; overload;
		function CompareTo(value: Boolean): Integer; overload;
		function Equals(obj: Boolean): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_BSTRWRAPPER)]
	IBStrWrapper = interface(IObject)
	['{6DF49528-3A72-44EC-A32E-A810A2A93F73}']
	{ private }
		function _GetProp_WrappedObject: String;
	{ public }
		property WrappedObject: String read _GetProp_WrappedObject;
	end;

	IBufferClass = interface(ICoreClrClass)
	['{576ECAF7-2F0C-4BBE-AC4D-95123E3BE4E1}']
	{ public }
		{ class } procedure BlockCopy(src: IArray; srcOffset: Integer; dst: IArray; dstOffset: Integer; count: Integer);
		{ class } function ByteLength(array_: IArray): Integer;
		{ class } function GetByte(array_: IArray; index: Integer): Byte;
		{ class } procedure MemoryCopy(source: ICoreClrInstance; destination: ICoreClrInstance; destinationSizeInBytes: Int64; sourceBytesToCopy: Int64); overload;
		{ class } procedure MemoryCopy(source: ICoreClrInstance; destination: ICoreClrInstance; destinationSizeInBytes: UInt64; sourceBytesToCopy: UInt64); overload;
		{ class } procedure SetByte(array_: IArray; index: Integer; value: Byte);
	end;

	[CoreTypeSignature(SYSTEM_BUFFER)]
	IBuffer = interface(IObject)
	['{ADF98B1B-5CB3-447A-8B37-B2D0494407A3}']
	end;

	IStreamClass = interface(ICoreClrClass)
	['{C89079EB-7488-4F4C-B390-6C0AA152897C}']
	{ private }
		{ class } function _GetFld_Null: IStream;
	{ public }
		{ class } function Synchronized(stream: IStream): IStream;
		{ class } property Null: IStream read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_STREAM)]
	IStream = interface(IMarshalByRefObject)
	['{F7098398-7442-4E44-AF99-030F036AFF83}']
	{ private }
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanSeek: Boolean;
		function _GetProp_CanTimeout: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Length: Int64;
		function _GetProp_Position: Int64;
		procedure _SetProp_Position(Value: Int64);
		function _GetProp_ReadTimeout: Integer;
		procedure _SetProp_ReadTimeout(Value: Integer);
		function _GetProp_WriteTimeout: Integer;
		procedure _SetProp_WriteTimeout(Value: Integer);
	{ public }
		function BeginRead(buffer: TArray<Byte>; offset: Integer; count: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		function BeginWrite(buffer: TArray<Byte>; offset: Integer; count: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		procedure Close();
		procedure CopyTo(destination: IStream); overload;
		procedure CopyTo(destination: IStream; bufferSize: Integer); overload;
		function CopyToAsync(destination: IStream): ITask; overload;
		function CopyToAsync(destination: IStream; bufferSize: Integer): ITask; overload;
		function CopyToAsync(destination: IStream; cancellationToken: ICancellationToken): ITask; overload;
		function CopyToAsync(destination: IStream; bufferSize: Integer; cancellationToken: ICancellationToken): ITask; overload;
		procedure Dispose();
		function DisposeAsync(): IValueTask;
		function EndRead(asyncResult: IIAsyncResult): Integer;
		procedure EndWrite(asyncResult: IIAsyncResult);
		procedure Flush();
		function FlushAsync(): ITask; overload;
		function FlushAsync(cancellationToken: ICancellationToken): ITask; overload;
		function Read(buffer: TArray<Byte>; offset: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Byte>): Integer; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer): ITask<Integer>; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Byte>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadByte(): Integer;
		function Seek(offset: Int64; origin: TSeekOrigin): Int64;
		procedure SetLength(value: Int64);
		procedure Write(buffer: TArray<Byte>; offset: Integer; count: Integer); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer): ITask; overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Byte>; cancellationToken: ICancellationToken): IValueTask; overload;
		procedure WriteByte(value: Byte);
		property CanRead: Boolean read _GetProp_CanRead;
		property CanSeek: Boolean read _GetProp_CanSeek;
		property CanTimeout: Boolean read _GetProp_CanTimeout;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Length: Int64 read _GetProp_Length;
		property Position: Int64 read _GetProp_Position write _SetProp_Position;
		property ReadTimeout: Integer read _GetProp_ReadTimeout write _SetProp_ReadTimeout;
		property WriteTimeout: Integer read _GetProp_WriteTimeout write _SetProp_WriteTimeout;
	end;

	[CoreTypeSignature(SYSTEM_IO_BUFFEREDSTREAM)]
	IBufferedStream = interface(IStream)
	['{5B0B1C70-4D13-44F0-92BB-39B418D09C64}']
	{ private }
		function _GetProp_BufferSize: Integer;
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanSeek: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Length: Int64;
		function _GetProp_Position: Int64;
		procedure _SetProp_Position(Value: Int64);
		function _GetProp_UnderlyingStream: IStream;
	{ public }
		function BeginRead(buffer: TArray<Byte>; offset: Integer; count: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		function BeginWrite(buffer: TArray<Byte>; offset: Integer; count: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		procedure CopyTo(destination: IStream; bufferSize: Integer);
		function CopyToAsync(destination: IStream; bufferSize: Integer; cancellationToken: ICancellationToken): ITask;
		function DisposeAsync(): IValueTask;
		function EndRead(asyncResult: IIAsyncResult): Integer;
		procedure EndWrite(asyncResult: IIAsyncResult);
		procedure Flush();
		function FlushAsync(cancellationToken: ICancellationToken): ITask;
		function Read(array_: TArray<Byte>; offset: Integer; count: Integer): Integer; overload;
		function Read(destination: ISpan<Byte>): Integer; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Byte>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadByte(): Integer;
		function Seek(offset: Int64; origin: TSeekOrigin): Int64;
		procedure SetLength(value: Int64);
		procedure Write(array_: TArray<Byte>; offset: Integer; count: Integer); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Byte>; cancellationToken: ICancellationToken): IValueTask; overload;
		procedure WriteByte(value: Byte);
		property BufferSize: Integer read _GetProp_BufferSize;
		property CanRead: Boolean read _GetProp_CanRead;
		property CanSeek: Boolean read _GetProp_CanSeek;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Length: Int64 read _GetProp_Length;
		property Position: Int64 read _GetProp_Position write _SetProp_Position;
		property UnderlyingStream: IStream read _GetProp_UnderlyingStream;
	end;

	IByteClass = interface(ICoreClrClass)
	['{49DAD906-5F13-4E73-8FCE-1CC1A0AD7475}']
	{ private }
		{ class } function _GetFld_MaxValue: Byte;
		{ class } function _GetFld_MinValue: Byte;
	{ public }
		{ class } function Parse(s: String): Byte; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Byte; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Byte; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Byte; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Byte; overload;
		{ class } function TryParse(s: String; var result_: Byte): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Byte): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Byte): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Byte): Boolean; overload;
		{ class } property MaxValue: Byte read _GetFld_MaxValue;
		{ class } property MinValue: Byte read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_BYTE)]
	IByte = interface(IValueType)
	['{CB365E0C-85B9-4C3B-8BD8-1151D9C32ED2}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Byte): Integer; overload;
		function Equals(obj: Byte): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IEqualityComparerClass<T> = interface(ICoreClrClass)
	['{935C28C4-8CDF-4F9F-A341-44F49B6CB9D1}']
	{ private }
		{ class } function _GetProp_Default: IEqualityComparer<T>;
	{ public }
		{ class } property &Default: IEqualityComparer<T> read _GetProp_Default;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_EQUALITYCOMPARER_1)]
	IEqualityComparer<T> = interface(IObject)
	['{618C54FC-187B-4C07-88BE-646332DCEDD1}']
	{ public }
		function Equals(x: T; y: T): Boolean;
		function GetHashCode(obj: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_BYTEEQUALITYCOMPARER)]
	IByteEqualityComparer = interface(IEqualityComparer<Byte>)
	['{0DFF4157-1D69-40D5-95AC-793DAB7E4AFA}']
	{ public }
		function Equals(x: Byte; y: Byte): Boolean;
		function GetHashCode(b: Byte): Integer;
	end;

	ICalendarClass = interface(ICoreClrClass)
	['{859B0D68-5ED0-4DF8-B3B7-1C209CC4ED61}']
	{ private }
		{ class } function _GetFld_CurrentEra: Integer;
	{ public }
		{ class } function &ReadOnly(calendar: ICalendar): ICalendar;
		{ class } property CurrentEra: Integer read _GetFld_CurrentEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_CALENDAR)]
	ICalendar = interface(IICloneable)
	['{A762C5C1-F408-4179-8EE6-F8E3C7A2F7AC}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddDays(time: TDateTime; days: Integer): TDateTime;
		function AddHours(time: TDateTime; hours: Integer): TDateTime;
		function AddMilliseconds(time: TDateTime; milliseconds: Double): TDateTime;
		function AddMinutes(time: TDateTime; minutes: Integer): TDateTime;
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddSeconds(time: TDateTime; seconds: Integer): TDateTime;
		function AddWeeks(time: TDateTime; weeks: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function Clone(): Variant;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer): Integer; overload;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer; overload;
		function GetDaysInYear(year: Integer): Integer; overload;
		function GetDaysInYear(year: Integer; era: Integer): Integer; overload;
		function GetEra(time: TDateTime): Integer;
		function GetHour(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer): Integer; overload;
		function GetLeapMonth(year: Integer; era: Integer): Integer; overload;
		function GetMilliseconds(time: TDateTime): Double;
		function GetMinute(time: TDateTime): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer): Integer; overload;
		function GetMonthsInYear(year: Integer; era: Integer): Integer; overload;
		function GetSecond(time: TDateTime): Integer;
		function GetWeekOfYear(time: TDateTime; rule: TCalendarWeekRule; firstDayOfWeek: TDayOfWeek): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer): Boolean; overload;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean; overload;
		function IsLeapMonth(year: Integer; month: Integer): Boolean; overload;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean; overload;
		function IsLeapYear(year: Integer): Boolean; overload;
		function IsLeapYear(year: Integer; era: Integer): Boolean; overload;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer): TDateTime; overload;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime; overload;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLCONVCDECL)]
	ICallConvCdecl = interface(IObject)
	['{E59787FF-4050-48C6-ACB9-51141FAA843E}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLCONVFASTCALL)]
	ICallConvFastcall = interface(IObject)
	['{4E065DD3-82B4-4F85-990D-7F1CB9CCE41D}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLCONVSTDCALL)]
	ICallConvStdcall = interface(IObject)
	['{A80B1FA3-40A8-4182-95F9-12DD203FE168}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLCONVTHISCALL)]
	ICallConvThiscall = interface(IObject)
	['{69AB5347-DAB9-4029-A48B-8CE8F968124D}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLERARGUMENTEXPRESSIONATTRIBUTE)]
	ICallerArgumentExpressionAttribute = interface(IAttribute)
	['{099EB296-34D0-4A37-92C4-3B5E6522BF1D}']
	{ private }
		function _GetProp_ParameterName: String;
	{ public }
		property ParameterName: String read _GetProp_ParameterName;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLERFILEPATHATTRIBUTE)]
	ICallerFilePathAttribute = interface(IAttribute)
	['{7D1A8792-B7DE-4735-9BB5-09435DC42186}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLERLINENUMBERATTRIBUTE)]
	ICallerLineNumberAttribute = interface(IAttribute)
	['{49ABC167-9259-4FE4-8464-5F7D46CEBDDA}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CALLERMEMBERNAMEATTRIBUTE)]
	ICallerMemberNameAttribute = interface(IAttribute)
	['{C22B6148-9D8D-4C11-91BB-322F16DD0A88}']
	end;

	ICancellationTokenClass = interface(ICoreClrClass)
	['{5FD7A8EB-98CE-4F15-85CE-D8FFA6DDF783}']
	{ private }
		{ class } function _GetProp_None: ICancellationToken;
	{ public }
		{ class } property None: ICancellationToken read _GetProp_None;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_CANCELLATIONTOKEN)]
	ICancellationToken = interface(IValueType)
	['{DD630BD9-CA2F-4015-A091-E13875BBD98D}']
	{ private }
		function _GetProp_CanBeCanceled: Boolean;
		function _GetProp_IsCancellationRequested: Boolean;
		function _GetProp_WaitHandle: IWaitHandle;
	{ public }
		function Equals(other: ICancellationToken): Boolean;
		function &Register(callback: TClrAction): ICancellationTokenRegistration; overload;
		function &Register(callback: TClrAction; useSynchronizationContext: Boolean): ICancellationTokenRegistration; overload;
		function &Register(callback: TClrAction<Variant>; state: Variant): ICancellationTokenRegistration; overload;
		function &Register(callback: TClrAction<Variant>; state: Variant; useSynchronizationContext: Boolean): ICancellationTokenRegistration; overload;
		procedure ThrowIfCancellationRequested();
		function UnsafeRegister(callback: TClrAction<Variant>; state: Variant): ICancellationTokenRegistration;
		property CanBeCanceled: Boolean read _GetProp_CanBeCanceled;
		property IsCancellationRequested: Boolean read _GetProp_IsCancellationRequested;
		property WaitHandle: IWaitHandle read _GetProp_WaitHandle;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_CANCELLATIONTOKENREGISTRATION)]
	ICancellationTokenRegistration = interface(IValueType)
	['{625F707C-95D7-48B4-858D-FF7E78965152}']
	{ private }
		function _GetProp_Token: ICancellationToken;
	{ public }
		procedure Dispose();
		function DisposeAsync(): IValueTask;
		function Equals(other: ICancellationTokenRegistration): Boolean;
		function Unregister(): Boolean;
		property Token: ICancellationToken read _GetProp_Token;
	end;

	ICancellationTokenSourceClass = interface(ICoreClrClass)
	['{F0C9440F-411F-4BED-8C91-443A9A0714D1}']
	{ public }
		{ class } function CreateLinkedTokenSource(token1: ICancellationToken; token2: ICancellationToken): ICancellationTokenSource; overload;
		{ class } function CreateLinkedTokenSource(token: ICancellationToken): ICancellationTokenSource; overload;
		{ class } function CreateLinkedTokenSource(tokens: ICoreClrBridgeArray<ICancellationToken>): ICancellationTokenSource; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_CANCELLATIONTOKENSOURCE)]
	ICancellationTokenSource = interface(IIDisposable)
	['{C929859B-5BEE-4347-A3D4-BA4495C0B4EF}']
	{ private }
		function _GetProp_IsCancellationRequested: Boolean;
		function _GetProp_Token: ICancellationToken;
	{ public }
		procedure Cancel(); overload;
		procedure Cancel(throwOnFirstException: Boolean); overload;
		procedure CancelAfter(delay: ITimeSpan); overload;
		procedure CancelAfter(millisecondsDelay: Integer); overload;
		procedure Dispose();
		property IsCancellationRequested: Boolean read _GetProp_IsCancellationRequested;
		property Token: ICancellationToken read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_CANNOTUNLOADAPPDOMAINEXCEPTION)]
	ICannotUnloadAppDomainException = interface(ISystemException)
	['{A5B57C96-9A56-42D1-92E4-558271B5BEA7}']
	end;

	ICharClass = interface(ICoreClrClass)
	['{88D0E454-6D5A-45BB-95BD-922987D08CCE}']
	{ private }
		{ class } function _GetFld_MaxValue: Char;
		{ class } function _GetFld_MinValue: Char;
	{ public }
		{ class } function ConvertFromUtf32(utf32: Integer): String;
		{ class } function ConvertToUtf32(highSurrogate: Char; lowSurrogate: Char): Integer; overload;
		{ class } function ConvertToUtf32(s: String; index: Integer): Integer; overload;
		{ class } function GetNumericValue(c: Char): Double; overload;
		{ class } function GetNumericValue(s: String; index: Integer): Double; overload;
		{ class } function GetUnicodeCategory(c: Char): TUnicodeCategory; overload;
		{ class } function GetUnicodeCategory(s: String; index: Integer): TUnicodeCategory; overload;
		{ class } function IsControl(s: String; index: Integer): Boolean; overload;
		{ class } function IsControl(c: Char): Boolean; overload;
		{ class } function IsDigit(s: String; index: Integer): Boolean; overload;
		{ class } function IsDigit(c: Char): Boolean; overload;
		{ class } function IsHighSurrogate(c: Char): Boolean; overload;
		{ class } function IsHighSurrogate(s: String; index: Integer): Boolean; overload;
		{ class } function IsLetter(s: String; index: Integer): Boolean; overload;
		{ class } function IsLetter(c: Char): Boolean; overload;
		{ class } function IsLetterOrDigit(s: String; index: Integer): Boolean; overload;
		{ class } function IsLetterOrDigit(c: Char): Boolean; overload;
		{ class } function IsLower(s: String; index: Integer): Boolean; overload;
		{ class } function IsLower(c: Char): Boolean; overload;
		{ class } function IsLowSurrogate(c: Char): Boolean; overload;
		{ class } function IsLowSurrogate(s: String; index: Integer): Boolean; overload;
		{ class } function IsNumber(c: Char): Boolean; overload;
		{ class } function IsNumber(s: String; index: Integer): Boolean; overload;
		{ class } function IsPunctuation(s: String; index: Integer): Boolean; overload;
		{ class } function IsPunctuation(c: Char): Boolean; overload;
		{ class } function IsSeparator(c: Char): Boolean; overload;
		{ class } function IsSeparator(s: String; index: Integer): Boolean; overload;
		{ class } function IsSurrogate(c: Char): Boolean; overload;
		{ class } function IsSurrogate(s: String; index: Integer): Boolean; overload;
		{ class } function IsSurrogatePair(s: String; index: Integer): Boolean; overload;
		{ class } function IsSurrogatePair(highSurrogate: Char; lowSurrogate: Char): Boolean; overload;
		{ class } function IsSymbol(c: Char): Boolean; overload;
		{ class } function IsSymbol(s: String; index: Integer): Boolean; overload;
		{ class } function IsUpper(s: String; index: Integer): Boolean; overload;
		{ class } function IsUpper(c: Char): Boolean; overload;
		{ class } function IsWhiteSpace(s: String; index: Integer): Boolean; overload;
		{ class } function IsWhiteSpace(c: Char): Boolean; overload;
		{ class } function Parse(s: String): Char;
		{ class } function ToLower(c: Char; culture: ICultureInfo): Char; overload;
		{ class } function ToLower(c: Char): Char; overload;
		{ class } function ToLowerInvariant(c: Char): Char;
		{ class } function ToString(c: Char): String;
		{ class } function ToUpper(c: Char; culture: ICultureInfo): Char; overload;
		{ class } function ToUpper(c: Char): Char; overload;
		{ class } function ToUpperInvariant(c: Char): Char;
		{ class } function TryParse(s: String; var result_: Char): Boolean;
		{ class } property MaxValue: Char read _GetFld_MaxValue;
		{ class } property MinValue: Char read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_CHAR_)]
	IChar = interface(IValueType)
	['{F0F6BECE-3A36-401E-AE8C-7FAE4DE0F369}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Char): Integer; overload;
		function Equals(obj: Char): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String;
	end;

	[CoreTypeSignature(SYSTEM_CHARENUMERATOR)]
	ICharEnumerator = interface(IObject)
	['{54296E78-B817-4BAF-9D66-A0008EBCBF57}']
	{ private }
		function _GetProp_Current: Char;
	{ public }
		function Clone(): Variant;
		procedure Dispose();
		function MoveNext(): Boolean;
		procedure Reset();
		property Current: Char read _GetProp_Current;
	end;

	ICharUnicodeInfoClass = interface(ICoreClrClass)
	['{65CF8F80-2339-4466-A040-41060F53AF0A}']
	{ public }
		{ class } function GetDecimalDigitValue(ch: Char): Integer; overload;
		{ class } function GetDecimalDigitValue(s: String; index: Integer): Integer; overload;
		{ class } function GetDigitValue(ch: Char): Integer; overload;
		{ class } function GetDigitValue(s: String; index: Integer): Integer; overload;
		{ class } function GetNumericValue(ch: Char): Double; overload;
		{ class } function GetNumericValue(s: String; index: Integer): Double; overload;
		{ class } function GetUnicodeCategory(ch: Char): TUnicodeCategory; overload;
		{ class } function GetUnicodeCategory(codePoint: Integer): TUnicodeCategory; overload;
		{ class } function GetUnicodeCategory(s: String; index: Integer): TUnicodeCategory; overload;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_CHARUNICODEINFO)]
	ICharUnicodeInfo = interface(IObject)
	['{9949ADCD-839D-44D6-8718-ACB35D345A42}']
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_EASTASIANLUNISOLARCALENDAR)]
	IEastAsianLunisolarCalendar = interface(ICalendar)
	['{2ABF5749-07EC-4A2C-937C-9E2DF19DBA47}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetCelestialStem(sexagenaryYear: Integer): Integer;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetSexagenaryYear(time: TDateTime): Integer;
		function GetTerrestrialBranch(sexagenaryYear: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IChineseLunisolarCalendarClass = interface(ICoreClrClass)
	['{0E41BCD0-D0A2-4C97-8E6F-47A6AC182CF2}']
	{ private }
		{ class } function _GetFld_ChineseEra: Integer;
	{ public }
		{ class } property ChineseEra: Integer read _GetFld_ChineseEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_CHINESELUNISOLARCALENDAR)]
	IChineseLunisolarCalendar = interface(IEastAsianLunisolarCalendar)
	['{D43A1305-A062-4027-A934-08952EDFD0BF}']
	{ private }
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_CHUNKENUMERATOR)]
	IChunkEnumerator = interface(IValueType)
	['{BA222A63-518B-4FDD-B656-0D57CEFFB808}']
	{ private }
		function _GetProp_Current: IReadOnlyMemory<Char>;
	{ public }
		function GetEnumerator(): IChunkEnumerator;
		function MoveNext(): Boolean;
		property Current: IReadOnlyMemory<Char> read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_CLASSINTERFACEATTRIBUTE)]
	IClassInterfaceAttribute = interface(IAttribute)
	['{64F6B0B6-3255-4CC3-9DB7-BE0BF37DE6DD}']
	{ private }
		function _GetProp_Value: TClassInterfaceType;
	{ public }
		property Value: TClassInterfaceType read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_CLSCOMPLIANTATTRIBUTE)]
	ICLSCompliantAttribute = interface(IAttribute)
	['{1976D800-D66F-4688-BFFF-00045FCF5F10}']
	{ private }
		function _GetProp_IsCompliant: Boolean;
	{ public }
		property IsCompliant: Boolean read _GetProp_IsCompliant;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COCLASSATTRIBUTE)]
	ICoClassAttribute = interface(IAttribute)
	['{A1BCEDAC-21DF-41EB-AB52-AF2BB676EA2E}']
	{ private }
		function _GetProp_CoClass: IType;
	{ public }
		property CoClass: IType read _GetProp_CoClass;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PERMISSIONS_SECURITYATTRIBUTE)]
	ISecurityAttribute = interface(IAttribute)
	['{3624AFC4-A627-4167-B120-BA1F5AE47DC1}']
	{ private }
		function _GetProp_Action: TSecurityAction;
		procedure _SetProp_Action(Value: TSecurityAction);
		function _GetProp_Unrestricted: Boolean;
		procedure _SetProp_Unrestricted(Value: Boolean);
	{ public }
		function CreatePermission(): IIPermission;
		property Action: TSecurityAction read _GetProp_Action write _SetProp_Action;
		property Unrestricted: Boolean read _GetProp_Unrestricted write _SetProp_Unrestricted;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PERMISSIONS_CODEACCESSSECURITYATTRIBUTE)]
	ICodeAccessSecurityAttribute = interface(ISecurityAttribute)
	['{D3DEE3A7-2AB8-4B4D-BB74-743278CA7DFD}']
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_OBJECTMODEL_COLLECTION_1)]
	ICollection<T> = interface(IObject)
	['{9650ADBB-9791-488A-93FA-2DB9879C86E9}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_Item(index: Integer): T;
		procedure _SetProp_Item(index: Integer; Value: T);
	{ public }
		procedure Add(item: T);
		procedure Clear();
		function Contains(item: T): Boolean;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; index: Integer);
		function GetEnumerator(): IIEnumerator<T>;
		function IndexOf(item: T): Integer;
		procedure Insert(index: Integer; item: T);
		function Remove(item: T): Boolean;
		procedure RemoveAt(index: Integer);
		property Count: Integer read _GetProp_Count;
		property Item[index: Integer]: T read _GetProp_Item write _SetProp_Item; default;
	end;

	ICollectionsMarshalClass = interface(ICoreClrClass)
	['{C57E6AA0-A1FA-4422-B247-7C7E48EA4DAE}']
	{ public }
		{ class } function AsSpan(T: PTypeInfo; list: IList<Variant{T}>): ISpan<Variant{T}>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COLLECTIONSMARSHAL)]
	ICollectionsMarshal = interface(IObject)
	['{7659863A-7CD2-450A-BF28-1692FF9D0D80}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMDEFAULTINTERFACEATTRIBUTE)]
	IComDefaultInterfaceAttribute = interface(IAttribute)
	['{AF801732-D457-40AA-B47B-159442C5827A}']
	{ private }
		function _GetProp_Value: IType;
	{ public }
		property Value: IType read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMEVENTINTERFACEATTRIBUTE)]
	IComEventInterfaceAttribute = interface(IAttribute)
	['{E9366C05-1D37-40D8-8B08-928DA1F22841}']
	{ private }
		function _GetProp_EventProvider: IType;
		function _GetProp_SourceInterface: IType;
	{ public }
		property EventProvider: IType read _GetProp_EventProvider;
		property SourceInterface: IType read _GetProp_SourceInterface;
	end;

	IComEventsHelperClass = interface(ICoreClrClass)
	['{2213C1E9-60F3-405D-BF98-201D4A27B012}']
	{ public }
		{ class } procedure Combine(rcw: Variant; iid: IGuid; dispid_: Integer; d: IDelegate);
		{ class } function Remove(rcw: Variant; iid: IGuid; dispid_: Integer; d: IDelegate): IDelegate;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMEVENTSHELPER)]
	IComEventsHelper = interface(IObject)
	['{23C08B3D-618C-4519-8946-EF71DDC931EE}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_EXTERNALEXCEPTION)]
	IExternalException = interface(ISystemException)
	['{3FDC545B-76CD-4C3A-A2DF-E961B337530F}']
	{ private }
		function _GetProp_ErrorCode: Integer;
	{ public }
		property ErrorCode: Integer read _GetProp_ErrorCode;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMEXCEPTION)]
	ICOMException = interface(IExternalException)
	['{7AA5A2BA-4062-4175-8842-C835C5B3422E}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMIMPORTATTRIBUTE)]
	IComImportAttribute = interface(IAttribute)
	['{EB2989CA-30F7-41DE-B62F-6DE5D9B84120}']
	end;

	IComInterfaceDispatchClass = interface(ICoreClrClass)
	['{10C2FA5F-75F0-4088-9394-62EC9369AC17}']
	{ public }
		{ class } function GetInstance(T: PTypeInfo; dispatchPtr: ICoreClrInstance): Variant{T};
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMINTERFACEDISPATCH)]
	IComInterfaceDispatch = interface(IValueType)
	['{7A3D00B2-7733-41B4-8822-9BD42C460DF5}']
	{ private }
		function _GetFld_Vtable: IIntPtr;
		procedure _SetFld_Vtable(Value: IIntPtr);
	{ public }
		property Vtable: IIntPtr read _GetFld_Vtable write _SetFld_Vtable;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMINTERFACEENTRY)]
	IComInterfaceEntry = interface(IValueType)
	['{BD719AB2-E9FB-4B08-8E85-29451C225B8C}']
	{ private }
		function _GetFld_IID: IGuid;
		procedure _SetFld_IID(Value: IGuid);
		function _GetFld_Vtable: IIntPtr;
		procedure _SetFld_Vtable(Value: IIntPtr);
	{ public }
		property IID: IGuid read _GetFld_IID write _SetFld_IID;
		property Vtable: IIntPtr read _GetFld_Vtable write _SetFld_Vtable;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_IDESERIALIZATIONCALLBACK)]
	IIDeserializationCallback = interface(IObject)
	['{B8C40F25-3514-4EBB-A8D4-B7AE7DD02420}']
	{ public }
		procedure OnDeserialization(sender: Variant);
	end;

	ICompareInfoClass = interface(ICoreClrClass)
	['{7F3192C7-B3C2-450B-8661-29A36779A140}']
	{ public }
		{ class } function GetCompareInfo(culture: Integer; assembly: IAssembly): ICompareInfo; overload;
		{ class } function GetCompareInfo(name: String; assembly: IAssembly): ICompareInfo; overload;
		{ class } function GetCompareInfo(culture: Integer): ICompareInfo; overload;
		{ class } function GetCompareInfo(name: String): ICompareInfo; overload;
		{ class } function IsSortable(ch: Char): Boolean; overload;
		{ class } function IsSortable(text: String): Boolean; overload;
		{ class } function IsSortable(text: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function IsSortable(value: IRune): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_COMPAREINFO)]
	ICompareInfo = interface(IIDeserializationCallback)
	['{9604821C-6B0E-4D93-AF6D-8E6F92886959}']
	{ private }
		function _GetProp_LCID: Integer;
		function _GetProp_Name: String;
		function _GetProp_Version: ISortVersion;
	{ public }
		function Compare(string1: String; string2: String): Integer; overload;
		function Compare(string1: String; string2: String; options: TCompareOptions_Set): Integer; overload;
		function Compare(string1: IReadOnlySpan<Char>; string2: IReadOnlySpan<Char>; options: TCompareOptions_Set): Integer; overload;
		function Compare(string1: String; offset1: Integer; length1: Integer; string2: String; offset2: Integer; length2: Integer): Integer; overload;
		function Compare(string1: String; offset1: Integer; string2: String; offset2: Integer; options: TCompareOptions_Set): Integer; overload;
		function Compare(string1: String; offset1: Integer; string2: String; offset2: Integer): Integer; overload;
		function Compare(string1: String; offset1: Integer; length1: Integer; string2: String; offset2: Integer; length2: Integer; options: TCompareOptions_Set): Integer; overload;
		function GetHashCode(source: String; options: TCompareOptions_Set): Integer; overload;
		function GetHashCode(source: IReadOnlySpan<Char>; options: TCompareOptions_Set): Integer; overload;
		function GetSortKey(source: String; options: TCompareOptions_Set): ISortKey; overload;
		function GetSortKey(source: String): ISortKey; overload;
		function GetSortKey(source: IReadOnlySpan<Char>; destination: ISpan<Byte>; options: TCompareOptions_Set): Integer; overload;
		function GetSortKeyLength(source: IReadOnlySpan<Char>; options: TCompareOptions_Set): Integer;
		function IndexOf(source: String; value: Char): Integer; overload;
		function IndexOf(source: String; value: String): Integer; overload;
		function IndexOf(source: String; value: Char; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: String; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: Char; startIndex: Integer): Integer; overload;
		function IndexOf(source: String; value: String; startIndex: Integer): Integer; overload;
		function IndexOf(source: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: IReadOnlySpan<Char>; value: IRune; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: Char; startIndex: Integer; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: String; startIndex: Integer; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: Char; startIndex: Integer; count: Integer): Integer; overload;
		function IndexOf(source: String; value: String; startIndex: Integer; count: Integer): Integer; overload;
		function IndexOf(source: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; options: TCompareOptions_Set; var matchLength: Integer): Integer; overload;
		function IndexOf(source: String; value: Char; startIndex: Integer; count: Integer; options: TCompareOptions_Set): Integer; overload;
		function IndexOf(source: String; value: String; startIndex: Integer; count: Integer; options: TCompareOptions_Set): Integer; overload;
		function IsPrefix(source: String; prefix: String; options: TCompareOptions_Set): Boolean; overload;
		function IsPrefix(source: IReadOnlySpan<Char>; prefix: IReadOnlySpan<Char>; options: TCompareOptions_Set): Boolean; overload;
		function IsPrefix(source: IReadOnlySpan<Char>; prefix: IReadOnlySpan<Char>; options: TCompareOptions_Set; var matchLength: Integer): Boolean; overload;
		function IsPrefix(source: String; prefix: String): Boolean; overload;
		function IsSuffix(source: String; suffix: String; options: TCompareOptions_Set): Boolean; overload;
		function IsSuffix(source: IReadOnlySpan<Char>; suffix: IReadOnlySpan<Char>; options: TCompareOptions_Set): Boolean; overload;
		function IsSuffix(source: IReadOnlySpan<Char>; suffix: IReadOnlySpan<Char>; options: TCompareOptions_Set; var matchLength: Integer): Boolean; overload;
		function IsSuffix(source: String; suffix: String): Boolean; overload;
		function LastIndexOf(source: String; value: Char): Integer; overload;
		function LastIndexOf(source: String; value: String): Integer; overload;
		function LastIndexOf(source: String; value: Char; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: String; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: Char; startIndex: Integer): Integer; overload;
		function LastIndexOf(source: String; value: String; startIndex: Integer): Integer; overload;
		function LastIndexOf(source: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: IReadOnlySpan<Char>; value: IRune; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: Char; startIndex: Integer; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: String; startIndex: Integer; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: Char; startIndex: Integer; count: Integer): Integer; overload;
		function LastIndexOf(source: String; value: String; startIndex: Integer; count: Integer): Integer; overload;
		function LastIndexOf(source: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; options: TCompareOptions_Set; var matchLength: Integer): Integer; overload;
		function LastIndexOf(source: String; value: Char; startIndex: Integer; count: Integer; options: TCompareOptions_Set): Integer; overload;
		function LastIndexOf(source: String; value: String; startIndex: Integer; count: Integer; options: TCompareOptions_Set): Integer; overload;
		property LCID: Integer read _GetProp_LCID;
		property Name: String read _GetProp_Name;
		property Version: ISortVersion read _GetProp_Version;
	end;

	IComparerClass = interface(ICoreClrClass)
	['{CF77FDEF-57CC-4221-9631-C207B0DDA1D7}']
	{ private }
		{ class } function _GetFld_Default: IComparer;
		{ class } function _GetFld_DefaultInvariant: IComparer;
	{ public }
		{ class } property &Default: IComparer read _GetFld_Default;
		{ class } property DefaultInvariant: IComparer read _GetFld_DefaultInvariant;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_COMPARER)]
	IComparer = interface(IObject)
	['{64A3A37E-3005-47EC-8BEE-F9D79AA8E9BC}']
	{ public }
		function Compare(a: Variant; b: Variant): Integer;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	IComparerClass<T> = interface(ICoreClrClass)
	['{D794246E-D8B9-4B35-8E13-19083CFA92C7}']
	{ private }
		{ class } function _GetProp_Default: IComparer<T>;
	{ public }
		{ class } function Create(comparison: TComparison<T>): IComparer<T>;
		{ class } property &Default: IComparer<T> read _GetProp_Default;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_COMPARER_1)]
	IComparer<T> = interface(IObject)
	['{FD2CA97F-7FF2-4EEF-BEF6-B2906701E62B}']
	{ public }
		function Compare(x: T; y: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_COMPILATIONRELAXATIONSATTRIBUTE)]
	ICompilationRelaxationsAttribute = interface(IAttribute)
	['{5352ED2D-030B-44DC-8A60-ABC0338B9019}']
	{ private }
		function _GetProp_CompilationRelaxations: Integer;
	{ public }
		property CompilationRelaxations: Integer read _GetProp_CompilationRelaxations;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_COMPILERGENERATEDATTRIBUTE)]
	ICompilerGeneratedAttribute = interface(IAttribute)
	['{63AD5192-05AD-4EFE-B281-A5653E9FEC71}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_COMPILERGLOBALSCOPEATTRIBUTE)]
	ICompilerGlobalScopeAttribute = interface(IAttribute)
	['{584B396E-CB91-495A-9471-2C31356A95D9}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_COMPONENTGUARANTEESATTRIBUTE)]
	IComponentGuaranteesAttribute = interface(IAttribute)
	['{036A991A-E2C3-4959-B9A2-61B46AB3819D}']
	{ private }
		function _GetProp_Guarantees: TComponentGuaranteesOptions_Set;
	{ public }
		property Guarantees: TComponentGuaranteesOptions_Set read _GetProp_Guarantees;
	end;

	ICompressedStackClass = interface(ICoreClrClass)
	['{04242D86-B527-4437-A8BE-8E16B84579FF}']
	{ public }
		{ class } function Capture(): ICompressedStack;
		{ class } function GetCompressedStack(): ICompressedStack;
		{ class } procedure Run(compressedStack: ICompressedStack; callback: TContextCallback; state: Variant);
	end;

	[CoreTypeSignature(SYSTEM_THREADING_COMPRESSEDSTACK)]
	ICompressedStack = interface(IISerializable)
	['{A3B2CC32-85FB-43CA-A259-EE1E616C4315}']
	{ public }
		function CreateCopy(): ICompressedStack;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMSOURCEINTERFACESATTRIBUTE)]
	IComSourceInterfacesAttribute = interface(IAttribute)
	['{02C15CDD-DA78-4501-A457-9398AB10EC75}']
	{ private }
		function _GetProp_Value: String;
	{ public }
		property Value: String read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMVISIBLEATTRIBUTE)]
	IComVisibleAttribute = interface(IAttribute)
	['{1F0AF66F-6787-4DF1-B85C-B27BB8886296}']
	{ private }
		function _GetProp_Value: Boolean;
	{ public }
		property Value: Boolean read _GetProp_Value;
	end;

	IComWrappersClass = interface(ICoreClrClass)
	['{C9BED97B-18BE-4834-BEC8-4997B5188A2E}']
	{ public }
		{ class } procedure RegisterForMarshalling(instance: IComWrappers);
		{ class } procedure RegisterForTrackerSupport(instance: IComWrappers);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMWRAPPERS)]
	IComWrappers = interface(IObject)
	['{35D6E115-5AF8-46A0-ACF4-8D2D55783EFF}']
	{ public }
		function GetOrCreateComInterfaceForObject(instance: Variant; flags: TCreateComInterfaceFlags_Set): IIntPtr;
		function GetOrCreateObjectForComInstance(externalComObject: IIntPtr; flags: TCreateObjectFlags_Set): Variant;
		function GetOrRegisterObjectForComInstance(externalComObject: IIntPtr; flags: TCreateObjectFlags_Set; wrapper: Variant): Variant;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_CONCURRENTEXCLUSIVESCHEDULERPAIR)]
	IConcurrentExclusiveSchedulerPair = interface(IObject)
	['{D476AE8D-FFBC-41B4-9DED-1564CB1A659E}']
	{ private }
		function _GetProp_Completion: ITask;
		function _GetProp_ConcurrentScheduler: ITaskScheduler;
		function _GetProp_ExclusiveScheduler: ITaskScheduler;
	{ public }
		procedure Complete();
		property Completion: ITask read _GetProp_Completion;
		property ConcurrentScheduler: ITaskScheduler read _GetProp_ConcurrentScheduler;
		property ExclusiveScheduler: ITaskScheduler read _GetProp_ExclusiveScheduler;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_CONCURRENT_CONCURRENTQUEUE_1)]
	IConcurrentQueue<T> = interface(IObject)
	['{FB8FC1EF-650B-46E3-A50F-EFC49D03C106}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsEmpty: Boolean;
	{ public }
		procedure Clear();
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; index: Integer);
		procedure Enqueue(item: T);
		function GetEnumerator(): IIEnumerator<T>;
		function ToArray(): TArray<T>;
		function TryDequeue(var result_: T): Boolean;
		function TryPeek(var result_: T): Boolean;
		property Count: Integer read _GetProp_Count;
		property IsEmpty: Boolean read _GetProp_IsEmpty;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONDITIONALATTRIBUTE)]
	IConditionalAttribute = interface(IAttribute)
	['{9CC5CAF5-1A16-45A9-B8F2-32C3AE7C6E7F}']
	{ private }
		function _GetProp_ConditionString: String;
	{ public }
		property ConditionString: String read _GetProp_ConditionString;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONDITIONALWEAKTABLE_2)]
	IConditionalWeakTable<TKey,TValue> = interface(IObject)
	['{6F2FB634-2E2A-494C-B7B1-6C90644A6F14}']
	{ public }
		procedure Add(key: TKey; value: TValue);
		procedure AddOrUpdate(key: TKey; value: TValue);
		procedure Clear();
		function GetOrCreateValue(key: TKey): TValue;
		function GetValue(key: TKey; createValueCallback: TCreateValueCallback<TKey, TValue>): TValue;
		function Remove(key: TKey): Boolean;
		function TryGetValue(key: TKey; var value: TValue): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDASYNCDISPOSABLE)]
	IConfiguredAsyncDisposable = interface(IValueType)
	['{B4727D59-DD03-4E72-B2A0-29FEE0542721}']
	{ public }
		function DisposeAsync(): IConfiguredValueTaskAwaitable;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDCANCELABLEASYNCENUMERABLE_1)]
	IConfiguredCancelableAsyncEnumerable<T> = interface(IValueType)
	['{2A4304B3-559E-44D4-B15F-3114E42C66F9}']
	{ public }
		function ConfigureAwait(continueOnCapturedContext: Boolean): IConfiguredCancelableAsyncEnumerable<T>;
		function GetAsyncEnumerator(): IConfiguredCancelableAsyncEnumerable_Enumerator<T>;
		function WithCancellation(cancellationToken: ICancellationToken): IConfiguredCancelableAsyncEnumerable<T>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ENUMERATOR)]
	IConfiguredCancelableAsyncEnumerable_Enumerator<T> = interface(IValueType)
	['{7B60F051-F5E8-48ED-89B5-979C739A9B7B}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		function DisposeAsync(): IConfiguredValueTaskAwaitable;
		function MoveNextAsync(): IConfiguredValueTaskAwaitable<Boolean>;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITABLE)]
	IConfiguredTaskAwaitable = interface(IValueType)
	['{42C075F0-9240-4756-B426-7874E53EDCB7}']
	{ public }
		function GetAwaiter(): IConfiguredTaskAwaiter;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITER)]
	IConfiguredTaskAwaiter = interface(IValueType)
	['{F04F1E4D-E3C2-46C2-8DA8-D6C980682876}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		procedure GetResult();
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITABLE_1)]
	IConfiguredTaskAwaitable<TResult> = interface(IValueType)
	['{EF4A82BE-84EB-4303-9676-5D92FD53A76A}']
	{ public }
		function GetAwaiter(): IConfiguredTaskAwaitable_ConfiguredTaskAwaiter<TResult>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITER_2)]
	IConfiguredTaskAwaitable_ConfiguredTaskAwaiter<TResult> = interface(IValueType)
	['{AD9304B5-439F-423A-AC1F-0BAF6C604A24}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		function GetResult(): TResult;
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITABLE)]
	IConfiguredValueTaskAwaitable = interface(IValueType)
	['{D6001D8A-21AD-4026-899B-6DE716ECA432}']
	{ public }
		function GetAwaiter(): IConfiguredValueTaskAwaiter;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITER)]
	IConfiguredValueTaskAwaiter = interface(IValueType)
	['{C22C699B-7536-4009-A62C-DBBD2EFAE75F}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		procedure GetResult();
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITABLE_1)]
	IConfiguredValueTaskAwaitable<TResult> = interface(IValueType)
	['{A13D818D-98F2-41C8-8678-20FC161E2C42}']
	{ public }
		function GetAwaiter(): IConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter<TResult>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITER_2)]
	IConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter<TResult> = interface(IValueType)
	['{8F521A85-4A10-494C-8032-529323AE1996}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		function GetResult(): TResult;
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_CONNECTDATA)]
	ICONNECTDATA = interface(IValueType)
	['{EBB81538-1112-4F4A-B601-A789C2B64AB3}']
	{ private }
		function _GetFld_dwCookie: Integer;
		procedure _SetFld_dwCookie(Value: Integer);
		function _GetFld_pUnk: Variant;
		procedure _SetFld_pUnk(Value: Variant);
	{ public }
		property dwCookie: Integer read _GetFld_dwCookie write _SetFld_dwCookie;
		property pUnk: Variant read _GetFld_pUnk write _SetFld_pUnk;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_ICUSTOMATTRIBUTEPROVIDER)]
	IICustomAttributeProvider = interface(IObject)
	['{21CEDD9A-86B7-47A0-8C33-95948979171A}']
	{ public }
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_MEMBERINFO)]
	IMemberInfo = interface(IICustomAttributeProvider)
	['{12854F39-2011-4EEF-91DC-25E94DDAB7B5}']
	{ private }
		function _GetProp_CustomAttributes: IIEnumerable<ICustomAttributeData>;
		function _GetProp_DeclaringType: IType;
		function _GetProp_IsCollectible: Boolean;
		function _GetProp_MemberType: TMemberTypes_Set;
		function _GetProp_MetadataToken: Integer;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_ReflectedType: IType;
	{ public }
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function HasSameMetadataDefinitionAs(other: IMemberInfo): Boolean;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		property CustomAttributes: IIEnumerable<ICustomAttributeData> read _GetProp_CustomAttributes;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property IsCollectible: Boolean read _GetProp_IsCollectible;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
		property MetadataToken: Integer read _GetProp_MetadataToken;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property ReflectedType: IType read _GetProp_ReflectedType;
	end;

	IMethodBaseClass = interface(ICoreClrClass)
	['{9038BF4A-7478-4514-A471-6528BE9A7F29}']
	{ public }
		{ class } function GetCurrentMethod(): IMethodBase;
		{ class } function GetMethodFromHandle(handle: IRuntimeMethodHandle): IMethodBase; overload;
		{ class } function GetMethodFromHandle(handle: IRuntimeMethodHandle; declaringType: IRuntimeTypeHandle): IMethodBase; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_METHODBASE)]
	IMethodBase = interface(IMemberInfo)
	['{8C5AF029-AFC7-46BD-944F-4C533D857046}']
	{ private }
		function _GetProp_Attributes: TMethodAttributes_Set;
		function _GetProp_CallingConvention: TCallingConventions_Set;
		function _GetProp_ContainsGenericParameters: Boolean;
		function _GetProp_IsAbstract: Boolean;
		function _GetProp_IsAssembly: Boolean;
		function _GetProp_IsConstructedGenericMethod: Boolean;
		function _GetProp_IsConstructor: Boolean;
		function _GetProp_IsFamily: Boolean;
		function _GetProp_IsFamilyAndAssembly: Boolean;
		function _GetProp_IsFamilyOrAssembly: Boolean;
		function _GetProp_IsFinal: Boolean;
		function _GetProp_IsGenericMethod: Boolean;
		function _GetProp_IsGenericMethodDefinition: Boolean;
		function _GetProp_IsHideBySig: Boolean;
		function _GetProp_IsPrivate: Boolean;
		function _GetProp_IsPublic: Boolean;
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_IsSpecialName: Boolean;
		function _GetProp_IsStatic: Boolean;
		function _GetProp_IsVirtual: Boolean;
		function _GetProp_MethodHandle: IRuntimeMethodHandle;
		function _GetProp_MethodImplementationFlags: TMethodImplAttributes;
	{ public }
		function GetGenericArguments(): TArray<IType>;
		function GetMethodBody(): IMethodBody;
		function GetMethodImplementationFlags(): TMethodImplAttributes;
		function GetParameters(): TArray<IParameterInfo>;
		function Invoke(obj: Variant; parameters: TArray<Variant>): Variant; overload;
		function Invoke(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		property Attributes: TMethodAttributes_Set read _GetProp_Attributes;
		property CallingConvention: TCallingConventions_Set read _GetProp_CallingConvention;
		property ContainsGenericParameters: Boolean read _GetProp_ContainsGenericParameters;
		property IsAbstract: Boolean read _GetProp_IsAbstract;
		property IsAssembly: Boolean read _GetProp_IsAssembly;
		property IsConstructedGenericMethod: Boolean read _GetProp_IsConstructedGenericMethod;
		property IsConstructor: Boolean read _GetProp_IsConstructor;
		property IsFamily: Boolean read _GetProp_IsFamily;
		property IsFamilyAndAssembly: Boolean read _GetProp_IsFamilyAndAssembly;
		property IsFamilyOrAssembly: Boolean read _GetProp_IsFamilyOrAssembly;
		property IsFinal: Boolean read _GetProp_IsFinal;
		property IsGenericMethod: Boolean read _GetProp_IsGenericMethod;
		property IsGenericMethodDefinition: Boolean read _GetProp_IsGenericMethodDefinition;
		property IsHideBySig: Boolean read _GetProp_IsHideBySig;
		property IsPrivate: Boolean read _GetProp_IsPrivate;
		property IsPublic: Boolean read _GetProp_IsPublic;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property IsSpecialName: Boolean read _GetProp_IsSpecialName;
		property IsStatic: Boolean read _GetProp_IsStatic;
		property IsVirtual: Boolean read _GetProp_IsVirtual;
		property MethodHandle: IRuntimeMethodHandle read _GetProp_MethodHandle;
		property MethodImplementationFlags: TMethodImplAttributes read _GetProp_MethodImplementationFlags;
	end;

	IConstructorInfoClass = interface(ICoreClrClass)
	['{56CD7E56-2E1A-4C58-AB39-20617DE725A0}']
	{ private }
		{ class } function _GetFld_ConstructorName: String;
		{ class } function _GetFld_TypeConstructorName: String;
	{ public }
		{ class } property ConstructorName: String read _GetFld_ConstructorName;
		{ class } property TypeConstructorName: String read _GetFld_TypeConstructorName;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CONSTRUCTORINFO)]
	IConstructorInfo = interface(IMethodBase)
	['{F0AA3B98-0E1C-4FA5-8CD7-497512338C1C}']
	{ private }
		function _GetProp_MemberType: TMemberTypes_Set;
	{ public }
		function Invoke(parameters: TArray<Variant>): Variant; overload;
		function Invoke(invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_CONSTRUCTORBUILDER)]
	IConstructorBuilder = interface(IConstructorInfo)
	['{03CBE013-3885-415C-980C-81D53B345A83}']
	{ private }
		function _GetProp_Attributes: TMethodAttributes_Set;
		function _GetProp_CallingConvention: TCallingConventions_Set;
		function _GetProp_DeclaringType: IType;
		function _GetProp_InitLocals: Boolean;
		procedure _SetProp_InitLocals(Value: Boolean);
		function _GetProp_MethodHandle: IRuntimeMethodHandle;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_Signature: String;
	{ public }
		function DefineParameter(iSequence: Integer; attributes: TParameterAttributes_Set; strParamName: String): IParameterBuilder;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetILGenerator(): IILGenerator; overload;
		function GetILGenerator(streamSize: Integer): IILGenerator; overload;
		function GetMethodImplementationFlags(): TMethodImplAttributes;
		function GetModule(): IModule;
		function GetParameters(): TArray<IParameterInfo>;
		function GetToken(): IMethodToken;
		function Invoke(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		function Invoke(invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetImplementationFlags(attributes: TMethodImplAttributes);
		property Attributes: TMethodAttributes_Set read _GetProp_Attributes;
		property CallingConvention: TCallingConventions_Set read _GetProp_CallingConvention;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property InitLocals: Boolean read _GetProp_InitLocals write _SetProp_InitLocals;
		property MethodHandle: IRuntimeMethodHandle read _GetProp_MethodHandle;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property Signature: String read _GetProp_Signature;
	end;

	[CoreTypeSignature(SYSTEM_CONTEXTBOUNDOBJECT)]
	IContextBoundObject = interface(IMarshalByRefObject)
	['{66520E41-D3BD-40B0-980C-6B5351E9B55E}']
	end;

	[CoreTypeSignature(SYSTEM_CONTEXTMARSHALEXCEPTION)]
	IContextMarshalException = interface(ISystemException)
	['{686E4057-4CDB-442C-8D26-D41066208DD0}']
	end;

	[CoreTypeSignature(SYSTEM_CONTEXTSTATICATTRIBUTE)]
	IContextStaticAttribute = interface(IAttribute)
	['{112F888A-4E1A-4C6B-ADC8-442562076C1F}']
	end;

	IContractClass = interface(ICoreClrClass)
	['{AAD64351-3549-43C0-BD2E-7528E960503A}']
	{ private }
		{ class } function _GetEvt_ContractFailed: TEventHandler<IContractFailedEventArgs>;
		{ class } procedure _SetEvt_ContractFailed(Value: TEventHandler<IContractFailedEventArgs>);
	{ public }
		{ class } procedure Assert(condition: Boolean); overload;
		{ class } procedure Assert(condition: Boolean; userMessage: String); overload;
		{ class } procedure Assume(condition: Boolean); overload;
		{ class } procedure Assume(condition: Boolean; userMessage: String); overload;
		{ class } procedure EndContractBlock();
		{ class } procedure Ensures(condition: Boolean); overload;
		{ class } procedure Ensures(condition: Boolean; userMessage: String); overload;
		{ class } procedure EnsuresOnThrow(TException: PTypeInfo; condition: Boolean); overload;
		{ class } procedure EnsuresOnThrow(TException: PTypeInfo; condition: Boolean; userMessage: String); overload;
		{ class } function Exists(fromInclusive: Integer; toExclusive: Integer; predicate: TClrPredicate<Integer>): Boolean; overload;
		{ class } function Exists(T: PTypeInfo; collection: IIEnumerable<Variant{T}>; predicate: TClrPredicate<Variant{T}>): Boolean; overload;
		{ class } function ForAll(fromInclusive: Integer; toExclusive: Integer; predicate: TClrPredicate<Integer>): Boolean; overload;
		{ class } function ForAll(T: PTypeInfo; collection: IIEnumerable<Variant{T}>; predicate: TClrPredicate<Variant{T}>): Boolean; overload;
		{ class } procedure Invariant(condition: Boolean); overload;
		{ class } procedure Invariant(condition: Boolean; userMessage: String); overload;
		{ class } function OldValue(T: PTypeInfo; value: Variant{T}): Variant{T};
		{ class } procedure &Requires(condition: Boolean); overload;
		{ class } procedure &Requires(condition: Boolean; userMessage: String); overload;
		{ class } function &Result(T: PTypeInfo): Variant{T};

		{ class } function ValueAtReturn(T: PTypeInfo; var value: Variant{T}): Variant{T};
		{ class } property ContractFailed: TEventHandler<IContractFailedEventArgs> read _GetEvt_ContractFailed write _SetEvt_ContractFailed;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACT)]
	IContract = interface(IObject)
	['{9557699F-3542-4D57-9058-9F4E53A2622E}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTABBREVIATORATTRIBUTE)]
	IContractAbbreviatorAttribute = interface(IAttribute)
	['{B64D2686-67DE-4618-9AB6-2180BBC429DA}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTARGUMENTVALIDATORATTRIBUTE)]
	IContractArgumentValidatorAttribute = interface(IAttribute)
	['{62B9CEF0-2E71-4B8C-9A21-9EA27A6A3870}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTCLASSATTRIBUTE)]
	IContractClassAttribute = interface(IAttribute)
	['{16868049-D581-4C0C-939C-413CC99FE9F7}']
	{ private }
		function _GetProp_TypeContainingContracts: IType;
	{ public }
		property TypeContainingContracts: IType read _GetProp_TypeContainingContracts;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTCLASSFORATTRIBUTE)]
	IContractClassForAttribute = interface(IAttribute)
	['{9C8D2B84-979E-4388-AAD8-CB00E488D913}']
	{ private }
		function _GetProp_TypeContractsAreFor: IType;
	{ public }
		property TypeContractsAreFor: IType read _GetProp_TypeContractsAreFor;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTEXCEPTION)]
	IContractException = interface(IException)
	['{E5740D3F-CC0F-40BE-BABF-ADD3005E7F92}']
	{ private }
		function _GetProp_Condition: String;
		function _GetProp_Failure: String;
		function _GetProp_Kind: TContractFailureKind;
		function _GetProp_UserMessage: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Condition: String read _GetProp_Condition;
		property Failure: String read _GetProp_Failure;
		property Kind: TContractFailureKind read _GetProp_Kind;
		property UserMessage: String read _GetProp_UserMessage;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTFAILEDEVENTARGS)]
	IContractFailedEventArgs = interface(IEventArgs)
	['{02449A70-1314-481C-8942-99E3676609B8}']
	{ private }
		function _GetProp_Condition: String;
		function _GetProp_FailureKind: TContractFailureKind;
		function _GetProp_Handled: Boolean;
		function _GetProp_Message: String;
		function _GetProp_OriginalException: IException;
		function _GetProp_Unwind: Boolean;
	{ public }
		procedure SetHandled();
		procedure SetUnwind();
		property Condition: String read _GetProp_Condition;
		property FailureKind: TContractFailureKind read _GetProp_FailureKind;
		property Handled: Boolean read _GetProp_Handled;
		property Message: String read _GetProp_Message;
		property OriginalException: IException read _GetProp_OriginalException;
		property Unwind: Boolean read _GetProp_Unwind;
	end;

	IContractHelperClass = interface(ICoreClrClass)
	['{E24E68E6-7927-414D-B3DA-51E4B0229D44}']
	{ public }
		{ class } function RaiseContractFailedEvent(failureKind: TContractFailureKind; userMessage: String; conditionText: String; innerException: IException): String;
		{ class } procedure TriggerFailure(kind: TContractFailureKind; displayMessage: String; userMessage: String; conditionText: String; innerException: IException);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CONTRACTHELPER)]
	IContractHelper = interface(IObject)
	['{89B0608D-752C-46CA-900C-80F490E82AB3}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTINVARIANTMETHODATTRIBUTE)]
	IContractInvariantMethodAttribute = interface(IAttribute)
	['{5C341F25-0350-4290-B562-2E088CA1AC9B}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTOPTIONATTRIBUTE)]
	IContractOptionAttribute = interface(IAttribute)
	['{9525FCDE-A8E5-479E-9D90-CB9199BE46CA}']
	{ private }
		function _GetProp_Category: String;
		function _GetProp_Enabled: Boolean;
		function _GetProp_Setting: String;
		function _GetProp_Value: String;
	{ public }
		property Category: String read _GetProp_Category;
		property Enabled: Boolean read _GetProp_Enabled;
		property Setting: String read _GetProp_Setting;
		property Value: String read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTPUBLICPROPERTYNAMEATTRIBUTE)]
	IContractPublicPropertyNameAttribute = interface(IAttribute)
	['{8A0CCDFF-7447-4E8F-9ABD-8575BEEC8BF2}']
	{ private }
		function _GetProp_Name: String;
	{ public }
		property Name: String read _GetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTREFERENCEASSEMBLYATTRIBUTE)]
	IContractReferenceAssemblyAttribute = interface(IAttribute)
	['{9673BC7C-BA65-4187-8C24-EF4623B0F268}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTRUNTIMEIGNOREDATTRIBUTE)]
	IContractRuntimeIgnoredAttribute = interface(IAttribute)
	['{F0B1A3DE-20B6-4104-B841-B032DC7E2A59}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_CONTRACTVERIFICATIONATTRIBUTE)]
	IContractVerificationAttribute = interface(IAttribute)
	['{C4A67DC4-B9E7-4DF0-81D6-A2FAF7FABF32}']
	{ private }
		function _GetProp_Value: Boolean;
	{ public }
		property Value: Boolean read _GetProp_Value;
	end;

	IConvertClass = interface(ICoreClrClass)
	['{0ED068C4-20F5-44CF-947A-0192DBC9C427}']
	{ private }
		{ class } function _GetFld_DBNull: Variant;
	{ public }
		{ class } function ChangeType(value: Variant; typeCode: TTypeCode): Variant; overload;
		{ class } function ChangeType(value: Variant; conversionType: IType): Variant; overload;
		{ class } function ChangeType(value: Variant; typeCode: TTypeCode; provider: IIFormatProvider): Variant; overload;
		{ class } function ChangeType(value: Variant; conversionType: IType; provider: IIFormatProvider): Variant; overload;
		{ class } function FromBase64CharArray(inArray: TArray<Char>; offset: Integer; length: Integer): TArray<Byte>;
		{ class } function FromBase64String(s: String): TArray<Byte>;
		{ class } function FromHexString(s: String): TArray<Byte>; overload;
		{ class } function FromHexString(chars: IReadOnlySpan<Char>): TArray<Byte>; overload;
		{ class } function GetTypeCode(value: Variant): TTypeCode;
		{ class } function IsDBNull(value: Variant): Boolean;
		{ class } function ToBase64CharArray(inArray: TArray<Byte>; offsetIn: Integer; length: Integer; outArray: TArray<Char>; offsetOut: Integer): Integer; overload;
		{ class } function ToBase64CharArray(inArray: TArray<Byte>; offsetIn: Integer; length: Integer; outArray: TArray<Char>; offsetOut: Integer; options: TBase64FormattingOptions_Set): Integer; overload;
		{ class } function ToBase64String(inArray: TArray<Byte>): String; overload;
		{ class } function ToBase64String(inArray: TArray<Byte>; options: TBase64FormattingOptions_Set): String; overload;
		{ class } function ToBase64String(bytes: IReadOnlySpan<Byte>; options: TBase64FormattingOptions_Set): String; overload;
		{ class } function ToBase64String(inArray: TArray<Byte>; offset: Integer; length: Integer): String; overload;
		{ class } function ToBase64String(inArray: TArray<Byte>; offset: Integer; length: Integer; options: TBase64FormattingOptions_Set): String; overload;
		{ class } function ToBoolean(value: Variant): Boolean; overload;
		{ class } function ToBoolean(value: Boolean): Boolean; overload;
		{ class } function ToBoolean(value: Shortint): Boolean; overload;
		{ class } function ToBoolean(value: Char): Boolean; overload;
		{ class } function ToBoolean(value: Byte): Boolean; overload;
		{ class } function ToBoolean(value: SmallInt): Boolean; overload;
		{ class } function ToBoolean(value: Word): Boolean; overload;
		{ class } function ToBoolean(value: Integer): Boolean; overload;
		{ class } function ToBoolean(value: longword): Boolean; overload;
		{ class } function ToBoolean(value: Int64): Boolean; overload;
		{ class } function ToBoolean(value: UInt64): Boolean; overload;
		{ class } function ToBoolean(value: String): Boolean; overload;
		{ class } function ToBoolean(value: Single): Boolean; overload;
		{ class } function ToBoolean(value: Double): Boolean; overload;
		{ class } function ToBoolean(value: IDecimal): Boolean; overload;
		{ class } function ToBoolean(value: TDateTime): Boolean; overload;
		{ class } function ToBoolean(value: Variant; provider: IIFormatProvider): Boolean; overload;
		{ class } function ToBoolean(value: String; provider: IIFormatProvider): Boolean; overload;
		{ class } function ToByte(value: String; fromBase: Integer): Byte; overload;
		{ class } function ToByte(value: String; provider: IIFormatProvider): Byte; overload;
		{ class } function ToByte(value: Variant; provider: IIFormatProvider): Byte; overload;
		{ class } function ToByte(value: UInt64): Byte; overload;
		{ class } function ToByte(value: Single): Byte; overload;
		{ class } function ToByte(value: Double): Byte; overload;
		{ class } function ToByte(value: IDecimal): Byte; overload;
		{ class } function ToByte(value: String): Byte; overload;
		{ class } function ToByte(value: TDateTime): Byte; overload;
		{ class } function ToByte(value: Variant): Byte; overload;
		{ class } function ToByte(value: Boolean): Byte; overload;
		{ class } function ToByte(value: Byte): Byte; overload;
		{ class } function ToByte(value: Char): Byte; overload;
		{ class } function ToByte(value: Shortint): Byte; overload;
		{ class } function ToByte(value: SmallInt): Byte; overload;
		{ class } function ToByte(value: Word): Byte; overload;
		{ class } function ToByte(value: Integer): Byte; overload;
		{ class } function ToByte(value: longword): Byte; overload;
		{ class } function ToByte(value: Int64): Byte; overload;
		{ class } function ToChar(value: Variant): Char; overload;
		{ class } function ToChar(value: Boolean): Char; overload;
		{ class } function ToChar(value: Char): Char; overload;
		{ class } function ToChar(value: Shortint): Char; overload;
		{ class } function ToChar(value: Byte): Char; overload;
		{ class } function ToChar(value: SmallInt): Char; overload;
		{ class } function ToChar(value: Word): Char; overload;
		{ class } function ToChar(value: Integer): Char; overload;
		{ class } function ToChar(value: longword): Char; overload;
		{ class } function ToChar(value: Int64): Char; overload;
		{ class } function ToChar(value: UInt64): Char; overload;
		{ class } function ToChar(value: String): Char; overload;
		{ class } function ToChar(value: Single): Char; overload;
		{ class } function ToChar(value: Double): Char; overload;
		{ class } function ToChar(value: IDecimal): Char; overload;
		{ class } function ToChar(value: TDateTime): Char; overload;
		{ class } function ToChar(value: Variant; provider: IIFormatProvider): Char; overload;
		{ class } function ToChar(value: String; provider: IIFormatProvider): Char; overload;
		{ class } function ToDateTime(value: Variant): TDateTime; overload;
		{ class } function ToDateTime(value: String): TDateTime; overload;
		{ class } function ToDateTime(value: Shortint): TDateTime; overload;
		{ class } function ToDateTime(value: Byte): TDateTime; overload;
		{ class } function ToDateTime(value: SmallInt): TDateTime; overload;
		{ class } function ToDateTime(value: Word): TDateTime; overload;
		{ class } function ToDateTime(value: Integer): TDateTime; overload;
		{ class } function ToDateTime(value: longword): TDateTime; overload;
		{ class } function ToDateTime(value: Int64): TDateTime; overload;
		{ class } function ToDateTime(value: UInt64): TDateTime; overload;
		{ class } function ToDateTime(value: Boolean): TDateTime; overload;
		{ class } function ToDateTime(value: Char): TDateTime; overload;
		{ class } function ToDateTime(value: Single): TDateTime; overload;
		{ class } function ToDateTime(value: Double): TDateTime; overload;
		{ class } function ToDateTime(value: IDecimal): TDateTime; overload;
		{ class } function ToDateTime(value: TDateTime): TDateTime; overload;
		{ class } function ToDateTime(value: Variant; provider: IIFormatProvider): TDateTime; overload;
		{ class } function ToDateTime(value: String; provider: IIFormatProvider): TDateTime; overload;
		{ class } function ToDecimal(value: Variant): IDecimal; overload;
		{ class } function ToDecimal(value: Shortint): IDecimal; overload;
		{ class } function ToDecimal(value: Byte): IDecimal; overload;
		{ class } function ToDecimal(value: Char): IDecimal; overload;
		{ class } function ToDecimal(value: SmallInt): IDecimal; overload;
		{ class } function ToDecimal(value: Word): IDecimal; overload;
		{ class } function ToDecimal(value: Integer): IDecimal; overload;
		{ class } function ToDecimal(value: longword): IDecimal; overload;
		{ class } function ToDecimal(value: Int64): IDecimal; overload;
		{ class } function ToDecimal(value: UInt64): IDecimal; overload;
		{ class } function ToDecimal(value: Single): IDecimal; overload;
		{ class } function ToDecimal(value: Double): IDecimal; overload;
		{ class } function ToDecimal(value: String): IDecimal; overload;
		{ class } function ToDecimal(value: IDecimal): IDecimal; overload;
		{ class } function ToDecimal(value: Boolean): IDecimal; overload;
		{ class } function ToDecimal(value: TDateTime): IDecimal; overload;
		{ class } function ToDecimal(value: Variant; provider: IIFormatProvider): IDecimal; overload;
		{ class } function ToDecimal(value: String; provider: IIFormatProvider): IDecimal; overload;
		{ class } function ToDouble(value: Variant): Double; overload;
		{ class } function ToDouble(value: Shortint): Double; overload;
		{ class } function ToDouble(value: Byte): Double; overload;
		{ class } function ToDouble(value: SmallInt): Double; overload;
		{ class } function ToDouble(value: Char): Double; overload;
		{ class } function ToDouble(value: Word): Double; overload;
		{ class } function ToDouble(value: Integer): Double; overload;
		{ class } function ToDouble(value: longword): Double; overload;
		{ class } function ToDouble(value: Int64): Double; overload;
		{ class } function ToDouble(value: UInt64): Double; overload;
		{ class } function ToDouble(value: Single): Double; overload;
		{ class } function ToDouble(value: Double): Double; overload;
		{ class } function ToDouble(value: IDecimal): Double; overload;
		{ class } function ToDouble(value: String): Double; overload;
		{ class } function ToDouble(value: Boolean): Double; overload;
		{ class } function ToDouble(value: TDateTime): Double; overload;
		{ class } function ToDouble(value: Variant; provider: IIFormatProvider): Double; overload;
		{ class } function ToDouble(value: String; provider: IIFormatProvider): Double; overload;
		{ class } function ToHexString(inArray: TArray<Byte>): String; overload;
		{ class } function ToHexString(bytes: IReadOnlySpan<Byte>): String; overload;
		{ class } function ToHexString(inArray: TArray<Byte>; offset: Integer; length: Integer): String; overload;
		{ class } function ToInt16(value: String; fromBase: Integer): SmallInt; overload;
		{ class } function ToInt16(value: Variant; provider: IIFormatProvider): SmallInt; overload;
		{ class } function ToInt16(value: String; provider: IIFormatProvider): SmallInt; overload;
		{ class } function ToInt16(value: Variant): SmallInt; overload;
		{ class } function ToInt16(value: Boolean): SmallInt; overload;
		{ class } function ToInt16(value: Char): SmallInt; overload;
		{ class } function ToInt16(value: Shortint): SmallInt; overload;
		{ class } function ToInt16(value: Byte): SmallInt; overload;
		{ class } function ToInt16(value: Word): SmallInt; overload;
		{ class } function ToInt16(value: Integer): SmallInt; overload;
		{ class } function ToInt16(value: longword): SmallInt; overload;
		{ class } function ToInt16(value: SmallInt): SmallInt; overload;
		{ class } function ToInt16(value: Int64): SmallInt; overload;
		{ class } function ToInt16(value: UInt64): SmallInt; overload;
		{ class } function ToInt16(value: Single): SmallInt; overload;
		{ class } function ToInt16(value: Double): SmallInt; overload;
		{ class } function ToInt16(value: IDecimal): SmallInt; overload;
		{ class } function ToInt16(value: String): SmallInt; overload;
		{ class } function ToInt16(value: TDateTime): SmallInt; overload;
		{ class } function ToInt32(value: String; fromBase: Integer): Integer; overload;
		{ class } function ToInt32(value: Variant; provider: IIFormatProvider): Integer; overload;
		{ class } function ToInt32(value: String; provider: IIFormatProvider): Integer; overload;
		{ class } function ToInt32(value: Variant): Integer; overload;
		{ class } function ToInt32(value: Boolean): Integer; overload;
		{ class } function ToInt32(value: Char): Integer; overload;
		{ class } function ToInt32(value: Shortint): Integer; overload;
		{ class } function ToInt32(value: Byte): Integer; overload;
		{ class } function ToInt32(value: SmallInt): Integer; overload;
		{ class } function ToInt32(value: Word): Integer; overload;
		{ class } function ToInt32(value: longword): Integer; overload;
		{ class } function ToInt32(value: Integer): Integer; overload;
		{ class } function ToInt32(value: Int64): Integer; overload;
		{ class } function ToInt32(value: UInt64): Integer; overload;
		{ class } function ToInt32(value: Single): Integer; overload;
		{ class } function ToInt32(value: Double): Integer; overload;
		{ class } function ToInt32(value: IDecimal): Integer; overload;
		{ class } function ToInt32(value: String): Integer; overload;
		{ class } function ToInt32(value: TDateTime): Integer; overload;
		{ class } function ToInt64(value: String; fromBase: Integer): Int64; overload;
		{ class } function ToInt64(value: String; provider: IIFormatProvider): Int64; overload;
		{ class } function ToInt64(value: Variant; provider: IIFormatProvider): Int64; overload;
		{ class } function ToInt64(value: SmallInt): Int64; overload;
		{ class } function ToInt64(value: Word): Int64; overload;
		{ class } function ToInt64(value: Integer): Int64; overload;
		{ class } function ToInt64(value: longword): Int64; overload;
		{ class } function ToInt64(value: UInt64): Int64; overload;
		{ class } function ToInt64(value: Int64): Int64; overload;
		{ class } function ToInt64(value: Single): Int64; overload;
		{ class } function ToInt64(value: Double): Int64; overload;
		{ class } function ToInt64(value: IDecimal): Int64; overload;
		{ class } function ToInt64(value: String): Int64; overload;
		{ class } function ToInt64(value: TDateTime): Int64; overload;
		{ class } function ToInt64(value: Variant): Int64; overload;
		{ class } function ToInt64(value: Boolean): Int64; overload;
		{ class } function ToInt64(value: Char): Int64; overload;
		{ class } function ToInt64(value: Shortint): Int64; overload;
		{ class } function ToInt64(value: Byte): Int64; overload;
		{ class } function ToSByte(value: String; fromBase: Integer): Shortint; overload;
		{ class } function ToSByte(value: Variant; provider: IIFormatProvider): Shortint; overload;
		{ class } function ToSByte(value: String; provider: IIFormatProvider): Shortint; overload;
		{ class } function ToSByte(value: Variant): Shortint; overload;
		{ class } function ToSByte(value: Boolean): Shortint; overload;
		{ class } function ToSByte(value: Shortint): Shortint; overload;
		{ class } function ToSByte(value: Char): Shortint; overload;
		{ class } function ToSByte(value: Byte): Shortint; overload;
		{ class } function ToSByte(value: SmallInt): Shortint; overload;
		{ class } function ToSByte(value: Word): Shortint; overload;
		{ class } function ToSByte(value: Integer): Shortint; overload;
		{ class } function ToSByte(value: longword): Shortint; overload;
		{ class } function ToSByte(value: Int64): Shortint; overload;
		{ class } function ToSByte(value: UInt64): Shortint; overload;
		{ class } function ToSByte(value: Single): Shortint; overload;
		{ class } function ToSByte(value: Double): Shortint; overload;
		{ class } function ToSByte(value: IDecimal): Shortint; overload;
		{ class } function ToSByte(value: String): Shortint; overload;
		{ class } function ToSByte(value: TDateTime): Shortint; overload;
		{ class } function ToSingle(value: Variant): Single; overload;
		{ class } function ToSingle(value: Shortint): Single; overload;
		{ class } function ToSingle(value: Byte): Single; overload;
		{ class } function ToSingle(value: Char): Single; overload;
		{ class } function ToSingle(value: SmallInt): Single; overload;
		{ class } function ToSingle(value: Word): Single; overload;
		{ class } function ToSingle(value: Integer): Single; overload;
		{ class } function ToSingle(value: longword): Single; overload;
		{ class } function ToSingle(value: Int64): Single; overload;
		{ class } function ToSingle(value: UInt64): Single; overload;
		{ class } function ToSingle(value: Single): Single; overload;
		{ class } function ToSingle(value: Double): Single; overload;
		{ class } function ToSingle(value: IDecimal): Single; overload;
		{ class } function ToSingle(value: String): Single; overload;
		{ class } function ToSingle(value: Boolean): Single; overload;
		{ class } function ToSingle(value: TDateTime): Single; overload;
		{ class } function ToSingle(value: Variant; provider: IIFormatProvider): Single; overload;
		{ class } function ToSingle(value: String; provider: IIFormatProvider): Single; overload;
		{ class } function ToString(value: Variant): String; overload;
		{ class } function ToString(value: Boolean): String; overload;
		{ class } function ToString(value: Char): String; overload;
		{ class } function ToString(value: Shortint): String; overload;
		{ class } function ToString(value: Byte): String; overload;
		{ class } function ToString(value: SmallInt): String; overload;
		{ class } function ToString(value: Word): String; overload;
		{ class } function ToString(value: Integer): String; overload;
		{ class } function ToString(value: longword): String; overload;
		{ class } function ToString(value: Int64): String; overload;
		{ class } function ToString(value: UInt64): String; overload;
		{ class } function ToString(value: Single): String; overload;
		{ class } function ToString(value: Double): String; overload;
		{ class } function ToString(value: IDecimal): String; overload;
		{ class } function ToString(value: TDateTime): String; overload;
		{ class } function ToString(value: String): String; overload;
		{ class } function ToString(value: Variant; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Boolean; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Char; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Shortint; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Byte; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: SmallInt; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Word; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Integer; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: longword; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Int64; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: UInt64; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Single; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Double; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: IDecimal; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: TDateTime; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: String; provider: IIFormatProvider): String; overload;
		{ class } function ToString(value: Byte; toBase: Integer): String; overload;
		{ class } function ToString(value: SmallInt; toBase: Integer): String; overload;
		{ class } function ToString(value: Integer; toBase: Integer): String; overload;
		{ class } function ToString(value: Int64; toBase: Integer): String; overload;
		{ class } function ToUInt16(value: String; fromBase: Integer): Word; overload;
		{ class } function ToUInt16(value: Variant; provider: IIFormatProvider): Word; overload;
		{ class } function ToUInt16(value: String; provider: IIFormatProvider): Word; overload;
		{ class } function ToUInt16(value: Variant): Word; overload;
		{ class } function ToUInt16(value: Boolean): Word; overload;
		{ class } function ToUInt16(value: Char): Word; overload;
		{ class } function ToUInt16(value: Shortint): Word; overload;
		{ class } function ToUInt16(value: Byte): Word; overload;
		{ class } function ToUInt16(value: SmallInt): Word; overload;
		{ class } function ToUInt16(value: Integer): Word; overload;
		{ class } function ToUInt16(value: Word): Word; overload;
		{ class } function ToUInt16(value: longword): Word; overload;
		{ class } function ToUInt16(value: Int64): Word; overload;
		{ class } function ToUInt16(value: UInt64): Word; overload;
		{ class } function ToUInt16(value: Single): Word; overload;
		{ class } function ToUInt16(value: Double): Word; overload;
		{ class } function ToUInt16(value: IDecimal): Word; overload;
		{ class } function ToUInt16(value: String): Word; overload;
		{ class } function ToUInt16(value: TDateTime): Word; overload;
		{ class } function ToUInt32(value: String; fromBase: Integer): longword; overload;
		{ class } function ToUInt32(value: Variant; provider: IIFormatProvider): longword; overload;
		{ class } function ToUInt32(value: String; provider: IIFormatProvider): longword; overload;
		{ class } function ToUInt32(value: Variant): longword; overload;
		{ class } function ToUInt32(value: Boolean): longword; overload;
		{ class } function ToUInt32(value: Char): longword; overload;
		{ class } function ToUInt32(value: Shortint): longword; overload;
		{ class } function ToUInt32(value: Byte): longword; overload;
		{ class } function ToUInt32(value: SmallInt): longword; overload;
		{ class } function ToUInt32(value: Word): longword; overload;
		{ class } function ToUInt32(value: Integer): longword; overload;
		{ class } function ToUInt32(value: longword): longword; overload;
		{ class } function ToUInt32(value: Int64): longword; overload;
		{ class } function ToUInt32(value: UInt64): longword; overload;
		{ class } function ToUInt32(value: Single): longword; overload;
		{ class } function ToUInt32(value: Double): longword; overload;
		{ class } function ToUInt32(value: IDecimal): longword; overload;
		{ class } function ToUInt32(value: String): longword; overload;
		{ class } function ToUInt32(value: TDateTime): longword; overload;
		{ class } function ToUInt64(value: String; fromBase: Integer): UInt64; overload;
		{ class } function ToUInt64(value: Variant; provider: IIFormatProvider): UInt64; overload;
		{ class } function ToUInt64(value: String; provider: IIFormatProvider): UInt64; overload;
		{ class } function ToUInt64(value: Variant): UInt64; overload;
		{ class } function ToUInt64(value: Boolean): UInt64; overload;
		{ class } function ToUInt64(value: Char): UInt64; overload;
		{ class } function ToUInt64(value: Shortint): UInt64; overload;
		{ class } function ToUInt64(value: Byte): UInt64; overload;
		{ class } function ToUInt64(value: SmallInt): UInt64; overload;
		{ class } function ToUInt64(value: Word): UInt64; overload;
		{ class } function ToUInt64(value: Integer): UInt64; overload;
		{ class } function ToUInt64(value: longword): UInt64; overload;
		{ class } function ToUInt64(value: Int64): UInt64; overload;
		{ class } function ToUInt64(value: UInt64): UInt64; overload;
		{ class } function ToUInt64(value: Single): UInt64; overload;
		{ class } function ToUInt64(value: Double): UInt64; overload;
		{ class } function ToUInt64(value: IDecimal): UInt64; overload;
		{ class } function ToUInt64(value: String): UInt64; overload;
		{ class } function ToUInt64(value: TDateTime): UInt64; overload;
		{ class } function TryFromBase64Chars(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>; var bytesWritten: Integer): Boolean;
		{ class } function TryFromBase64String(s: String; bytes: ISpan<Byte>; var bytesWritten: Integer): Boolean;
		{ class } function TryToBase64Chars(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>; var charsWritten: Integer; options: TBase64FormattingOptions_Set): Boolean;
		{ class } property DBNull: Variant read _GetFld_DBNull;
	end;

	[CoreTypeSignature(SYSTEM_CONVERT)]
	IConvert = interface(IObject)
	['{3AA2CAA6-B687-4F8D-A62E-CFF5AF2E2535}']
	end;

	ICrc32Class = interface(ICoreClrClass)
	['{9812BA8B-81A0-448A-84E8-08871C70B192}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function ComputeCrc32(crc: longword; data: Byte): longword; overload;
		{ class } function ComputeCrc32(crc: longword; data: Word): longword; overload;
		{ class } function ComputeCrc32(crc: longword; data: longword): longword; overload;
		{ class } function ComputeCrc32C(crc: longword; data: Byte): longword; overload;
		{ class } function ComputeCrc32C(crc: longword; data: Word): longword; overload;
		{ class } function ComputeCrc32C(crc: longword; data: longword): longword; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_CRC32)]
	ICrc32 = interface(IArmBase)
	['{F3984BEA-6E65-4F5B-8423-AD8D7E4FEDC7}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_CONSTRAINEDEXECUTION_CRITICALFINALIZEROBJECT)]
	ICriticalFinalizerObject = interface(IObject)
	['{F59DABE1-0C37-4F15-9A04-208AC2177BB8}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_CRITICALHANDLE)]
	ICriticalHandle = interface(ICriticalFinalizerObject)
	['{A290E3E2-323A-4023-B3AF-C703B4F46D70}']
	{ private }
		function _GetProp_IsClosed: Boolean;
		function _GetProp_IsInvalid: Boolean;
	{ public }
		procedure Close();
		procedure Dispose();
		procedure SetHandleAsInvalid();
		property IsClosed: Boolean read _GetProp_IsClosed;
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_CRITICALHANDLEMINUSONEISINVALID)]
	ICriticalHandleMinusOneIsInvalid = interface(ICriticalHandle)
	['{90B59A1C-047B-48E0-8775-9F3692C4CE50}']
	{ private }
		function _GetProp_IsInvalid: Boolean;
	{ public }
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_CRITICALHANDLEZEROORMINUSONEISINVALID)]
	ICriticalHandleZeroOrMinusOneIsInvalid = interface(ICriticalHandle)
	['{1A6F1E52-7092-4ADF-A580-164403F0548B}']
	{ private }
		function _GetProp_IsInvalid: Boolean;
	{ public }
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_CRYPTOGRAPHY_CRYPTOGRAPHICEXCEPTION)]
	ICryptographicException = interface(ISystemException)
	['{2B76CD5E-BC67-4107-9651-D12868D8F165}']
	end;

	IStringComparerClass = interface(ICoreClrClass)
	['{AC7B1E47-25F4-4FE2-BC44-A097EFCAC355}']
	{ private }
		{ class } function _GetProp_CurrentCulture: IStringComparer;
		{ class } function _GetProp_CurrentCultureIgnoreCase: IStringComparer;
		{ class } function _GetProp_InvariantCulture: IStringComparer;
		{ class } function _GetProp_InvariantCultureIgnoreCase: IStringComparer;
		{ class } function _GetProp_Ordinal: IStringComparer;
		{ class } function _GetProp_OrdinalIgnoreCase: IStringComparer;
	{ public }
		{ class } function Create(culture: ICultureInfo; ignoreCase: Boolean): IStringComparer; overload;
		{ class } function Create(culture: ICultureInfo; options: TCompareOptions_Set): IStringComparer; overload;
		{ class } function FromComparison(comparisonType: TStringComparison): IStringComparer;
		{ class } property CurrentCulture: IStringComparer read _GetProp_CurrentCulture;
		{ class } property CurrentCultureIgnoreCase: IStringComparer read _GetProp_CurrentCultureIgnoreCase;
		{ class } property InvariantCulture: IStringComparer read _GetProp_InvariantCulture;
		{ class } property InvariantCultureIgnoreCase: IStringComparer read _GetProp_InvariantCultureIgnoreCase;
		{ class } property Ordinal: IStringComparer read _GetProp_Ordinal;
		{ class } property OrdinalIgnoreCase: IStringComparer read _GetProp_OrdinalIgnoreCase;
	end;

	[CoreTypeSignature(SYSTEM_STRINGCOMPARER)]
	IStringComparer = interface(IObject)
	['{50BAEB24-3B92-466D-BCA3-0CC1EBD7DD4C}']
	{ public }
		function Compare(x: Variant; y: Variant): Integer; overload;
		function Compare(x: String; y: String): Integer; overload;
		function Equals(x: Variant; y: Variant): Boolean; overload;
		function Equals(x: String; y: String): Boolean; overload;
		function GetHashCode(obj: Variant): Integer; overload;
		function GetHashCode(obj: String): Integer; overload;
	end;

	[CoreTypeSignature(SYSTEM_CULTUREAWARECOMPARER)]
	ICultureAwareComparer = interface(IStringComparer)
	['{C03897AB-BCA9-4377-ACC5-E2F30D151C7B}']
	{ public }
		function Compare(x: String; y: String): Integer;
		function Equals(x: String; y: String): Boolean;
		function GetHashCode(obj: String): Integer;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	ICultureInfoClass = interface(ICoreClrClass)
	['{B4D6FB89-8195-4840-ABB9-9AEBB5D9D631}']
	{ private }
		{ class } function _GetProp_CurrentCulture: ICultureInfo;
		{ class } procedure _SetProp_CurrentCulture(Value: ICultureInfo);
		{ class } function _GetProp_CurrentUICulture: ICultureInfo;
		{ class } procedure _SetProp_CurrentUICulture(Value: ICultureInfo);
		{ class } function _GetProp_DefaultThreadCurrentCulture: ICultureInfo;
		{ class } procedure _SetProp_DefaultThreadCurrentCulture(Value: ICultureInfo);
		{ class } function _GetProp_DefaultThreadCurrentUICulture: ICultureInfo;
		{ class } procedure _SetProp_DefaultThreadCurrentUICulture(Value: ICultureInfo);
		{ class } function _GetProp_InstalledUICulture: ICultureInfo;
		{ class } function _GetProp_InvariantCulture: ICultureInfo;
	{ public }
		{ class } function CreateSpecificCulture(name: String): ICultureInfo;
		{ class } function GetCultureInfo(culture: Integer): ICultureInfo; overload;
		{ class } function GetCultureInfo(name: String): ICultureInfo; overload;
		{ class } function GetCultureInfo(name: String; altName: String): ICultureInfo; overload;
		{ class } function GetCultureInfo(name: String; predefinedOnly: Boolean): ICultureInfo; overload;
		{ class } function GetCultureInfoByIetfLanguageTag(name: String): ICultureInfo;
		{ class } function GetCultures(types: TCultureTypes_Set): TArray<ICultureInfo>;
		{ class } function &ReadOnly(ci: ICultureInfo): ICultureInfo;
		{ class } property CurrentCulture: ICultureInfo read _GetProp_CurrentCulture write _SetProp_CurrentCulture;
		{ class } property CurrentUICulture: ICultureInfo read _GetProp_CurrentUICulture write _SetProp_CurrentUICulture;
		{ class } property DefaultThreadCurrentCulture: ICultureInfo read _GetProp_DefaultThreadCurrentCulture write _SetProp_DefaultThreadCurrentCulture;
		{ class } property DefaultThreadCurrentUICulture: ICultureInfo read _GetProp_DefaultThreadCurrentUICulture write _SetProp_DefaultThreadCurrentUICulture;
		{ class } property InstalledUICulture: ICultureInfo read _GetProp_InstalledUICulture;
		{ class } property InvariantCulture: ICultureInfo read _GetProp_InvariantCulture;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_CULTUREINFO)]
	ICultureInfo = interface(IObject)
	['{9BD74958-F62D-4709-8C2A-87CE9B1DF9C2}']
	{ private }
		function _GetProp_Calendar: ICalendar;
		function _GetProp_CompareInfo: ICompareInfo;
		function _GetProp_CultureTypes: TCultureTypes_Set;
		function _GetProp_DateTimeFormat: IDateTimeFormatInfo;
		procedure _SetProp_DateTimeFormat(Value: IDateTimeFormatInfo);
		function _GetProp_DisplayName: String;
		function _GetProp_EnglishName: String;
		function _GetProp_IetfLanguageTag: String;
		function _GetProp_IsNeutralCulture: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_KeyboardLayoutId: Integer;
		function _GetProp_LCID: Integer;
		function _GetProp_Name: String;
		function _GetProp_NativeName: String;
		function _GetProp_NumberFormat: INumberFormatInfo;
		procedure _SetProp_NumberFormat(Value: INumberFormatInfo);
		function _GetProp_OptionalCalendars: ICoreClrBridgeArray<ICalendar>;
		function _GetProp_Parent: ICultureInfo;
		function _GetProp_TextInfo: ITextInfo;
		function _GetProp_ThreeLetterISOLanguageName: String;
		function _GetProp_ThreeLetterWindowsLanguageName: String;
		function _GetProp_TwoLetterISOLanguageName: String;
		function _GetProp_UseUserOverride: Boolean;
	{ public }
		procedure ClearCachedData();
		function Clone(): Variant;
		function GetConsoleFallbackUICulture(): ICultureInfo;
		function GetFormat(formatType: IType): Variant;
		property Calendar: ICalendar read _GetProp_Calendar;
		property CompareInfo: ICompareInfo read _GetProp_CompareInfo;
		property CultureTypes: TCultureTypes_Set read _GetProp_CultureTypes;
		property DateTimeFormat: IDateTimeFormatInfo read _GetProp_DateTimeFormat write _SetProp_DateTimeFormat;
		property DisplayName: String read _GetProp_DisplayName;
		property EnglishName: String read _GetProp_EnglishName;
		property IetfLanguageTag: String read _GetProp_IetfLanguageTag;
		property IsNeutralCulture: Boolean read _GetProp_IsNeutralCulture;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property KeyboardLayoutId: Integer read _GetProp_KeyboardLayoutId;
		property LCID: Integer read _GetProp_LCID;
		property Name: String read _GetProp_Name;
		property NativeName: String read _GetProp_NativeName;
		property NumberFormat: INumberFormatInfo read _GetProp_NumberFormat write _SetProp_NumberFormat;
		property OptionalCalendars: ICoreClrBridgeArray<ICalendar> read _GetProp_OptionalCalendars;
		property Parent: ICultureInfo read _GetProp_Parent;
		property TextInfo: ITextInfo read _GetProp_TextInfo;
		property ThreeLetterISOLanguageName: String read _GetProp_ThreeLetterISOLanguageName;
		property ThreeLetterWindowsLanguageName: String read _GetProp_ThreeLetterWindowsLanguageName;
		property TwoLetterISOLanguageName: String read _GetProp_TwoLetterISOLanguageName;
		property UseUserOverride: Boolean read _GetProp_UseUserOverride;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_CULTURENOTFOUNDEXCEPTION)]
	ICultureNotFoundException = interface(IArgumentException)
	['{9C70E1BE-8FC1-43DE-A9AB-CB872FC1577B}']
	{ private }
		function _GetProp_InvalidCultureId: Nullable<Integer>;
		function _GetProp_InvalidCultureName: String;
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property InvalidCultureId: Nullable<Integer> read _GetProp_InvalidCultureId;
		property InvalidCultureName: String read _GetProp_InvalidCultureName;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_CURRENCYWRAPPER)]
	ICurrencyWrapper = interface(IObject)
	['{5F1783D5-EA01-4CF0-AFE7-6B92121218F1}']
	{ private }
		function _GetProp_WrappedObject: IDecimal;
	{ public }
		property WrappedObject: IDecimal read _GetProp_WrappedObject;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_CUSTOMATTRIBUTEBUILDER)]
	ICustomAttributeBuilder = interface(IObject)
	['{E1EAB079-BA83-482B-808E-AF33D82A7DDF}']
	end;

	ICustomAttributeDataClass = interface(ICoreClrClass)
	['{504B6D67-7B6E-4943-ACD1-432A7447CA1C}']
	{ public }
		{ class } function GetCustomAttributes(target: IMemberInfo): IIList<ICustomAttributeData>; overload;
		{ class } function GetCustomAttributes(target: IModule): IIList<ICustomAttributeData>; overload;
		{ class } function GetCustomAttributes(target: IAssembly): IIList<ICustomAttributeData>; overload;
		{ class } function GetCustomAttributes(target: IParameterInfo): IIList<ICustomAttributeData>; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CUSTOMATTRIBUTEDATA)]
	ICustomAttributeData = interface(IObject)
	['{7E3ECB73-FD7E-4329-BE5E-41BA69235817}']
	{ private }
		function _GetProp_AttributeType: IType;
		function _GetProp_Constructor: IConstructorInfo;
		function _GetProp_ConstructorArguments: IIList<ICustomAttributeTypedArgument>;
		function _GetProp_NamedArguments: IIList<ICustomAttributeNamedArgument>;
	{ public }
		property AttributeType: IType read _GetProp_AttributeType;
		property &Constructor: IConstructorInfo read _GetProp_Constructor;
		property ConstructorArguments: IIList<ICustomAttributeTypedArgument> read _GetProp_ConstructorArguments;
		property NamedArguments: IIList<ICustomAttributeNamedArgument> read _GetProp_NamedArguments;
	end;

	ICustomAttributeExtensionsClass = interface(ICoreClrClass)
	['{AFB79640-BDDD-4D70-B8D4-B791DAFEE7B2}']
	{ public }
		{ class } function GetCustomAttribute(element: IAssembly; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IModule; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IMemberInfo; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IParameterInfo; attributeType: IType): IAttribute; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IMemberInfo; inherit: Boolean): Variant{T}; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IParameterInfo; inherit: Boolean): Variant{T}; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IAssembly): Variant{T}; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IModule): Variant{T}; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IMemberInfo): Variant{T}; overload;
		{ class } function GetCustomAttribute(T: PTypeInfo; element: IParameterInfo): Variant{T}; overload;
		{ class } function GetCustomAttribute(element: IMemberInfo; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttribute(element: IParameterInfo; attributeType: IType; inherit: Boolean): IAttribute; overload;
		{ class } function GetCustomAttributes(element: IAssembly): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; inherit: Boolean): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; inherit: Boolean): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IAssembly; attributeType: IType): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IModule; attributeType: IType): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; attributeType: IType): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; attributeType: IType): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IMemberInfo; attributeType: IType; inherit: Boolean): IIEnumerable<IAttribute>; overload;
		{ class } function GetCustomAttributes(element: IParameterInfo; attributeType: IType; inherit: Boolean): IIEnumerable<IAttribute>; overload;
		{ class } function IsDefined(element: IAssembly; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IModule; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IMemberInfo; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IParameterInfo; attributeType: IType): Boolean; overload;
		{ class } function IsDefined(element: IMemberInfo; attributeType: IType; inherit: Boolean): Boolean; overload;
		{ class } function IsDefined(element: IParameterInfo; attributeType: IType; inherit: Boolean): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CUSTOMATTRIBUTEEXTENSIONS)]
	ICustomAttributeExtensions = interface(IObject)
	['{FBD79F6C-85CB-4EF4-BB9C-061A1B82AE15}']
	end;

	[CoreTypeSignature(SYSTEM_FORMATEXCEPTION)]
	IFormatException = interface(ISystemException)
	['{E25C5ED5-AB79-41A3-842C-6EA95E4E82D8}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CUSTOMATTRIBUTEFORMATEXCEPTION)]
	ICustomAttributeFormatException = interface(IFormatException)
	['{2FC3E752-EE0F-4869-9BB3-B3482AD241FC}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CUSTOMATTRIBUTENAMEDARGUMENT)]
	ICustomAttributeNamedArgument = interface(IValueType)
	['{1CD5E22D-98B6-42E5-B233-B1C4353742CA}']
	{ private }
		function _GetProp_IsField: Boolean;
		function _GetProp_MemberInfo: IMemberInfo;
		function _GetProp_MemberName: String;
		function _GetProp_TypedValue: ICustomAttributeTypedArgument;
	{ public }
		property IsField: Boolean read _GetProp_IsField;
		property MemberInfo: IMemberInfo read _GetProp_MemberInfo;
		property MemberName: String read _GetProp_MemberName;
		property TypedValue: ICustomAttributeTypedArgument read _GetProp_TypedValue;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_CUSTOMATTRIBUTETYPEDARGUMENT)]
	ICustomAttributeTypedArgument = interface(IValueType)
	['{97452F36-B4D4-428A-9283-EB47EBBDD7F6}']
	{ private }
		function _GetProp_ArgumentType: IType;
		function _GetProp_Value: Variant;
	{ public }
		property ArgumentType: IType read _GetProp_ArgumentType;
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_CUSTOMCONSTANTATTRIBUTE)]
	ICustomConstantAttribute = interface(IAttribute)
	['{FA481F2D-5565-46BC-986A-FFF86B490950}']
	{ private }
		function _GetProp_Value: Variant;
	{ public }
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_DATAMISALIGNEDEXCEPTION)]
	IDataMisalignedException = interface(ISystemException)
	['{97713C2A-D32B-44DA-ADB7-062B700070DA}']
	end;

	IDateTimeClass = interface(ICoreClrClass)
	['{E0AB8EBF-DAB7-40C7-8401-AF2E53646B74}']
	{ private }
		{ class } function _GetFld_MaxValue: TDateTime;
		{ class } function _GetFld_MinValue: TDateTime;
		{ class } function _GetFld_UnixEpoch: TDateTime;
		{ class } function _GetProp_Now: TDateTime;
		{ class } function _GetProp_Today: TDateTime;
		{ class } function _GetProp_UtcNow: TDateTime;
	{ public }
		{ class } function Compare(t1: TDateTime; t2: TDateTime): Integer;
		{ class } function DaysInMonth(year: Integer; month: Integer): Integer;
		{ class } function Equals(t1: TDateTime; t2: TDateTime): Boolean;
		{ class } function FromBinary(dateData: Int64): TDateTime;
		{ class } function FromFileTime(fileTime: Int64): TDateTime;
		{ class } function FromFileTimeUtc(fileTime: Int64): TDateTime;
		{ class } function FromOADate(d: Double): TDateTime;
		{ class } function IsLeapYear(year: Integer): Boolean;
		{ class } function Parse(s: String): TDateTime; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): TDateTime; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider; styles: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; provider: IIFormatProvider; styles: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function ParseExact(s: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; provider: IIFormatProvider; style: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function ParseExact(s: String; formats: TArray<String>; provider: IIFormatProvider; style: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function ParseExact(s: IReadOnlySpan<Char>; formats: TArray<String>; provider: IIFormatProvider; style: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function ParseExact(s: String; format: String; provider: IIFormatProvider; style: TDateTimeStyles_Set): TDateTime; overload;
		{ class } function ParseExact(s: String; format: String; provider: IIFormatProvider): TDateTime; overload;
		{ class } function SpecifyKind(value: TDateTime; kind: TDateTimeKind): TDateTime;
		{ class } function TryParse(s: String; var result_: TDateTime): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: TDateTime): Boolean; overload;
		{ class } function TryParse(s: String; provider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; provider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } function TryParseExact(s: String; format: String; provider: IIFormatProvider; style: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } function TryParseExact(s: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; provider: IIFormatProvider; style: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } function TryParseExact(s: String; formats: TArray<String>; provider: IIFormatProvider; style: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } function TryParseExact(s: IReadOnlySpan<Char>; formats: TArray<String>; provider: IIFormatProvider; style: TDateTimeStyles_Set; var result_: TDateTime): Boolean; overload;
		{ class } property MaxValue: TDateTime read _GetFld_MaxValue;
		{ class } property MinValue: TDateTime read _GetFld_MinValue;
		{ class } property UnixEpoch: TDateTime read _GetFld_UnixEpoch;
		{ class } property Now: TDateTime read _GetProp_Now;
		{ class } property Today: TDateTime read _GetProp_Today;
		{ class } property UtcNow: TDateTime read _GetProp_UtcNow;
	end;

	[CoreTypeSignature(SYSTEM_DATETIME)]
	IDateTime = interface(IValueType)
	['{2509C4BA-2079-4C20-8AD9-DA5A5016E465}']
	{ private }
		function _GetProp_Date: TDateTime;
		function _GetProp_Day: Integer;
		function _GetProp_DayOfWeek: TDayOfWeek;
		function _GetProp_DayOfYear: Integer;
		function _GetProp_Hour: Integer;
		function _GetProp_Kind: TDateTimeKind;
		function _GetProp_Millisecond: Integer;
		function _GetProp_Minute: Integer;
		function _GetProp_Month: Integer;
		function _GetProp_Second: Integer;
		function _GetProp_Ticks: Int64;
		function _GetProp_TimeOfDay: ITimeSpan;
		function _GetProp_Year: Integer;
	{ public }
		function Add(value: ITimeSpan): TDateTime;
		function AddDays(value: Double): TDateTime;
		function AddHours(value: Double): TDateTime;
		function AddMilliseconds(value: Double): TDateTime;
		function AddMinutes(value: Double): TDateTime;
		function AddMonths(months: Integer): TDateTime;
		function AddSeconds(value: Double): TDateTime;
		function AddTicks(value: Int64): TDateTime;
		function AddYears(value: Integer): TDateTime;
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: TDateTime): Integer; overload;
		function Equals(value: TDateTime): Boolean;
		function GetDateTimeFormats(): TArray<String>; overload;
		function GetDateTimeFormats(provider: IIFormatProvider): TArray<String>; overload;
		function GetDateTimeFormats(format: Char): TArray<String>; overload;
		function GetDateTimeFormats(format: Char; provider: IIFormatProvider): TArray<String>; overload;
		function GetTypeCode(): TTypeCode;
		function IsDaylightSavingTime(): Boolean;
		function Subtract(value: TDateTime): ITimeSpan; overload;
		function Subtract(value: ITimeSpan): TDateTime; overload;
		function ToBinary(): Int64;
		function ToFileTime(): Int64;
		function ToFileTimeUtc(): Int64;
		function ToLocalTime(): TDateTime;
		function ToLongDateString(): String;
		function ToLongTimeString(): String;
		function ToOADate(): Double;
		function ToShortDateString(): String;
		function ToShortTimeString(): String;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function ToUniversalTime(): TDateTime;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
		property Date: TDateTime read _GetProp_Date;
		property Day: Integer read _GetProp_Day;
		property DayOfWeek: TDayOfWeek read _GetProp_DayOfWeek;
		property DayOfYear: Integer read _GetProp_DayOfYear;
		property Hour: Integer read _GetProp_Hour;
		property Kind: TDateTimeKind read _GetProp_Kind;
		property Millisecond: Integer read _GetProp_Millisecond;
		property Minute: Integer read _GetProp_Minute;
		property Month: Integer read _GetProp_Month;
		property Second: Integer read _GetProp_Second;
		property Ticks: Int64 read _GetProp_Ticks;
		property TimeOfDay: ITimeSpan read _GetProp_TimeOfDay;
		property Year: Integer read _GetProp_Year;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DATETIMECONSTANTATTRIBUTE)]
	IDateTimeConstantAttribute = interface(ICustomConstantAttribute)
	['{D7A2B70E-1DC2-4715-8AF7-6B50F534E20D}']
	{ private }
		function _GetProp_Value: Variant;
	{ public }
		property Value: Variant read _GetProp_Value;
	end;

	IDateTimeFormatInfoClass = interface(ICoreClrClass)
	['{D9B0BB92-007B-4A31-AD8C-35B557FC99B9}']
	{ private }
		{ class } function _GetProp_CurrentInfo: IDateTimeFormatInfo;
		{ class } function _GetProp_InvariantInfo: IDateTimeFormatInfo;
	{ public }
		{ class } function GetInstance(provider: IIFormatProvider): IDateTimeFormatInfo;
		{ class } function &ReadOnly(dtfi: IDateTimeFormatInfo): IDateTimeFormatInfo;
		{ class } property CurrentInfo: IDateTimeFormatInfo read _GetProp_CurrentInfo;
		{ class } property InvariantInfo: IDateTimeFormatInfo read _GetProp_InvariantInfo;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_DATETIMEFORMATINFO)]
	IDateTimeFormatInfo = interface(IObject)
	['{CB2595B8-8F0C-4C41-BA32-C316CD1477D2}']
	{ private }
		function _GetProp_AbbreviatedDayNames: TArray<String>;
		procedure _SetProp_AbbreviatedDayNames(Value: TArray<String>);
		function _GetProp_AbbreviatedMonthGenitiveNames: TArray<String>;
		procedure _SetProp_AbbreviatedMonthGenitiveNames(Value: TArray<String>);
		function _GetProp_AbbreviatedMonthNames: TArray<String>;
		procedure _SetProp_AbbreviatedMonthNames(Value: TArray<String>);
		function _GetProp_AMDesignator: String;
		procedure _SetProp_AMDesignator(Value: String);
		function _GetProp_Calendar: ICalendar;
		procedure _SetProp_Calendar(Value: ICalendar);
		function _GetProp_CalendarWeekRule: TCalendarWeekRule;
		procedure _SetProp_CalendarWeekRule(Value: TCalendarWeekRule);
		function _GetProp_DateSeparator: String;
		procedure _SetProp_DateSeparator(Value: String);
		function _GetProp_DayNames: TArray<String>;
		procedure _SetProp_DayNames(Value: TArray<String>);
		function _GetProp_FirstDayOfWeek: TDayOfWeek;
		procedure _SetProp_FirstDayOfWeek(Value: TDayOfWeek);
		function _GetProp_FullDateTimePattern: String;
		procedure _SetProp_FullDateTimePattern(Value: String);
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_LongDatePattern: String;
		procedure _SetProp_LongDatePattern(Value: String);
		function _GetProp_LongTimePattern: String;
		procedure _SetProp_LongTimePattern(Value: String);
		function _GetProp_MonthDayPattern: String;
		procedure _SetProp_MonthDayPattern(Value: String);
		function _GetProp_MonthGenitiveNames: TArray<String>;
		procedure _SetProp_MonthGenitiveNames(Value: TArray<String>);
		function _GetProp_MonthNames: TArray<String>;
		procedure _SetProp_MonthNames(Value: TArray<String>);
		function _GetProp_NativeCalendarName: String;
		function _GetProp_PMDesignator: String;
		procedure _SetProp_PMDesignator(Value: String);
		function _GetProp_RFC1123Pattern: String;
		function _GetProp_ShortDatePattern: String;
		procedure _SetProp_ShortDatePattern(Value: String);
		function _GetProp_ShortestDayNames: TArray<String>;
		procedure _SetProp_ShortestDayNames(Value: TArray<String>);
		function _GetProp_ShortTimePattern: String;
		procedure _SetProp_ShortTimePattern(Value: String);
		function _GetProp_SortableDateTimePattern: String;
		function _GetProp_TimeSeparator: String;
		procedure _SetProp_TimeSeparator(Value: String);
		function _GetProp_UniversalSortableDateTimePattern: String;
		function _GetProp_YearMonthPattern: String;
		procedure _SetProp_YearMonthPattern(Value: String);
	{ public }
		function Clone(): Variant;
		function GetAbbreviatedDayName(dayofweek: TDayOfWeek): String;
		function GetAbbreviatedEraName(era: Integer): String;
		function GetAbbreviatedMonthName(month: Integer): String;
		function GetAllDateTimePatterns(): TArray<String>; overload;
		function GetAllDateTimePatterns(format: Char): TArray<String>; overload;
		function GetDayName(dayofweek: TDayOfWeek): String;
		function GetEra(eraName: String): Integer;
		function GetEraName(era: Integer): String;
		function GetFormat(formatType: IType): Variant;
		function GetMonthName(month: Integer): String;
		function GetShortestDayName(dayOfWeek: TDayOfWeek): String;
		procedure SetAllDateTimePatterns(patterns: TArray<String>; format: Char);
		property AbbreviatedDayNames: TArray<String> read _GetProp_AbbreviatedDayNames write _SetProp_AbbreviatedDayNames;
		property AbbreviatedMonthGenitiveNames: TArray<String> read _GetProp_AbbreviatedMonthGenitiveNames write _SetProp_AbbreviatedMonthGenitiveNames;
		property AbbreviatedMonthNames: TArray<String> read _GetProp_AbbreviatedMonthNames write _SetProp_AbbreviatedMonthNames;
		property AMDesignator: String read _GetProp_AMDesignator write _SetProp_AMDesignator;
		property Calendar: ICalendar read _GetProp_Calendar write _SetProp_Calendar;
		property CalendarWeekRule: TCalendarWeekRule read _GetProp_CalendarWeekRule write _SetProp_CalendarWeekRule;
		property DateSeparator: String read _GetProp_DateSeparator write _SetProp_DateSeparator;
		property DayNames: TArray<String> read _GetProp_DayNames write _SetProp_DayNames;
		property FirstDayOfWeek: TDayOfWeek read _GetProp_FirstDayOfWeek write _SetProp_FirstDayOfWeek;
		property FullDateTimePattern: String read _GetProp_FullDateTimePattern write _SetProp_FullDateTimePattern;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property LongDatePattern: String read _GetProp_LongDatePattern write _SetProp_LongDatePattern;
		property LongTimePattern: String read _GetProp_LongTimePattern write _SetProp_LongTimePattern;
		property MonthDayPattern: String read _GetProp_MonthDayPattern write _SetProp_MonthDayPattern;
		property MonthGenitiveNames: TArray<String> read _GetProp_MonthGenitiveNames write _SetProp_MonthGenitiveNames;
		property MonthNames: TArray<String> read _GetProp_MonthNames write _SetProp_MonthNames;
		property NativeCalendarName: String read _GetProp_NativeCalendarName;
		property PMDesignator: String read _GetProp_PMDesignator write _SetProp_PMDesignator;
		property RFC1123Pattern: String read _GetProp_RFC1123Pattern;
		property ShortDatePattern: String read _GetProp_ShortDatePattern write _SetProp_ShortDatePattern;
		property ShortestDayNames: TArray<String> read _GetProp_ShortestDayNames write _SetProp_ShortestDayNames;
		property ShortTimePattern: String read _GetProp_ShortTimePattern write _SetProp_ShortTimePattern;
		property SortableDateTimePattern: String read _GetProp_SortableDateTimePattern;
		property TimeSeparator: String read _GetProp_TimeSeparator write _SetProp_TimeSeparator;
		property UniversalSortableDateTimePattern: String read _GetProp_UniversalSortableDateTimePattern;
		property YearMonthPattern: String read _GetProp_YearMonthPattern write _SetProp_YearMonthPattern;
	end;

	IDateTimeOffsetClass = interface(ICoreClrClass)
	['{DF837204-B76B-494B-8744-AAEF45EC4690}']
	{ private }
		{ class } function _GetFld_MaxValue: IDateTimeOffset;
		{ class } function _GetFld_MinValue: IDateTimeOffset;
		{ class } function _GetFld_UnixEpoch: IDateTimeOffset;
		{ class } function _GetProp_Now: IDateTimeOffset;
		{ class } function _GetProp_UtcNow: IDateTimeOffset;
	{ public }
		{ class } function Compare(first: IDateTimeOffset; second: IDateTimeOffset): Integer;
		{ class } function Equals(first: IDateTimeOffset; second: IDateTimeOffset): Boolean;
		{ class } function FromFileTime(fileTime: Int64): IDateTimeOffset;
		{ class } function FromUnixTimeMilliseconds(milliseconds: Int64): IDateTimeOffset;
		{ class } function FromUnixTimeSeconds(seconds: Int64): IDateTimeOffset;
		{ class } function Parse(input: String): IDateTimeOffset; overload;
		{ class } function Parse(input: String; formatProvider: IIFormatProvider): IDateTimeOffset; overload;
		{ class } function Parse(input: String; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function Parse(input: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function ParseExact(input: String; format: String; formatProvider: IIFormatProvider): IDateTimeOffset; overload;
		{ class } function ParseExact(input: String; format: String; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function ParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function ParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function ParseExact(input: IReadOnlySpan<Char>; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set): IDateTimeOffset; overload;
		{ class } function TryParse(input: IReadOnlySpan<Char>; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParse(input: String; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParse(input: String; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParse(input: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParseExact(input: String; format: String; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TDateTimeStyles_Set; var result_: IDateTimeOffset): Boolean; overload;
		{ class } property MaxValue: IDateTimeOffset read _GetFld_MaxValue;
		{ class } property MinValue: IDateTimeOffset read _GetFld_MinValue;
		{ class } property UnixEpoch: IDateTimeOffset read _GetFld_UnixEpoch;
		{ class } property Now: IDateTimeOffset read _GetProp_Now;
		{ class } property UtcNow: IDateTimeOffset read _GetProp_UtcNow;
	end;

	[CoreTypeSignature(SYSTEM_DATETIMEOFFSET)]
	IDateTimeOffset = interface(IValueType)
	['{2CEB5EB7-F776-4AE4-957B-B44BF26513D0}']
	{ private }
		function _GetProp_Date: TDateTime;
		function _GetProp_DateTime: TDateTime;
		function _GetProp_Day: Integer;
		function _GetProp_DayOfWeek: TDayOfWeek;
		function _GetProp_DayOfYear: Integer;
		function _GetProp_Hour: Integer;
		function _GetProp_LocalDateTime: TDateTime;
		function _GetProp_Millisecond: Integer;
		function _GetProp_Minute: Integer;
		function _GetProp_Month: Integer;
		function _GetProp_Offset: ITimeSpan;
		function _GetProp_Second: Integer;
		function _GetProp_Ticks: Int64;
		function _GetProp_TimeOfDay: ITimeSpan;
		function _GetProp_UtcDateTime: TDateTime;
		function _GetProp_UtcTicks: Int64;
		function _GetProp_Year: Integer;
	{ public }
		function Add(timeSpan: ITimeSpan): IDateTimeOffset;
		function AddDays(days: Double): IDateTimeOffset;
		function AddHours(hours: Double): IDateTimeOffset;
		function AddMilliseconds(milliseconds: Double): IDateTimeOffset;
		function AddMinutes(minutes: Double): IDateTimeOffset;
		function AddMonths(months: Integer): IDateTimeOffset;
		function AddSeconds(seconds: Double): IDateTimeOffset;
		function AddTicks(ticks: Int64): IDateTimeOffset;
		function AddYears(years: Integer): IDateTimeOffset;
		function CompareTo(other: IDateTimeOffset): Integer;
		function Equals(other: IDateTimeOffset): Boolean;
		function EqualsExact(other: IDateTimeOffset): Boolean;
		function Subtract(value: IDateTimeOffset): ITimeSpan; overload;
		function Subtract(value: ITimeSpan): IDateTimeOffset; overload;
		function ToFileTime(): Int64;
		function ToLocalTime(): IDateTimeOffset;
		function ToOffset(offset: ITimeSpan): IDateTimeOffset;
		function ToString(format: String): String; overload;
		function ToString(formatProvider: IIFormatProvider): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		function ToUniversalTime(): IDateTimeOffset;
		function ToUnixTimeMilliseconds(): Int64;
		function ToUnixTimeSeconds(): Int64;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider): Boolean;
		property Date: TDateTime read _GetProp_Date;
		property DateTime: TDateTime read _GetProp_DateTime;
		property Day: Integer read _GetProp_Day;
		property DayOfWeek: TDayOfWeek read _GetProp_DayOfWeek;
		property DayOfYear: Integer read _GetProp_DayOfYear;
		property Hour: Integer read _GetProp_Hour;
		property LocalDateTime: TDateTime read _GetProp_LocalDateTime;
		property Millisecond: Integer read _GetProp_Millisecond;
		property Minute: Integer read _GetProp_Minute;
		property Month: Integer read _GetProp_Month;
		property Offset: ITimeSpan read _GetProp_Offset;
		property Second: Integer read _GetProp_Second;
		property Ticks: Int64 read _GetProp_Ticks;
		property TimeOfDay: ITimeSpan read _GetProp_TimeOfDay;
		property UtcDateTime: TDateTime read _GetProp_UtcDateTime;
		property UtcTicks: Int64 read _GetProp_UtcTicks;
		property Year: Integer read _GetProp_Year;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_DAYLIGHTTIME)]
	IDaylightTime = interface(IObject)
	['{45656DCE-B9A6-4782-9A54-DA37F4BD3B58}']
	{ private }
		function _GetProp_Delta: ITimeSpan;
		function _GetProp_End: TDateTime;
		function _GetProp_Start: TDateTime;
	{ public }
		property Delta: ITimeSpan read _GetProp_Delta;
		property &End: TDateTime read _GetProp_End;
		property Start: TDateTime read _GetProp_Start;
	end;

	IDBNullClass = interface(ICoreClrClass)
	['{B7883E4C-DDC6-401F-BC74-A038B595DF42}']
	{ private }
		{ class } function _GetFld_Value: IDBNull;
	{ public }
		{ class } property Value: IDBNull read _GetFld_Value;
	end;

	[CoreTypeSignature(SYSTEM_DBNULL)]
	IDBNull = interface(IObject)
	['{7BCA42AC-C559-4739-BEE7-60FFFC06691C}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String;
	end;

	IDebugClass = interface(ICoreClrClass)
	['{E086437D-6199-4413-8670-71AFCD51A61E}']
	{ private }
		{ class } function _GetProp_AutoFlush: Boolean;
		{ class } procedure _SetProp_AutoFlush(Value: Boolean);
		{ class } function _GetProp_IndentLevel: Integer;
		{ class } procedure _SetProp_IndentLevel(Value: Integer);
		{ class } function _GetProp_IndentSize: Integer;
		{ class } procedure _SetProp_IndentSize(Value: Integer);
	{ public }
		{ class } procedure Assert(condition: Boolean); overload;
		{ class } procedure Assert(condition: Boolean; message: String); overload;
		{ class } procedure Assert(condition: Boolean; message: String; detailMessage: String); overload;
		{ class } procedure Assert(condition: Boolean; message: String; detailMessageFormat: String; args: TArray<Variant>); overload;
		{ class } procedure Close();
		{ class } procedure Fail(message: String); overload;
		{ class } procedure Fail(message: String; detailMessage: String); overload;
		{ class } procedure Flush();
		{ class } procedure Indent();
		{ class } procedure Print(message: String); overload;
		{ class } procedure Print(format: String; args: TArray<Variant>); overload;
		{ class } function SetProvider(provider: IDebugProvider): IDebugProvider;
		{ class } procedure Unindent();
		{ class } procedure Write(message: String); overload;
		{ class } procedure Write(value: Variant); overload;
		{ class } procedure Write(message: String; category: String); overload;
		{ class } procedure Write(value: Variant; category: String); overload;
		{ class } procedure WriteIf(condition: Boolean; message: String); overload;
		{ class } procedure WriteIf(condition: Boolean; value: Variant); overload;
		{ class } procedure WriteIf(condition: Boolean; message: String; category: String); overload;
		{ class } procedure WriteIf(condition: Boolean; value: Variant; category: String); overload;
		{ class } procedure WriteLine(message: String); overload;
		{ class } procedure WriteLine(value: Variant); overload;
		{ class } procedure WriteLine(value: Variant; category: String); overload;
		{ class } procedure WriteLine(format: String; args: TArray<Variant>); overload;
		{ class } procedure WriteLine(message: String; category: String); overload;
		{ class } procedure WriteLineIf(condition: Boolean; value: Variant); overload;
		{ class } procedure WriteLineIf(condition: Boolean; message: String); overload;
		{ class } procedure WriteLineIf(condition: Boolean; value: Variant; category: String); overload;
		{ class } procedure WriteLineIf(condition: Boolean; message: String; category: String); overload;
		{ class } property AutoFlush: Boolean read _GetProp_AutoFlush write _SetProp_AutoFlush;
		{ class } property IndentLevel: Integer read _GetProp_IndentLevel write _SetProp_IndentLevel;
		{ class } property IndentSize: Integer read _GetProp_IndentSize write _SetProp_IndentSize;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUG)]
	IDebug = interface(IObject)
	['{C6147655-DE88-4DC0-BD46-CE93FB46E2CA}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGABLEATTRIBUTE)]
	IDebuggableAttribute = interface(IAttribute)
	['{676780DF-1169-4A5F-853E-643B93B88536}']
	{ private }
		function _GetProp_DebuggingFlags: TDebuggingModes_Set;
		function _GetProp_IsJITOptimizerDisabled: Boolean;
		function _GetProp_IsJITTrackingEnabled: Boolean;
	{ public }
		property DebuggingFlags: TDebuggingModes_Set read _GetProp_DebuggingFlags;
		property IsJITOptimizerDisabled: Boolean read _GetProp_IsJITOptimizerDisabled;
		property IsJITTrackingEnabled: Boolean read _GetProp_IsJITTrackingEnabled;
	end;

	IDebuggerClass = interface(ICoreClrClass)
	['{D36F7B85-AC18-4761-9D3C-EC71FF592841}']
	{ private }
		{ class } function _GetFld_DefaultCategory: String;
		{ class } function _GetProp_IsAttached: Boolean;
	{ public }
		{ class } procedure &Break();
		{ class } function IsLogging(): Boolean;
		{ class } function Launch(): Boolean;
		{ class } procedure Log(level: Integer; category: String; message: String);
		{ class } procedure NotifyOfCrossThreadDependency();
		{ class } property DefaultCategory: String read _GetFld_DefaultCategory;
		{ class } property IsAttached: Boolean read _GetProp_IsAttached;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGER)]
	IDebugger = interface(IObject)
	['{20DDD3C6-9636-4274-A0F1-3F15FB5D746F}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERBROWSABLEATTRIBUTE)]
	IDebuggerBrowsableAttribute = interface(IAttribute)
	['{DCFA5877-E059-4FA1-BB0A-B1B07B796B84}']
	{ private }
		function _GetProp_State: TDebuggerBrowsableState;
	{ public }
		property State: TDebuggerBrowsableState read _GetProp_State;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERDISPLAYATTRIBUTE)]
	IDebuggerDisplayAttribute = interface(IAttribute)
	['{5FF24C08-59FC-4DC9-9554-59F2C00E9B99}']
	{ private }
		function _GetProp_Name: String;
		procedure _SetProp_Name(Value: String);
		function _GetProp_Target: IType;
		procedure _SetProp_Target(Value: IType);
		function _GetProp_TargetTypeName: String;
		procedure _SetProp_TargetTypeName(Value: String);
		function _GetProp_Type: String;
		procedure _SetProp_Type(Value: String);
		function _GetProp_Value: String;
	{ public }
		property Name: String read _GetProp_Name write _SetProp_Name;
		property Target: IType read _GetProp_Target write _SetProp_Target;
		property TargetTypeName: String read _GetProp_TargetTypeName write _SetProp_TargetTypeName;
		property &Type: String read _GetProp_Type write _SetProp_Type;
		property Value: String read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERHIDDENATTRIBUTE)]
	IDebuggerHiddenAttribute = interface(IAttribute)
	['{7A256E5D-342D-4995-860A-D9AF051E1CBA}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERNONUSERCODEATTRIBUTE)]
	IDebuggerNonUserCodeAttribute = interface(IAttribute)
	['{456F05CB-5FAE-43F3-8DE6-BF2C55897BB2}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERSTEPPERBOUNDARYATTRIBUTE)]
	IDebuggerStepperBoundaryAttribute = interface(IAttribute)
	['{633D0C68-6E6E-4ACC-AFC6-7ED3BCF1A82C}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERSTEPTHROUGHATTRIBUTE)]
	IDebuggerStepThroughAttribute = interface(IAttribute)
	['{1175A581-48F3-4E5F-A55D-9ADB0416F01D}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERTYPEPROXYATTRIBUTE)]
	IDebuggerTypeProxyAttribute = interface(IAttribute)
	['{C750C2CF-2E80-4A49-8D47-7E72117F86FF}']
	{ private }
		function _GetProp_ProxyTypeName: String;
		function _GetProp_Target: IType;
		procedure _SetProp_Target(Value: IType);
		function _GetProp_TargetTypeName: String;
		procedure _SetProp_TargetTypeName(Value: String);
	{ public }
		property ProxyTypeName: String read _GetProp_ProxyTypeName;
		property Target: IType read _GetProp_Target write _SetProp_Target;
		property TargetTypeName: String read _GetProp_TargetTypeName write _SetProp_TargetTypeName;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGGERVISUALIZERATTRIBUTE)]
	IDebuggerVisualizerAttribute = interface(IAttribute)
	['{39295F07-6629-43D1-A191-5E82FB826B27}']
	{ private }
		function _GetProp_Description: String;
		procedure _SetProp_Description(Value: String);
		function _GetProp_Target: IType;
		procedure _SetProp_Target(Value: IType);
		function _GetProp_TargetTypeName: String;
		procedure _SetProp_TargetTypeName(Value: String);
		function _GetProp_VisualizerObjectSourceTypeName: String;
		function _GetProp_VisualizerTypeName: String;
	{ public }
		property Description: String read _GetProp_Description write _SetProp_Description;
		property Target: IType read _GetProp_Target write _SetProp_Target;
		property TargetTypeName: String read _GetProp_TargetTypeName write _SetProp_TargetTypeName;
		property VisualizerObjectSourceTypeName: String read _GetProp_VisualizerObjectSourceTypeName;
		property VisualizerTypeName: String read _GetProp_VisualizerTypeName;
	end;

	IDebugProviderClass = interface(ICoreClrClass)
	['{3F8771B3-5F9A-41D8-9400-649CA2089DB3}']
	{ public }
		{ class } procedure FailCore(stackTrace: String; message: String; detailMessage: String; errorSource: String);
		{ class } procedure WriteCore(message: String);
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_DEBUGPROVIDER)]
	IDebugProvider = interface(IObject)
	['{97E5131B-AE92-43C0-8A19-8FC836EB59B8}']
	{ public }
		procedure Fail(message: String; detailMessage: String);
		procedure OnIndentLevelChanged(indentLevel: Integer);
		procedure OnIndentSizeChanged(indentSize: Integer);
		procedure Write(message: String);
		procedure WriteLine(message: String);
	end;

	IDecimalClass = interface(ICoreClrClass)
	['{C71F17C7-004C-420A-BB4A-D071F32C4B92}']
	{ private }
		{ class } function _GetFld_MaxValue: IDecimal;
		{ class } function _GetFld_MinusOne: IDecimal;
		{ class } function _GetFld_MinValue: IDecimal;
		{ class } function _GetFld_One: IDecimal;
		{ class } function _GetFld_Zero: IDecimal;
	{ public }
		{ class } function Add(d1: IDecimal; d2: IDecimal): IDecimal;
		{ class } function Ceiling(d: IDecimal): IDecimal;
		{ class } function Compare(d1: IDecimal; d2: IDecimal): Integer;
		{ class } function Divide(d1: IDecimal; d2: IDecimal): IDecimal;
		{ class } function Equals(d1: IDecimal; d2: IDecimal): Boolean;
		{ class } function Floor(d: IDecimal): IDecimal;
		{ class } function FromOACurrency(cy: Int64): IDecimal;
		{ class } function GetBits(d: IDecimal): TArray<Integer>; overload;
		{ class } function GetBits(d: IDecimal; destination: ISpan<Integer>): Integer; overload;
		{ class } function Multiply(d1: IDecimal; d2: IDecimal): IDecimal;
		{ class } function Negate(d: IDecimal): IDecimal;
		{ class } function Parse(s: String): IDecimal; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): IDecimal; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): IDecimal; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): IDecimal; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): IDecimal; overload;
		{ class } function Remainder(d1: IDecimal; d2: IDecimal): IDecimal;
		{ class } function Round(d: IDecimal): IDecimal; overload;
		{ class } function Round(d: IDecimal; decimals: Integer): IDecimal; overload;
		{ class } function Round(d: IDecimal; mode: TMidpointRounding): IDecimal; overload;
		{ class } function Round(d: IDecimal; decimals: Integer; mode: TMidpointRounding): IDecimal; overload;
		{ class } function Subtract(d1: IDecimal; d2: IDecimal): IDecimal;
		{ class } function ToByte(value: IDecimal): Byte;
		{ class } function ToDouble(d: IDecimal): Double;
		{ class } function ToInt16(value: IDecimal): SmallInt;
		{ class } function ToInt32(d: IDecimal): Integer;
		{ class } function ToInt64(d: IDecimal): Int64;
		{ class } function ToOACurrency(value: IDecimal): Int64;
		{ class } function ToSByte(value: IDecimal): Shortint;
		{ class } function ToSingle(d: IDecimal): Single;
		{ class } function ToUInt16(value: IDecimal): Word;
		{ class } function ToUInt32(d: IDecimal): longword;
		{ class } function ToUInt64(d: IDecimal): UInt64;
		{ class } function Truncate(d: IDecimal): IDecimal;
		{ class } function TryGetBits(d: IDecimal; destination: ISpan<Integer>; var valuesWritten: Integer): Boolean;
		{ class } function TryParse(s: String; var result_: IDecimal): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: IDecimal): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IDecimal): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IDecimal): Boolean; overload;
		{ class } property MaxValue: IDecimal read _GetFld_MaxValue;
		{ class } property MinusOne: IDecimal read _GetFld_MinusOne;
		{ class } property MinValue: IDecimal read _GetFld_MinValue;
		{ class } property One: IDecimal read _GetFld_One;
		{ class } property Zero: IDecimal read _GetFld_Zero;
	end;

	[CoreTypeSignature(SYSTEM_DECIMAL)]
	IDecimal = interface(IValueType)
	['{A15B69E1-95E7-469D-9AB0-1E890DAA0DAB}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: IDecimal): Integer; overload;
		function Equals(value: IDecimal): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DECIMALCONSTANTATTRIBUTE)]
	IDecimalConstantAttribute = interface(IAttribute)
	['{49A7FCD4-AF1A-420F-9564-30432C376799}']
	{ private }
		function _GetProp_Value: IDecimal;
	{ public }
		property Value: IDecimal read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODER)]
	IDecoder = interface(IObject)
	['{19163FB9-61DF-49F0-B7AA-BAAE88413B5B}']
	{ private }
		function _GetProp_Fallback: IDecoderFallback;
		procedure _SetProp_Fallback(Value: IDecoderFallback);
		function _GetProp_FallbackBuffer: IDecoderFallbackBuffer;
	{ public }
		procedure Convert(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer; charCount: Integer; flush: Boolean; var bytesUsed: Integer; var charsUsed: Integer; var completed: Boolean); overload;
		procedure Convert(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer; flush: Boolean; var bytesUsed: Integer; var charsUsed: Integer; var completed: Boolean); overload;
		procedure Convert(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>; flush: Boolean; var bytesUsed: Integer; var charsUsed: Integer; var completed: Boolean); overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer; flush: Boolean): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer; flush: Boolean): Integer; overload;
		function GetCharCount(bytes: IReadOnlySpan<Byte>; flush: Boolean): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer; flush: Boolean): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer; flush: Boolean): Integer; overload;
		function GetChars(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>; flush: Boolean): Integer; overload;
		procedure Reset();
		property Fallback: IDecoderFallback read _GetProp_Fallback write _SetProp_Fallback;
		property FallbackBuffer: IDecoderFallbackBuffer read _GetProp_FallbackBuffer;
	end;

	IDecoderFallbackClass = interface(ICoreClrClass)
	['{E517408A-E6A2-4718-BE75-E3FCE80A4ECF}']
	{ private }
		{ class } function _GetProp_ExceptionFallback: IDecoderFallback;
		{ class } function _GetProp_ReplacementFallback: IDecoderFallback;
	{ public }
		{ class } property ExceptionFallback: IDecoderFallback read _GetProp_ExceptionFallback;
		{ class } property ReplacementFallback: IDecoderFallback read _GetProp_ReplacementFallback;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODERFALLBACK)]
	IDecoderFallback = interface(IObject)
	['{8F5B0675-D795-4A86-A93F-31628F7AB161}']
	{ private }
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IDecoderFallbackBuffer;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODEREXCEPTIONFALLBACK)]
	IDecoderExceptionFallback = interface(IDecoderFallback)
	['{B66FBC7A-1CBC-402C-9D42-E504A63729D6}']
	{ private }
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IDecoderFallbackBuffer;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODERFALLBACKBUFFER)]
	IDecoderFallbackBuffer = interface(IObject)
	['{1AE71A6C-6BEA-4A12-B5DA-C8B4EEEC3B21}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(bytesUnknown: TArray<Byte>; index: Integer): Boolean;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		procedure Reset();
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODEREXCEPTIONFALLBACKBUFFER)]
	IDecoderExceptionFallbackBuffer = interface(IDecoderFallbackBuffer)
	['{0FC70FBA-7AF6-49BF-8882-FAC6F9D32E52}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(bytesUnknown: TArray<Byte>; index: Integer): Boolean;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODERFALLBACKEXCEPTION)]
	IDecoderFallbackException = interface(IArgumentException)
	['{61B69982-76F3-45DA-A187-00C32414D51C}']
	{ private }
		function _GetProp_BytesUnknown: TArray<Byte>;
		function _GetProp_Index: Integer;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property BytesUnknown: TArray<Byte> read _GetProp_BytesUnknown;
		property Index: Integer read _GetProp_Index;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODERREPLACEMENTFALLBACK)]
	IDecoderReplacementFallback = interface(IDecoderFallback)
	['{598A3B4B-F78D-4C10-ADF1-7418308E9282}']
	{ private }
		function _GetProp_DefaultString: String;
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IDecoderFallbackBuffer;
		property DefaultString: String read _GetProp_DefaultString;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_DECODERREPLACEMENTFALLBACKBUFFER)]
	IDecoderReplacementFallbackBuffer = interface(IDecoderFallbackBuffer)
	['{91B25594-FF0E-4E44-A929-4456B2A86B03}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(bytesUnknown: TArray<Byte>; index: Integer): Boolean;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		procedure Reset();
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DEFAULTCHARSETATTRIBUTE)]
	IDefaultCharSetAttribute = interface(IAttribute)
	['{B135BD70-F889-4B7F-A038-8BA520C496E7}']
	{ private }
		function _GetProp_CharSet: TCharSet;
	{ public }
		property CharSet: TCharSet read _GetProp_CharSet;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DEFAULTDEPENDENCYATTRIBUTE)]
	IDefaultDependencyAttribute = interface(IAttribute)
	['{D5C725AA-B2B2-4F94-8A1F-7AD7DCC00DCD}']
	{ private }
		function _GetProp_LoadHint: TLoadHint;
	{ public }
		property LoadHint: TLoadHint read _GetProp_LoadHint;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DEFAULTDLLIMPORTSEARCHPATHSATTRIBUTE)]
	IDefaultDllImportSearchPathsAttribute = interface(IAttribute)
	['{967D0AEB-A8C4-4E9E-B121-C2868E526153}']
	{ private }
		function _GetProp_Paths: TDllImportSearchPath_Set;
	{ public }
		property Paths: TDllImportSearchPath_Set read _GetProp_Paths;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_DEFAULTMEMBERATTRIBUTE)]
	IDefaultMemberAttribute = interface(IAttribute)
	['{2C3E2944-2A58-458C-936D-A448D50D1E55}']
	{ private }
		function _GetProp_MemberName: String;
	{ public }
		property MemberName: String read _GetProp_MemberName;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DEFAULTPARAMETERVALUEATTRIBUTE)]
	IDefaultParameterValueAttribute = interface(IAttribute)
	['{887E5E84-9003-4626-97B2-E6F743FFD8A6}']
	{ private }
		function _GetProp_Value: Variant;
	{ public }
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_COMPONENTMODEL_DEFAULTVALUEATTRIBUTE)]
	IDefaultValueAttribute = interface(IAttribute)
	['{0EF49B23-B204-4926-AC80-E8346ACE5F5A}']
	{ private }
		function _GetProp_Value: Variant;
	{ public }
		property Value: Variant read _GetProp_Value;
	end;

	IDelegateClass = interface(ICoreClrClass)
	['{C1D8F6A3-44B9-48D4-B01C-AD5AB8DE6893}']
	{ public }
		{ class } function Combine(a: IDelegate; b: IDelegate): IDelegate; overload;
		{ class } function Combine(delegates: ICoreClrBridgeArray<IDelegate>): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: Variant; method: String; ignoreCase: Boolean; throwOnBindFailure: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: IType; method: String; ignoreCase: Boolean; throwOnBindFailure: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; method: IMethodInfo; throwOnBindFailure: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; firstArgument: Variant; method: IMethodInfo): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: Variant; method: String): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: IType; method: String): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; firstArgument: Variant; method: IMethodInfo; throwOnBindFailure: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: Variant; method: String; ignoreCase: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; target: IType; method: String; ignoreCase: Boolean): IDelegate; overload;
		{ class } function CreateDelegate(type_: IType; method: IMethodInfo): IDelegate; overload;
		{ class } function Remove(source: IDelegate; value: IDelegate): IDelegate;
		{ class } function RemoveAll(source: IDelegate; value: IDelegate): IDelegate;
	end;

	[CoreTypeSignature(SYSTEM_DELEGATE)]
	IDelegate = interface(IObject)
	['{5B6DC2FC-8CF2-49C2-80EA-630CFF9B2296}']
	{ private }
		function _GetProp_Method: IMethodInfo;
		function _GetProp_Target: Variant;
	{ public }
		function Clone(): Variant;
		function DynamicInvoke(args: TArray<Variant>): Variant;
		function GetInvocationList(): TArray<IDelegate>;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Method: IMethodInfo read _GetProp_Method;
		property Target: Variant read _GetProp_Target;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DELEGATEWRAPPER)]
	IDelegateWrapper = interface(IObject)
	['{B2B78503-D502-4EBD-8114-CADF5B74D471}']
	{ private }
		function _GetProp_Delegate: IDelegate;
		procedure _SetProp_Delegate(Value: IDelegate);
		function _GetProp_WrapArgs: Boolean;
	{ public }
		function Invoke(args: TArray<Variant>): Variant;
		property Delegate: IDelegate read _GetProp_Delegate write _SetProp_Delegate;
		property WrapArgs: Boolean read _GetProp_WrapArgs;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DEPENDENCYATTRIBUTE)]
	IDependencyAttribute = interface(IAttribute)
	['{79861690-59DF-4B5E-8E30-CEC9B1CF2310}']
	{ private }
		function _GetProp_DependentAssembly: String;
		function _GetProp_LoadHint: TLoadHint;
	{ public }
		property DependentAssembly: String read _GetProp_DependentAssembly;
		property LoadHint: TLoadHint read _GetProp_LoadHint;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_DESCUNION)]
	IDESCUNION = interface(IValueType)
	['{6596A19A-0758-449C-A8E6-5DE1BAE0E9A8}']
	{ private }
		function _GetFld_idldesc: IIDLDESC;
		procedure _SetFld_idldesc(Value: IIDLDESC);
		function _GetFld_paramdesc: IPARAMDESC;
		procedure _SetFld_paramdesc(Value: IPARAMDESC);
	{ public }
		property idldesc: IIDLDESC read _GetFld_idldesc write _SetFld_idldesc;
		property paramdesc: IPARAMDESC read _GetFld_paramdesc write _SetFld_paramdesc;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_DESCUNION_2)]
	IDESCUNION_1 = interface(IValueType)
	['{C158FF18-5944-4872-AF85-D59DC5F0C68A}']
	{ private }
		function _GetFld_lpvarValue: IIntPtr;
		procedure _SetFld_lpvarValue(Value: IIntPtr);
		function _GetFld_oInst: Integer;
		procedure _SetFld_oInst(Value: Integer);
	{ public }
		property lpvarValue: IIntPtr read _GetFld_lpvarValue write _SetFld_lpvarValue;
		property oInst: Integer read _GetFld_oInst write _SetFld_oInst;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_DESERIALIZATIONTOKEN)]
	IDeserializationToken = interface(IValueType)
	['{73C617B7-8B23-4653-8DB0-1AEB1285A8F8}']
	{ public }
		procedure Dispose();
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_DIAGNOSTICCOUNTER)]
	IDiagnosticCounter = interface(IIDisposable)
	['{7D534A07-C8D8-4B74-9F2B-F2F91F68E5F9}']
	{ private }
		function _GetProp_DisplayName: String;
		procedure _SetProp_DisplayName(Value: String);
		function _GetProp_DisplayUnits: String;
		procedure _SetProp_DisplayUnits(Value: String);
		function _GetProp_EventSource: IEventSource;
		function _GetProp_Name: String;
	{ public }
		procedure AddMetadata(key: String; value: String);
		procedure Dispose();
		property DisplayName: String read _GetProp_DisplayName write _SetProp_DisplayName;
		property DisplayUnits: String read _GetProp_DisplayUnits write _SetProp_DisplayUnits;
		property EventSource: IEventSource read _GetProp_EventSource;
		property Name: String read _GetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_DICTIONARY_2)]
	IDictionary<TKey,TValue> = interface(IObject)
	['{981C9C2F-8D91-4B5F-9CFE-FCF22F7B0309}']
	{ private }
		function _GetProp_Comparer: IIEqualityComparer<TKey>;
		function _GetProp_Count: Integer;
		function _GetProp_Item(key: TKey): TValue;
		procedure _SetProp_Item(key: TKey; Value: TValue);
		function _GetProp_Keys: IDictionary_KeyCollection<TKey,TValue>;
		function _GetProp_Values: IDictionary_ValueCollection<TKey,TValue>;
	{ public }
		procedure Add(key: TKey; value: TValue);
		procedure Clear();
		function ContainsKey(key: TKey): Boolean;
		function ContainsValue(value: TValue): Boolean;
		function EnsureCapacity(capacity: Integer): Integer;
		function GetEnumerator(): IDictionary_Enumerator<TKey,TValue>;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure OnDeserialization(sender: Variant);
		function Remove(key: TKey): Boolean; overload;
		function Remove(key: TKey; var value: TValue): Boolean; overload;
		procedure TrimExcess(); overload;
		procedure TrimExcess(capacity: Integer); overload;
		function TryAdd(key: TKey; value: TValue): Boolean;
		function TryGetValue(key: TKey; var value: TValue): Boolean;
		property Comparer: IIEqualityComparer<TKey> read _GetProp_Comparer;
		property Count: Integer read _GetProp_Count;
		property Item[key: TKey]: TValue read _GetProp_Item write _SetProp_Item; default;
		property Keys: IDictionary_KeyCollection<TKey,TValue> read _GetProp_Keys;
		property Values: IDictionary_ValueCollection<TKey,TValue> read _GetProp_Values;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR)]
	IDictionary_Enumerator<TKey,TValue> = interface(IValueType)
	['{3A0E8456-B0EE-4A7D-939B-06BCC685A188}']
	{ private }
		function _GetProp_Current: IKeyValuePair<TKey,TValue>;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: IKeyValuePair<TKey,TValue> read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_KEYCOLLECTION)]
	IDictionary_KeyCollection<TKey,TValue> = interface(IObject)
	['{CEEFDDE5-7A40-4799-810A-54E5831A5E30}']
	{ private }
		function _GetProp_Count: Integer;
	{ public }
		procedure CopyTo(array_: ICoreClrBridgeArray<TKey>; index: Integer);
		function GetEnumerator(): IKeyCollection_Enumerator<TKey,TValue>;
		property Count: Integer read _GetProp_Count;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_2)]
	IKeyCollection_Enumerator<TKey,TValue> = interface(IValueType)
	['{694858D8-A3D4-4C6D-9444-0CE790945D69}']
	{ private }
		function _GetProp_Current: TKey;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: TKey read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_VALUECOLLECTION)]
	IDictionary_ValueCollection<TKey,TValue> = interface(IObject)
	['{C00DC7A1-D1EB-49F9-8FB7-72C7DADF11D0}']
	{ private }
		function _GetProp_Count: Integer;
	{ public }
		procedure CopyTo(array_: ICoreClrBridgeArray<TValue>; index: Integer);
		function GetEnumerator(): IValueCollection_Enumerator<TKey,TValue>;
		property Count: Integer read _GetProp_Count;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_3)]
	IValueCollection_Enumerator<TKey,TValue> = interface(IValueType)
	['{729293E0-B6B4-4BE6-966D-792E36AD2E4B}']
	{ private }
		function _GetProp_Current: TValue;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: TValue read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_DICTIONARYENTRY)]
	IDictionaryEntry = interface(IValueType)
	['{19A9E889-FF65-41A9-8ADF-151BD16E42EF}']
	{ private }
		function _GetProp_Key: Variant;
		procedure _SetProp_Key(Value: Variant);
		function _GetProp_Value: Variant;
		procedure _SetProp_Value(Value: Variant);
	{ public }
		procedure Deconstruct(var key: Variant; var value: Variant);
		property Key: Variant read _GetProp_Key write _SetProp_Key;
		property Value: Variant read _GetProp_Value write _SetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_IO_IOEXCEPTION)]
	IIOException = interface(ISystemException)
	['{465DF779-8149-44C4-8ED6-552979E73FD5}']
	end;

	[CoreTypeSignature(SYSTEM_IO_DIRECTORYNOTFOUNDEXCEPTION)]
	IDirectoryNotFoundException = interface(IIOException)
	['{704CF5AA-42D7-49F7-9DF1-47DF5D92EB2E}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DISABLEPRIVATEREFLECTIONATTRIBUTE)]
	IDisablePrivateReflectionAttribute = interface(IAttribute)
	['{FDA5B30A-3A07-4E9B-930F-A08CD4C59DDB}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_DISALLOWNULLATTRIBUTE)]
	IDisallowNullAttribute = interface(IAttribute)
	['{C45442D8-2F4D-4734-A368-E4ACC9D5C465}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_DISCARDABLEATTRIBUTE)]
	IDiscardableAttribute = interface(IAttribute)
	['{669C0577-C048-47FD-97FD-57B022FF9E55}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DISPATCHWRAPPER)]
	IDispatchWrapper = interface(IObject)
	['{13C58E04-3CCA-4A42-A065-9D34EF93D921}']
	{ private }
		function _GetProp_WrappedObject: Variant;
	{ public }
		property WrappedObject: Variant read _GetProp_WrappedObject;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DISPIDATTRIBUTE)]
	IDispIdAttribute = interface(IAttribute)
	['{BC9C5871-4152-49AF-B798-A88E2B6E5560}']
	{ private }
		function _GetProp_Value: Integer;
	{ public }
		property Value: Integer read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_DISPPARAMS)]
	IDISPPARAMS = interface(IValueType)
	['{75916499-D6F0-4280-BCF7-A8CD1E88C8F9}']
	{ private }
		function _GetFld_cArgs: Integer;
		procedure _SetFld_cArgs(Value: Integer);
		function _GetFld_cNamedArgs: Integer;
		procedure _SetFld_cNamedArgs(Value: Integer);
		function _GetFld_rgdispidNamedArgs: IIntPtr;
		procedure _SetFld_rgdispidNamedArgs(Value: IIntPtr);
		function _GetFld_rgvarg: IIntPtr;
		procedure _SetFld_rgvarg(Value: IIntPtr);
	{ public }
		property cArgs: Integer read _GetFld_cArgs write _SetFld_cArgs;
		property cNamedArgs: Integer read _GetFld_cNamedArgs write _SetFld_cNamedArgs;
		property rgdispidNamedArgs: IIntPtr read _GetFld_rgdispidNamedArgs write _SetFld_rgdispidNamedArgs;
		property rgvarg: IIntPtr read _GetFld_rgvarg write _SetFld_rgvarg;
	end;

	[CoreTypeSignature(SYSTEM_DIVIDEBYZEROEXCEPTION)]
	IDivideByZeroException = interface(IArithmeticException)
	['{AA6AF15C-3125-4C9D-9AFD-DA2E2C37A1C2}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DLLIMPORTATTRIBUTE)]
	IDllImportAttribute = interface(IAttribute)
	['{05CE5B4D-3217-4800-B367-A025CBF3CE0D}']
	{ private }
		function _GetFld_BestFitMapping: Boolean;
		procedure _SetFld_BestFitMapping(Value: Boolean);
		function _GetFld_CallingConvention: TCallingConvention;
		procedure _SetFld_CallingConvention(Value: TCallingConvention);
		function _GetFld_CharSet: TCharSet;
		procedure _SetFld_CharSet(Value: TCharSet);
		function _GetFld_EntryPoint: String;
		procedure _SetFld_EntryPoint(Value: String);
		function _GetFld_ExactSpelling: Boolean;
		procedure _SetFld_ExactSpelling(Value: Boolean);
		function _GetFld_PreserveSig: Boolean;
		procedure _SetFld_PreserveSig(Value: Boolean);
		function _GetFld_SetLastError: Boolean;
		procedure _SetFld_SetLastError(Value: Boolean);
		function _GetFld_ThrowOnUnmappableChar: Boolean;
		procedure _SetFld_ThrowOnUnmappableChar(Value: Boolean);
		function _GetProp_Value: String;
	{ public }
		property BestFitMapping: Boolean read _GetFld_BestFitMapping write _SetFld_BestFitMapping;
		property CallingConvention: TCallingConvention read _GetFld_CallingConvention write _SetFld_CallingConvention;
		property CharSet: TCharSet read _GetFld_CharSet write _SetFld_CharSet;
		property EntryPoint: String read _GetFld_EntryPoint write _SetFld_EntryPoint;
		property ExactSpelling: Boolean read _GetFld_ExactSpelling write _SetFld_ExactSpelling;
		property PreserveSig: Boolean read _GetFld_PreserveSig write _SetFld_PreserveSig;
		property SetLastError: Boolean read _GetFld_SetLastError write _SetFld_SetLastError;
		property ThrowOnUnmappableChar: Boolean read _GetFld_ThrowOnUnmappableChar write _SetFld_ThrowOnUnmappableChar;
		property Value: String read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_TYPELOADEXCEPTION)]
	ITypeLoadException = interface(ISystemException)
	['{46453C1F-E81C-4CFA-A8F3-4803DB02BF55}']
	{ private }
		function _GetProp_Message: String;
		function _GetProp_TypeName: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
		property TypeName: String read _GetProp_TypeName;
	end;

	[CoreTypeSignature(SYSTEM_DLLNOTFOUNDEXCEPTION)]
	IDllNotFoundException = interface(ITypeLoadException)
	['{88C79EFB-4FF4-49E6-AA3A-EBD7CF69CE8A}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_DOESNOTRETURNATTRIBUTE)]
	IDoesNotReturnAttribute = interface(IAttribute)
	['{9ABDD16B-15B2-4A42-AC6C-D8E4319C1929}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_DOESNOTRETURNIFATTRIBUTE)]
	IDoesNotReturnIfAttribute = interface(IAttribute)
	['{F3BA6276-47E8-4A1C-A70B-683BA217E0BE}']
	{ private }
		function _GetProp_ParameterValue: Boolean;
	{ public }
		property ParameterValue: Boolean read _GetProp_ParameterValue;
	end;

	IDoubleClass = interface(ICoreClrClass)
	['{C290C8EF-EC0D-4487-9F95-D2407A46C0D3}']
	{ private }
		{ class } function _GetFld_Epsilon: Double;
		{ class } function _GetFld_MaxValue: Double;
		{ class } function _GetFld_MinValue: Double;
		{ class } function _GetFld_NaN: Double;
		{ class } function _GetFld_NegativeInfinity: Double;
		{ class } function _GetFld_PositiveInfinity: Double;
	{ public }
		{ class } function IsFinite(d: Double): Boolean;
		{ class } function IsInfinity(d: Double): Boolean;
		{ class } function IsNaN(d: Double): Boolean;
		{ class } function IsNegative(d: Double): Boolean;
		{ class } function IsNegativeInfinity(d: Double): Boolean;
		{ class } function IsNormal(d: Double): Boolean;
		{ class } function IsPositiveInfinity(d: Double): Boolean;
		{ class } function IsSubnormal(d: Double): Boolean;
		{ class } function Parse(s: String): Double; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Double; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Double; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Double; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Double; overload;
		{ class } function TryParse(s: String; var result_: Double): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Double): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Double): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Double): Boolean; overload;
		{ class } property Epsilon: Double read _GetFld_Epsilon;
		{ class } property MaxValue: Double read _GetFld_MaxValue;
		{ class } property MinValue: Double read _GetFld_MinValue;
		{ class } property NaN: Double read _GetFld_NaN;
		{ class } property NegativeInfinity: Double read _GetFld_NegativeInfinity;
		{ class } property PositiveInfinity: Double read _GetFld_PositiveInfinity;
	end;

	[CoreTypeSignature(SYSTEM_DOUBLE_)]
	IDouble = interface(IValueType)
	['{F4DC3F12-1205-40A5-BCEB-C4649DF41398}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Double): Integer; overload;
		function Equals(obj: Double): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IDpClass = interface(ICoreClrClass)
	['{C9A86B3D-5BE1-4ED0-B3C7-2401ED35E71A}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function DotProduct(addend: IVector64<Integer>; left: IVector64<Shortint>; right: IVector64<Shortint>): IVector64<Integer>; overload;
		{ class } function DotProduct(addend: IVector64<longword>; left: IVector64<Byte>; right: IVector64<Byte>): IVector64<longword>; overload;
		{ class } function DotProduct(addend: IVector128<Integer>; left: IVector128<Shortint>; right: IVector128<Shortint>): IVector128<Integer>; overload;
		{ class } function DotProduct(addend: IVector128<longword>; left: IVector128<Byte>; right: IVector128<Byte>): IVector128<longword>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector64<Integer>; left: IVector64<Shortint>; right: IVector64<Shortint>; rightScaledIndex: Byte): IVector64<Integer>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector64<Integer>; left: IVector64<Shortint>; right: IVector128<Shortint>; rightScaledIndex: Byte): IVector64<Integer>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector64<longword>; left: IVector64<Byte>; right: IVector64<Byte>; rightScaledIndex: Byte): IVector64<longword>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector64<longword>; left: IVector64<Byte>; right: IVector128<Byte>; rightScaledIndex: Byte): IVector64<longword>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector128<Integer>; left: IVector128<Shortint>; right: IVector128<Shortint>; rightScaledIndex: Byte): IVector128<Integer>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector128<Integer>; left: IVector128<Shortint>; right: IVector64<Shortint>; rightScaledIndex: Byte): IVector128<Integer>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector128<longword>; left: IVector128<Byte>; right: IVector128<Byte>; rightScaledIndex: Byte): IVector128<longword>; overload;
		{ class } function DotProductBySelectedQuadruplet(addend: IVector128<longword>; left: IVector128<Byte>; right: IVector64<Byte>; rightScaledIndex: Byte): IVector128<longword>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_DP)]
	IDp = interface(IAdvSimd)
	['{341A6809-B966-4F13-8F46-BFD6BD36E7B3}']
	end;

	[CoreTypeSignature(SYSTEM_DUPLICATEWAITOBJECTEXCEPTION)]
	IDuplicateWaitObjectException = interface(IArgumentException)
	['{3A0C8A9D-ADC8-4D0C-97EB-B2793903366A}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_DYNAMICALLYACCESSEDMEMBERSATTRIBUTE)]
	IDynamicallyAccessedMembersAttribute = interface(IAttribute)
	['{07A425D8-D4A9-4FFC-A1B2-C71E7E43DB86}']
	{ private }
		function _GetProp_MemberTypes: TDynamicallyAccessedMemberTypes_Set;
	{ public }
		property MemberTypes: TDynamicallyAccessedMemberTypes_Set read _GetProp_MemberTypes;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_DYNAMICDEPENDENCYATTRIBUTE)]
	IDynamicDependencyAttribute = interface(IAttribute)
	['{C3BC65E3-C61E-49B3-9C01-1A9DA981F49C}']
	{ private }
		function _GetProp_AssemblyName: String;
		function _GetProp_Condition: String;
		procedure _SetProp_Condition(Value: String);
		function _GetProp_MemberSignature: String;
		function _GetProp_MemberTypes: TDynamicallyAccessedMemberTypes_Set;
		function _GetProp_Type: IType;
		function _GetProp_TypeName: String;
	{ public }
		property AssemblyName: String read _GetProp_AssemblyName;
		property Condition: String read _GetProp_Condition write _SetProp_Condition;
		property MemberSignature: String read _GetProp_MemberSignature;
		property MemberTypes: TDynamicallyAccessedMemberTypes_Set read _GetProp_MemberTypes;
		property &Type: IType read _GetProp_Type;
		property TypeName: String read _GetProp_TypeName;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_DYNAMICILINFO)]
	IDynamicILInfo = interface(IObject)
	['{10D1ECE5-935B-417E-8E96-2040B2E19E3A}']
	{ private }
		function _GetProp_DynamicMethod: IDynamicMethod;
	{ public }
		function GetTokenFor(method: IRuntimeMethodHandle): Integer; overload;
		function GetTokenFor(method: IDynamicMethod): Integer; overload;
		function GetTokenFor(field: IRuntimeFieldHandle): Integer; overload;
		function GetTokenFor(type_: IRuntimeTypeHandle): Integer; overload;
		function GetTokenFor(literal: String): Integer; overload;
		function GetTokenFor(signature: TArray<Byte>): Integer; overload;
		function GetTokenFor(method: IRuntimeMethodHandle; contextType: IRuntimeTypeHandle): Integer; overload;
		function GetTokenFor(field: IRuntimeFieldHandle; contextType: IRuntimeTypeHandle): Integer; overload;
		procedure SetCode(code: TArray<Byte>; maxStackSize: Integer); overload;
		procedure SetCode(code: ICoreClrInstance; codeSize: Integer; maxStackSize: Integer); overload;
		procedure SetExceptions(exceptions: TArray<Byte>); overload;
		procedure SetExceptions(exceptions: ICoreClrInstance; exceptionsSize: Integer); overload;
		procedure SetLocalSignature(localSignature: TArray<Byte>); overload;
		procedure SetLocalSignature(localSignature: ICoreClrInstance; signatureSize: Integer); overload;
		property DynamicMethod: IDynamicMethod read _GetProp_DynamicMethod;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_DYNAMICINTERFACECASTABLEIMPLEMENTATIONATTRIBUTE)]
	IDynamicInterfaceCastableImplementationAttribute = interface(IAttribute)
	['{92E25455-0C8E-45CE-A612-921DB8F3A459}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_METHODINFO)]
	IMethodInfo = interface(IMethodBase)
	['{097E2BC6-8A65-45C2-9103-35C37FCE33FF}']
	{ private }
		function _GetProp_MemberType: TMemberTypes_Set;
		function _GetProp_ReturnParameter: IParameterInfo;
		function _GetProp_ReturnType: IType;
		function _GetProp_ReturnTypeCustomAttributes: IICustomAttributeProvider;
	{ public }
		function CreateDelegate(delegateType: IType): IDelegate; overload;
		function CreateDelegate(T: PTypeInfo; target: Variant): IDelegate; overload;
		function CreateDelegate(delegateType: IType; target: Variant): IDelegate; overload;
		function CreateDelegate(T: PTypeInfo): IDelegate;
 overload;
		function GetBaseDefinition(): IMethodInfo;
		function GetGenericArguments(): TArray<IType>;
		function GetGenericMethodDefinition(): IMethodInfo;
		function MakeGenericMethod(typeArguments: ICoreClrBridgeArray<IType>): IMethodInfo;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
		property ReturnParameter: IParameterInfo read _GetProp_ReturnParameter;
		property ReturnType: IType read _GetProp_ReturnType;
		property ReturnTypeCustomAttributes: IICustomAttributeProvider read _GetProp_ReturnTypeCustomAttributes;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_DYNAMICMETHOD)]
	IDynamicMethod = interface(IMethodInfo)
	['{2AB0B265-ABAF-4D8C-AE8C-5E68F425D296}']
	{ private }
		function _GetProp_Attributes: TMethodAttributes_Set;
		function _GetProp_CallingConvention: TCallingConventions_Set;
		function _GetProp_DeclaringType: IType;
		function _GetProp_InitLocals: Boolean;
		procedure _SetProp_InitLocals(Value: Boolean);
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_MethodHandle: IRuntimeMethodHandle;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_ReturnParameter: IParameterInfo;
		function _GetProp_ReturnType: IType;
		function _GetProp_ReturnTypeCustomAttributes: IICustomAttributeProvider;
	{ public }
		function CreateDelegate(delegateType: IType): IDelegate; overload;
		function CreateDelegate(delegateType: IType; target: Variant): IDelegate; overload;
		function DefineParameter(position: Integer; attributes: TParameterAttributes_Set; parameterName: String): IParameterBuilder;
		function GetBaseDefinition(): IMethodInfo;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetDynamicILInfo(): IDynamicILInfo;
		function GetGenericArguments(): TArray<IType>;
		function GetILGenerator(): IILGenerator; overload;
		function GetILGenerator(streamSize: Integer): IILGenerator; overload;
		function GetMethodImplementationFlags(): TMethodImplAttributes;
		function GetParameters(): TArray<IParameterInfo>;
		function Invoke(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		property Attributes: TMethodAttributes_Set read _GetProp_Attributes;
		property CallingConvention: TCallingConventions_Set read _GetProp_CallingConvention;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property InitLocals: Boolean read _GetProp_InitLocals write _SetProp_InitLocals;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property MethodHandle: IRuntimeMethodHandle read _GetProp_MethodHandle;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property ReturnParameter: IParameterInfo read _GetProp_ReturnParameter;
		property ReturnType: IType read _GetProp_ReturnType;
		property ReturnTypeCustomAttributes: IICustomAttributeProvider read _GetProp_ReturnTypeCustomAttributes;
	end;

	[CoreTypeSignature(SYSTEM_COMPONENTMODEL_EDITORBROWSABLEATTRIBUTE)]
	IEditorBrowsableAttribute = interface(IAttribute)
	['{FD931321-B7ED-4DCF-8AE1-C58A4CAAD34F}']
	{ private }
		function _GetProp_State: TEditorBrowsableState;
	{ public }
		property State: TEditorBrowsableState read _GetProp_State;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ELEMDESC)]
	IELEMDESC = interface(IValueType)
	['{083C510E-39A2-43AC-B35D-B79D343A029A}']
	{ private }
		function _GetFld_desc: IDESCUNION;
		procedure _SetFld_desc(Value: IDESCUNION);
		function _GetFld_tdesc: ITYPEDESC;
		procedure _SetFld_tdesc(Value: ITYPEDESC);
	{ public }
		property desc: IDESCUNION read _GetFld_desc write _SetFld_desc;
		property tdesc: ITYPEDESC read _GetFld_tdesc write _SetFld_tdesc;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODER)]
	IEncoder = interface(IObject)
	['{CF9C1DFA-2558-48C0-985B-0589BE2392EC}']
	{ private }
		function _GetProp_Fallback: IEncoderFallback;
		procedure _SetProp_Fallback(Value: IEncoderFallback);
		function _GetProp_FallbackBuffer: IEncoderFallbackBuffer;
	{ public }
		procedure Convert(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; flush: Boolean; var charsUsed: Integer; var bytesUsed: Integer; var completed: Boolean); overload;
		procedure Convert(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer; flush: Boolean; var charsUsed: Integer; var bytesUsed: Integer; var completed: Boolean); overload;
		procedure Convert(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>; flush: Boolean; var charsUsed: Integer; var bytesUsed: Integer; var completed: Boolean); overload;
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer; flush: Boolean): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer; flush: Boolean): Integer; overload;
		function GetByteCount(chars: IReadOnlySpan<Char>; flush: Boolean): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer; flush: Boolean): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer; flush: Boolean): Integer; overload;
		function GetBytes(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>; flush: Boolean): Integer; overload;
		procedure Reset();
		property Fallback: IEncoderFallback read _GetProp_Fallback write _SetProp_Fallback;
		property FallbackBuffer: IEncoderFallbackBuffer read _GetProp_FallbackBuffer;
	end;

	IEncoderFallbackClass = interface(ICoreClrClass)
	['{D08BD6D0-2FC3-450D-8C2E-B670E5F5F75E}']
	{ private }
		{ class } function _GetProp_ExceptionFallback: IEncoderFallback;
		{ class } function _GetProp_ReplacementFallback: IEncoderFallback;
	{ public }
		{ class } property ExceptionFallback: IEncoderFallback read _GetProp_ExceptionFallback;
		{ class } property ReplacementFallback: IEncoderFallback read _GetProp_ReplacementFallback;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODERFALLBACK)]
	IEncoderFallback = interface(IObject)
	['{81877763-88FC-4152-81F4-BA4C53594E4B}']
	{ private }
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IEncoderFallbackBuffer;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODEREXCEPTIONFALLBACK)]
	IEncoderExceptionFallback = interface(IEncoderFallback)
	['{39D72C66-42AB-429A-96CC-339BF9F18425}']
	{ private }
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IEncoderFallbackBuffer;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODERFALLBACKBUFFER)]
	IEncoderFallbackBuffer = interface(IObject)
	['{1E3FBC39-9D39-42A5-8FED-73A6D87FBB0E}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(charUnknown: Char; index: Integer): Boolean; overload;
		function Fallback(charUnknownHigh: Char; charUnknownLow: Char; index: Integer): Boolean; overload;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		procedure Reset();
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODEREXCEPTIONFALLBACKBUFFER)]
	IEncoderExceptionFallbackBuffer = interface(IEncoderFallbackBuffer)
	['{17F12CB0-EE47-4CBA-B454-687F4F4333C7}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(charUnknown: Char; index: Integer): Boolean; overload;
		function Fallback(charUnknownHigh: Char; charUnknownLow: Char; index: Integer): Boolean; overload;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODERFALLBACKEXCEPTION)]
	IEncoderFallbackException = interface(IArgumentException)
	['{124ED507-C932-4EA4-9E8A-E3E59AF5D002}']
	{ private }
		function _GetProp_CharUnknown: Char;
		function _GetProp_CharUnknownHigh: Char;
		function _GetProp_CharUnknownLow: Char;
		function _GetProp_Index: Integer;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		function IsUnknownSurrogate(): Boolean;
		property CharUnknown: Char read _GetProp_CharUnknown;
		property CharUnknownHigh: Char read _GetProp_CharUnknownHigh;
		property CharUnknownLow: Char read _GetProp_CharUnknownLow;
		property Index: Integer read _GetProp_Index;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODERREPLACEMENTFALLBACK)]
	IEncoderReplacementFallback = interface(IEncoderFallback)
	['{4EC1C00E-AF72-4FC4-89BA-1A833DB173EA}']
	{ private }
		function _GetProp_DefaultString: String;
		function _GetProp_MaxCharCount: Integer;
	{ public }
		function CreateFallbackBuffer(): IEncoderFallbackBuffer;
		property DefaultString: String read _GetProp_DefaultString;
		property MaxCharCount: Integer read _GetProp_MaxCharCount;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODERREPLACEMENTFALLBACKBUFFER)]
	IEncoderReplacementFallbackBuffer = interface(IEncoderFallbackBuffer)
	['{A520F737-8465-4795-B973-F1198827AAA6}']
	{ private }
		function _GetProp_Remaining: Integer;
	{ public }
		function Fallback(charUnknown: Char; index: Integer): Boolean; overload;
		function Fallback(charUnknownHigh: Char; charUnknownLow: Char; index: Integer): Boolean; overload;
		function GetNextChar(): Char;
		function MovePrevious(): Boolean;
		procedure Reset();
		property Remaining: Integer read _GetProp_Remaining;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODINGINFO)]
	IEncodingInfo = interface(IObject)
	['{330F60B8-1895-4637-B57F-C8B62522F45C}']
	{ private }
		function _GetProp_CodePage: Integer;
		function _GetProp_DisplayName: String;
		function _GetProp_Name: String;
	{ public }
		function GetEncoding(): IEncoding;
		property CodePage: Integer read _GetProp_CodePage;
		property DisplayName: String read _GetProp_DisplayName;
		property Name: String read _GetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_ENCODINGPROVIDER)]
	IEncodingProvider = interface(IObject)
	['{069AA895-3644-41A3-92C0-C7A2A06FBFC1}']
	{ public }
		function GetEncoding(name: String): IEncoding; overload;
		function GetEncoding(codepage: Integer): IEncoding; overload;
		function GetEncoding(name: String; encoderFallback: IEncoderFallback; decoderFallback: IDecoderFallback): IEncoding; overload;
		function GetEncoding(codepage: Integer; encoderFallback: IEncoderFallback; decoderFallback: IDecoderFallback): IEncoding; overload;
		function GetEncodings(): IIEnumerable<IEncodingInfo>;
	end;

	[CoreTypeSignature(SYSTEM_IO_ENDOFSTREAMEXCEPTION)]
	IEndOfStreamException = interface(IIOException)
	['{E2527F83-87BE-4344-A2AE-D0387F746571}']
	end;

	[CoreTypeSignature(SYSTEM_ENTRYPOINTNOTFOUNDEXCEPTION)]
	IEntryPointNotFoundException = interface(ITypeLoadException)
	['{67DF384C-6BC0-4ED4-A9B8-9B7BA5618215}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	IEnumClass = interface(ICoreClrClass)
	['{5DDB5A05-EA9F-4BD6-B5EB-0A8B808A63B8}']
	{ public }
		{ class } function Format(enumType: IType; value: Variant; format: String): String;
		{ class } function GetName(TEnum: PTypeInfo; value: Variant{TEnum}): String; overload;
		{ class } function GetName(enumType: IType; value: Variant): String; overload;
		{ class } function GetNames(TEnum: PTypeInfo): TArray<String>;
 overload;
		{ class } function GetNames(enumType: IType): TArray<String>; overload;
		{ class } function GetUnderlyingType(enumType: IType): IType;
		{ class } function GetValues(TEnum: PTypeInfo): ICoreClrBridgeArray<Variant{TEnum}>;
 overload;
		{ class } function GetValues(enumType: IType): IArray; overload;
		{ class } function IsDefined(TEnum: PTypeInfo; value: Variant{TEnum}): Boolean; overload;
		{ class } function IsDefined(enumType: IType; value: Variant): Boolean; overload;
		{ class } function Parse(enumType: IType; value: String): Variant; overload;
		{ class } function Parse(TEnum: PTypeInfo; value: String; ignoreCase: Boolean): Variant{TEnum}; overload;
		{ class } function Parse(enumType: IType; value: String; ignoreCase: Boolean): Variant; overload;
		{ class } function Parse(TEnum: PTypeInfo; value: String): Variant{TEnum}; overload;
		{ class } function ToObject(enumType: IType; value: Byte): Variant; overload;
		{ class } function ToObject(enumType: IType; value: Word): Variant; overload;
		{ class } function ToObject(enumType: IType; value: longword): Variant; overload;
		{ class } function ToObject(enumType: IType; value: Int64): Variant; overload;
		{ class } function ToObject(enumType: IType; value: UInt64): Variant; overload;
		{ class } function ToObject(enumType: IType; value: Variant): Variant; overload;
		{ class } function ToObject(enumType: IType; value: Shortint): Variant; overload;
		{ class } function ToObject(enumType: IType; value: SmallInt): Variant; overload;
		{ class } function ToObject(enumType: IType; value: Integer): Variant; overload;
		{ class } function TryParse(enumType: IType; value: String; var result_: Variant): Boolean; overload;
		{ class } function TryParse(TEnum: PTypeInfo; value: String; ignoreCase: Boolean; var result_: Variant{TEnum}): Boolean; overload;
		{ class } function TryParse(enumType: IType; value: String; ignoreCase: Boolean; var result_: Variant): Boolean; overload;
		{ class } function TryParse(TEnum: PTypeInfo; value: String; var result_: Variant{TEnum}): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_ENUM)]
	IEnum = interface(IValueType)
	['{3D2934E7-B757-427A-9C91-51EDB10FA69B}']
	{ public }
		function CompareTo(target: Variant): Integer;
		function GetTypeCode(): TTypeCode;
		function HasFlag(flag: IEnum): Boolean;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
	end;

	ITypeClass = interface(ICoreClrClass)
	['{E07A3537-2D2E-42E7-A4D4-28B28EF447D6}']
	{ private }
		{ class } function _GetFld_Delimiter: Char;
		{ class } function _GetFld_EmptyTypes: ICoreClrBridgeArray<IType>;
		{ class } function _GetFld_Missing: Variant;
		{ class } function _GetProp_DefaultBinder: IBinder;
	{ public }
		{ class } function GetType(typeName: String; throwOnError: Boolean; ignoreCase: Boolean): IType; overload;
		{ class } function GetType(typeName: String; assemblyResolver: TClrFunc<IAssemblyName, IAssembly>; typeResolver: TClrFunc<IAssembly, String, Boolean, IType>): IType; overload;
		{ class } function GetType(typeName: String; throwOnError: Boolean): IType; overload;
		{ class } function GetType(typeName: String): IType; overload;
		{ class } function GetType(typeName: String; assemblyResolver: TClrFunc<IAssemblyName, IAssembly>; typeResolver: TClrFunc<IAssembly, String, Boolean, IType>; throwOnError: Boolean): IType; overload;
		{ class } function GetType(typeName: String; assemblyResolver: TClrFunc<IAssemblyName, IAssembly>; typeResolver: TClrFunc<IAssembly, String, Boolean, IType>; throwOnError: Boolean; ignoreCase: Boolean): IType; overload;
		{ class } function GetTypeArray(args: TArray<Variant>): TArray<IType>;
		{ class } function GetTypeCode(type_: IType): TTypeCode;
		{ class } function GetTypeFromCLSID(clsid: IGuid): IType; overload;
		{ class } function GetTypeFromCLSID(clsid: IGuid; throwOnError: Boolean): IType; overload;
		{ class } function GetTypeFromCLSID(clsid: IGuid; server: String): IType; overload;
		{ class } function GetTypeFromCLSID(clsid: IGuid; server: String; throwOnError: Boolean): IType; overload;
		{ class } function GetTypeFromHandle(handle: IRuntimeTypeHandle): IType;
		{ class } function GetTypeFromProgID(progID: String): IType; overload;
		{ class } function GetTypeFromProgID(progID: String; throwOnError: Boolean): IType; overload;
		{ class } function GetTypeFromProgID(progID: String; server: String): IType; overload;
		{ class } function GetTypeFromProgID(progID: String; server: String; throwOnError: Boolean): IType; overload;
		{ class } function GetTypeHandle(o: Variant): IRuntimeTypeHandle;
		{ class } function MakeGenericMethodParameter(position: Integer): IType;
		{ class } function MakeGenericSignatureType(genericTypeDefinition: IType; typeArguments: ICoreClrBridgeArray<IType>): IType;
		{ class } function ReflectionOnlyGetType(typeName: String; throwIfNotFound: Boolean; ignoreCase: Boolean): IType;
		{ class } property Delimiter: Char read _GetFld_Delimiter;
		{ class } property EmptyTypes: ICoreClrBridgeArray<IType> read _GetFld_EmptyTypes;
		{ class } property Missing: Variant read _GetFld_Missing;
		{ class } property DefaultBinder: IBinder read _GetProp_DefaultBinder;
	end;

	[CoreTypeSignature(SYSTEM_TYPE_)]
	IType = interface(IMemberInfo)
	['{D89C7A0F-B1DD-4337-BA91-DC8B180A013D}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_AssemblyQualifiedName: String;
		function _GetProp_Attributes: TTypeAttributes_Set;
		function _GetProp_BaseType: IType;
		function _GetProp_ContainsGenericParameters: Boolean;
		function _GetProp_DeclaringMethod: IMethodBase;
		function _GetProp_DeclaringType: IType;
		function _GetProp_FullName: String;
		function _GetProp_GenericParameterAttributes: TGenericParameterAttributes_Set;
		function _GetProp_GenericParameterPosition: Integer;
		function _GetProp_GenericTypeArguments: ICoreClrBridgeArray<IType>;
		function _GetProp_GUID: IGuid;
		function _GetProp_HasElementType: Boolean;
		function _GetProp_IsAbstract: Boolean;
		function _GetProp_IsAnsiClass: Boolean;
		function _GetProp_IsArray: Boolean;
		function _GetProp_IsAutoClass: Boolean;
		function _GetProp_IsAutoLayout: Boolean;
		function _GetProp_IsByRef: Boolean;
		function _GetProp_IsByRefLike: Boolean;
		function _GetProp_IsClass: Boolean;
		function _GetProp_IsCOMObject: Boolean;
		function _GetProp_IsConstructedGenericType: Boolean;
		function _GetProp_IsContextful: Boolean;
		function _GetProp_IsEnum: Boolean;
		function _GetProp_IsExplicitLayout: Boolean;
		function _GetProp_IsGenericMethodParameter: Boolean;
		function _GetProp_IsGenericParameter: Boolean;
		function _GetProp_IsGenericType: Boolean;
		function _GetProp_IsGenericTypeDefinition: Boolean;
		function _GetProp_IsGenericTypeParameter: Boolean;
		function _GetProp_IsImport: Boolean;
		function _GetProp_IsInterface: Boolean;
		function _GetProp_IsLayoutSequential: Boolean;
		function _GetProp_IsMarshalByRef: Boolean;
		function _GetProp_IsNested: Boolean;
		function _GetProp_IsNestedAssembly: Boolean;
		function _GetProp_IsNestedFamANDAssem: Boolean;
		function _GetProp_IsNestedFamily: Boolean;
		function _GetProp_IsNestedFamORAssem: Boolean;
		function _GetProp_IsNestedPrivate: Boolean;
		function _GetProp_IsNestedPublic: Boolean;
		function _GetProp_IsNotPublic: Boolean;
		function _GetProp_IsPointer: Boolean;
		function _GetProp_IsPrimitive: Boolean;
		function _GetProp_IsPublic: Boolean;
		function _GetProp_IsSealed: Boolean;
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_IsSerializable: Boolean;
		function _GetProp_IsSignatureType: Boolean;
		function _GetProp_IsSpecialName: Boolean;
		function _GetProp_IsSZArray: Boolean;
		function _GetProp_IsTypeDefinition: Boolean;
		function _GetProp_IsUnicodeClass: Boolean;
		function _GetProp_IsValueType: Boolean;
		function _GetProp_IsVariableBoundArray: Boolean;
		function _GetProp_IsVisible: Boolean;
		function _GetProp_MemberType: TMemberTypes_Set;
		function _GetProp_Module: IModule;
		function _GetProp_Namespace: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_StructLayoutAttribute: IStructLayoutAttribute;
		function _GetProp_TypeHandle: IRuntimeTypeHandle;
		function _GetProp_TypeInitializer: IConstructorInfo;
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		function Equals(o: IType): Boolean;
		function FindInterfaces(filter: TTypeFilter; filterCriteria: Variant): TArray<IType>;
		function FindMembers(memberType: TMemberTypes_Set; bindingAttr: TBindingFlags_Set; filter: TMemberFilter; filterCriteria: Variant): TArray<IMemberInfo>;
		function GetArrayRank(): Integer;
		function GetConstructor(types: ICoreClrBridgeArray<IType>): IConstructorInfo; overload;
		function GetConstructor(bindingAttr: TBindingFlags_Set; binder: IBinder; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IConstructorInfo; overload;
		function GetConstructor(bindingAttr: TBindingFlags_Set; binder: IBinder; callConvention: TCallingConventions_Set; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IConstructorInfo; overload;
		function GetConstructors(): TArray<IConstructorInfo>; overload;
		function GetConstructors(bindingAttr: TBindingFlags_Set): TArray<IConstructorInfo>; overload;
		function GetDefaultMembers(): TArray<IMemberInfo>;
		function GetElementType(): IType;
		function GetEnumName(value: Variant): String;
		function GetEnumNames(): TArray<String>;
		function GetEnumUnderlyingType(): IType;
		function GetEnumValues(): IArray;
		function GetEvent(name: String): IEventInfo; overload;
		function GetEvent(name: String; bindingAttr: TBindingFlags_Set): IEventInfo; overload;
		function GetEvents(bindingAttr: TBindingFlags_Set): TArray<IEventInfo>; overload;
		function GetEvents(): TArray<IEventInfo>; overload;
		function GetField(name: String): IFieldInfo; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo; overload;
		function GetFields(): TArray<IFieldInfo>; overload;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>; overload;
		function GetGenericArguments(): TArray<IType>;
		function GetGenericParameterConstraints(): TArray<IType>;
		function GetGenericTypeDefinition(): IType;
		function GetInterface(name: String): IType; overload;
		function GetInterface(name: String; ignoreCase: Boolean): IType; overload;
		function GetInterfaceMap(interfaceType: IType): IInterfaceMapping;
		function GetInterfaces(): TArray<IType>;
		function GetMember(name: String): TArray<IMemberInfo>; overload;
		function GetMember(name: String; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>; overload;
		function GetMember(name: String; type_: TMemberTypes_Set; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>; overload;
		function GetMembers(): TArray<IMemberInfo>; overload;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>; overload;
		function GetMethod(name: String): IMethodInfo; overload;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set): IMethodInfo; overload;
		function GetMethod(name: String; types: ICoreClrBridgeArray<IType>): IMethodInfo; overload;
		function GetMethod(name: String; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; genericParameterCount: Integer; types: ICoreClrBridgeArray<IType>): IMethodInfo; overload;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; callConvention: TCallingConventions_Set; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; genericParameterCount: Integer; bindingAttr: TBindingFlags_Set; binder: IBinder; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; genericParameterCount: Integer; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; genericParameterCount: Integer; bindingAttr: TBindingFlags_Set; binder: IBinder; callConvention: TCallingConventions_Set; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethods(): TArray<IMethodInfo>; overload;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>; overload;
		function GetNestedType(name: String): IType; overload;
		function GetNestedType(name: String; bindingAttr: TBindingFlags_Set): IType; overload;
		function GetNestedTypes(): TArray<IType>; overload;
		function GetNestedTypes(bindingAttr: TBindingFlags_Set): TArray<IType>; overload;
		function GetProperties(): TArray<IPropertyInfo>; overload;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>; overload;
		function GetProperty(name: String): IPropertyInfo; overload;
		function GetProperty(name: String; bindingAttr: TBindingFlags_Set): IPropertyInfo; overload;
		function GetProperty(name: String; returnType: IType): IPropertyInfo; overload;
		function GetProperty(name: String; types: ICoreClrBridgeArray<IType>): IPropertyInfo; overload;
		function GetProperty(name: String; returnType: IType; types: ICoreClrBridgeArray<IType>): IPropertyInfo; overload;
		function GetProperty(name: String; returnType: IType; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IPropertyInfo; overload;
		function GetProperty(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; returnType: IType; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IPropertyInfo; overload;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>): Variant; overload;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant; overload;
		function IsAssignableFrom(c: IType): Boolean;
		function IsAssignableTo(targetType: IType): Boolean;
		function IsEnumDefined(value: Variant): Boolean;
		function IsEquivalentTo(other: IType): Boolean;
		function IsInstanceOfType(o: Variant): Boolean;
		function IsSubclassOf(c: IType): Boolean;
		function MakeArrayType(): IType; overload;
		function MakeArrayType(rank: Integer): IType; overload;
		function MakeByRefType(): IType;
		function MakeGenericType(typeArguments: ICoreClrBridgeArray<IType>): IType;
		function MakePointerType(): IType;
		property Assembly: IAssembly read _GetProp_Assembly;
		property AssemblyQualifiedName: String read _GetProp_AssemblyQualifiedName;
		property Attributes: TTypeAttributes_Set read _GetProp_Attributes;
		property BaseType: IType read _GetProp_BaseType;
		property ContainsGenericParameters: Boolean read _GetProp_ContainsGenericParameters;
		property DeclaringMethod: IMethodBase read _GetProp_DeclaringMethod;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property FullName: String read _GetProp_FullName;
		property GenericParameterAttributes: TGenericParameterAttributes_Set read _GetProp_GenericParameterAttributes;
		property GenericParameterPosition: Integer read _GetProp_GenericParameterPosition;
		property GenericTypeArguments: ICoreClrBridgeArray<IType> read _GetProp_GenericTypeArguments;
		property GUID: IGuid read _GetProp_GUID;
		property HasElementType: Boolean read _GetProp_HasElementType;
		property IsAbstract: Boolean read _GetProp_IsAbstract;
		property IsAnsiClass: Boolean read _GetProp_IsAnsiClass;
		property IsArray: Boolean read _GetProp_IsArray;
		property IsAutoClass: Boolean read _GetProp_IsAutoClass;
		property IsAutoLayout: Boolean read _GetProp_IsAutoLayout;
		property IsByRef: Boolean read _GetProp_IsByRef;
		property IsByRefLike: Boolean read _GetProp_IsByRefLike;
		property IsClass: Boolean read _GetProp_IsClass;
		property IsCOMObject: Boolean read _GetProp_IsCOMObject;
		property IsConstructedGenericType: Boolean read _GetProp_IsConstructedGenericType;
		property IsContextful: Boolean read _GetProp_IsContextful;
		property IsEnum: Boolean read _GetProp_IsEnum;
		property IsExplicitLayout: Boolean read _GetProp_IsExplicitLayout;
		property IsGenericMethodParameter: Boolean read _GetProp_IsGenericMethodParameter;
		property IsGenericParameter: Boolean read _GetProp_IsGenericParameter;
		property IsGenericType: Boolean read _GetProp_IsGenericType;
		property IsGenericTypeDefinition: Boolean read _GetProp_IsGenericTypeDefinition;
		property IsGenericTypeParameter: Boolean read _GetProp_IsGenericTypeParameter;
		property IsImport: Boolean read _GetProp_IsImport;
		property IsInterface: Boolean read _GetProp_IsInterface;
		property IsLayoutSequential: Boolean read _GetProp_IsLayoutSequential;
		property IsMarshalByRef: Boolean read _GetProp_IsMarshalByRef;
		property IsNested: Boolean read _GetProp_IsNested;
		property IsNestedAssembly: Boolean read _GetProp_IsNestedAssembly;
		property IsNestedFamANDAssem: Boolean read _GetProp_IsNestedFamANDAssem;
		property IsNestedFamily: Boolean read _GetProp_IsNestedFamily;
		property IsNestedFamORAssem: Boolean read _GetProp_IsNestedFamORAssem;
		property IsNestedPrivate: Boolean read _GetProp_IsNestedPrivate;
		property IsNestedPublic: Boolean read _GetProp_IsNestedPublic;
		property IsNotPublic: Boolean read _GetProp_IsNotPublic;
		property IsPointer: Boolean read _GetProp_IsPointer;
		property IsPrimitive: Boolean read _GetProp_IsPrimitive;
		property IsPublic: Boolean read _GetProp_IsPublic;
		property IsSealed: Boolean read _GetProp_IsSealed;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property IsSerializable: Boolean read _GetProp_IsSerializable;
		property IsSignatureType: Boolean read _GetProp_IsSignatureType;
		property IsSpecialName: Boolean read _GetProp_IsSpecialName;
		property IsSZArray: Boolean read _GetProp_IsSZArray;
		property IsTypeDefinition: Boolean read _GetProp_IsTypeDefinition;
		property IsUnicodeClass: Boolean read _GetProp_IsUnicodeClass;
		property IsValueType: Boolean read _GetProp_IsValueType;
		property IsVariableBoundArray: Boolean read _GetProp_IsVariableBoundArray;
		property IsVisible: Boolean read _GetProp_IsVisible;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
		property Module: IModule read _GetProp_Module;
		property Namespace: String read _GetProp_Namespace;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property StructLayoutAttribute: IStructLayoutAttribute read _GetProp_StructLayoutAttribute;
		property TypeHandle: IRuntimeTypeHandle read _GetProp_TypeHandle;
		property TypeInitializer: IConstructorInfo read _GetProp_TypeInitializer;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_TYPEINFO)]
	ITypeInfo = interface(IType)
	['{B91AFB1F-3A2A-44D7-B6C9-0B378A32CB72}']
	{ private }
		function _GetProp_DeclaredConstructors: IIEnumerable<IConstructorInfo>;
		function _GetProp_DeclaredEvents: IIEnumerable<IEventInfo>;
		function _GetProp_DeclaredFields: IIEnumerable<IFieldInfo>;
		function _GetProp_DeclaredMembers: IIEnumerable<IMemberInfo>;
		function _GetProp_DeclaredMethods: IIEnumerable<IMethodInfo>;
		function _GetProp_DeclaredNestedTypes: IIEnumerable<ITypeInfo>;
		function _GetProp_DeclaredProperties: IIEnumerable<IPropertyInfo>;
		function _GetProp_GenericTypeParameters: ICoreClrBridgeArray<IType>;
		function _GetProp_ImplementedInterfaces: IIEnumerable<IType>;
	{ public }
		function AsType(): IType;
		function GetDeclaredEvent(name: String): IEventInfo;
		function GetDeclaredField(name: String): IFieldInfo;
		function GetDeclaredMethod(name: String): IMethodInfo;
		function GetDeclaredMethods(name: String): IIEnumerable<IMethodInfo>;
		function GetDeclaredNestedType(name: String): ITypeInfo;
		function GetDeclaredProperty(name: String): IPropertyInfo;
		function IsAssignableFrom(typeInfo: ITypeInfo): Boolean;
		property DeclaredConstructors: IIEnumerable<IConstructorInfo> read _GetProp_DeclaredConstructors;
		property DeclaredEvents: IIEnumerable<IEventInfo> read _GetProp_DeclaredEvents;
		property DeclaredFields: IIEnumerable<IFieldInfo> read _GetProp_DeclaredFields;
		property DeclaredMembers: IIEnumerable<IMemberInfo> read _GetProp_DeclaredMembers;
		property DeclaredMethods: IIEnumerable<IMethodInfo> read _GetProp_DeclaredMethods;
		property DeclaredNestedTypes: IIEnumerable<ITypeInfo> read _GetProp_DeclaredNestedTypes;
		property DeclaredProperties: IIEnumerable<IPropertyInfo> read _GetProp_DeclaredProperties;
		property GenericTypeParameters: ICoreClrBridgeArray<IType> read _GetProp_GenericTypeParameters;
		property ImplementedInterfaces: IIEnumerable<IType> read _GetProp_ImplementedInterfaces;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_ENUMBUILDER)]
	IEnumBuilder = interface(ITypeInfo)
	['{A47FD7EF-B2BB-4204-8E03-F2194122478A}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_AssemblyQualifiedName: String;
		function _GetProp_BaseType: IType;
		function _GetProp_DeclaringType: IType;
		function _GetProp_FullName: String;
		function _GetProp_GUID: IGuid;
		function _GetProp_IsByRefLike: Boolean;
		function _GetProp_IsConstructedGenericType: Boolean;
		function _GetProp_IsSZArray: Boolean;
		function _GetProp_IsTypeDefinition: Boolean;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_Namespace: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_TypeHandle: IRuntimeTypeHandle;
		function _GetProp_TypeToken: ITypeToken;
		function _GetProp_UnderlyingField: IFieldBuilder;
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		function CreateType(): IType;
		function CreateTypeInfo(): ITypeInfo;
		function DefineLiteral(literalName: String; literalValue: Variant): IFieldBuilder;
		function GetConstructors(bindingAttr: TBindingFlags_Set): TArray<IConstructorInfo>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetElementType(): IType;
		function GetEnumUnderlyingType(): IType;
		function GetEvent(name: String; bindingAttr: TBindingFlags_Set): IEventInfo;
		function GetEvents(): TArray<IEventInfo>; overload;
		function GetEvents(bindingAttr: TBindingFlags_Set): TArray<IEventInfo>; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetInterface(name: String; ignoreCase: Boolean): IType;
		function GetInterfaceMap(interfaceType: IType): IInterfaceMapping;
		function GetInterfaces(): TArray<IType>;
		function GetMember(name: String; type_: TMemberTypes_Set; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetNestedType(name: String; bindingAttr: TBindingFlags_Set): IType;
		function GetNestedTypes(bindingAttr: TBindingFlags_Set): TArray<IType>;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant;
		function IsAssignableFrom(typeInfo: ITypeInfo): Boolean;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function MakeArrayType(): IType; overload;
		function MakeArrayType(rank: Integer): IType; overload;
		function MakeByRefType(): IType;
		function MakePointerType(): IType;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		property Assembly: IAssembly read _GetProp_Assembly;
		property AssemblyQualifiedName: String read _GetProp_AssemblyQualifiedName;
		property BaseType: IType read _GetProp_BaseType;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property FullName: String read _GetProp_FullName;
		property GUID: IGuid read _GetProp_GUID;
		property IsByRefLike: Boolean read _GetProp_IsByRefLike;
		property IsConstructedGenericType: Boolean read _GetProp_IsConstructedGenericType;
		property IsSZArray: Boolean read _GetProp_IsSZArray;
		property IsTypeDefinition: Boolean read _GetProp_IsTypeDefinition;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property Namespace: String read _GetProp_Namespace;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property TypeHandle: IRuntimeTypeHandle read _GetProp_TypeHandle;
		property TypeToken: ITypeToken read _GetProp_TypeToken;
		property UnderlyingField: IFieldBuilder read _GetProp_UnderlyingField;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMEQUALITYCOMPARER_1)]
	IEnumEqualityComparer<T> = interface(IEqualityComparer<T>)
	['{8BD26A06-9AC1-402B-A7C5-9C267BA3DEA7}']
	{ public }
		function Equals(x: T; y: T): Boolean;
		function GetHashCode(obj: T): Integer;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_4)]
	IHashSet_Enumerator<T> = interface(IValueType)
	['{A102EDD6-0854-4522-AB86-231BEB47EB4E}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_5)]
	IList_Enumerator<T> = interface(IValueType)
	['{B5C91BE3-811F-41B9-A023-38A5C0A8E7B7}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		procedure Dispose();
		function MoveNext(): Boolean;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_ENUMERATOR_2)]
	IReadOnlySpan_Enumerator<T> = interface(IValueType)
	['{6DCB8BBA-D06E-46CD-BA0A-5322324891FD}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		function MoveNext(): Boolean;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_ENUMERATOR_3)]
	ISpan_Enumerator<T> = interface(IValueType)
	['{25B9D63A-0769-4F7F-AF86-09A34D1EFA60}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		function MoveNext(): Boolean;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ENUMERATORCANCELLATIONATTRIBUTE)]
	IEnumeratorCancellationAttribute = interface(IAttribute)
	['{5EDFBFD7-EEA1-4BB7-8E1D-80F0617BF025}']
	end;

	IEnvironmentClass = interface(ICoreClrClass)
	['{DA86C914-A762-4F0F-B87B-456D3300953F}']
	{ private }
		{ class } function _GetProp_CommandLine: String;
		{ class } function _GetProp_CurrentDirectory: String;
		{ class } procedure _SetProp_CurrentDirectory(Value: String);
		{ class } function _GetProp_CurrentManagedThreadId: Integer;
		{ class } function _GetProp_ExitCode: Integer;
		{ class } procedure _SetProp_ExitCode(Value: Integer);
		{ class } function _GetProp_HasShutdownStarted: Boolean;
		{ class } function _GetProp_Is64BitOperatingSystem: Boolean;
		{ class } function _GetProp_Is64BitProcess: Boolean;
		{ class } function _GetProp_MachineName: String;
		{ class } function _GetProp_NewLine: String;
		{ class } function _GetProp_OSVersion: IOperatingSystem;
		{ class } function _GetProp_ProcessId: Integer;
		{ class } function _GetProp_ProcessorCount: Integer;
		{ class } function _GetProp_StackTrace: String;
		{ class } function _GetProp_SystemDirectory: String;
		{ class } function _GetProp_SystemPageSize: Integer;
		{ class } function _GetProp_TickCount: Integer;
		{ class } function _GetProp_TickCount64: Int64;
		{ class } function _GetProp_UserDomainName: String;
		{ class } function _GetProp_UserInteractive: Boolean;
		{ class } function _GetProp_UserName: String;
		{ class } function _GetProp_Version: IVersion;
		{ class } function _GetProp_WorkingSet: Int64;
	{ public }
		{ class } procedure Exit(exitCode: Integer);
		{ class } function ExpandEnvironmentVariables(name: String): String;
		{ class } procedure FailFast(message: String); overload;
		{ class } procedure FailFast(message: String; exception: IException); overload;
		{ class } procedure FailFast(message: String; exception: IException; errorMessage: String); overload;
		{ class } function GetCommandLineArgs(): TArray<String>;
		{ class } function GetEnvironmentVariable(variable: String): String; overload;
		{ class } function GetEnvironmentVariable(variable: String; target: TEnvironmentVariableTarget): String; overload;
		{ class } function GetEnvironmentVariables(target: TEnvironmentVariableTarget): IIDictionary; overload;
		{ class } function GetEnvironmentVariables(): IIDictionary; overload;
		{ class } function GetFolderPath(folder: TSpecialFolder): String; overload;
		{ class } function GetFolderPath(folder: TSpecialFolder; option: TSpecialFolderOption): String; overload;
		{ class } function GetLogicalDrives(): TArray<String>;
		{ class } procedure SetEnvironmentVariable(variable: String; value: String); overload;
		{ class } procedure SetEnvironmentVariable(variable: String; value: String; target: TEnvironmentVariableTarget); overload;
		{ class } property CommandLine: String read _GetProp_CommandLine;
		{ class } property CurrentDirectory: String read _GetProp_CurrentDirectory write _SetProp_CurrentDirectory;
		{ class } property CurrentManagedThreadId: Integer read _GetProp_CurrentManagedThreadId;
		{ class } property ExitCode: Integer read _GetProp_ExitCode write _SetProp_ExitCode;
		{ class } property HasShutdownStarted: Boolean read _GetProp_HasShutdownStarted;
		{ class } property Is64BitOperatingSystem: Boolean read _GetProp_Is64BitOperatingSystem;
		{ class } property Is64BitProcess: Boolean read _GetProp_Is64BitProcess;
		{ class } property MachineName: String read _GetProp_MachineName;
		{ class } property NewLine: String read _GetProp_NewLine;
		{ class } property OSVersion: IOperatingSystem read _GetProp_OSVersion;
		{ class } property ProcessId: Integer read _GetProp_ProcessId;
		{ class } property ProcessorCount: Integer read _GetProp_ProcessorCount;
		{ class } property StackTrace: String read _GetProp_StackTrace;
		{ class } property SystemDirectory: String read _GetProp_SystemDirectory;
		{ class } property SystemPageSize: Integer read _GetProp_SystemPageSize;
		{ class } property TickCount: Integer read _GetProp_TickCount;
		{ class } property TickCount64: Int64 read _GetProp_TickCount64;
		{ class } property UserDomainName: String read _GetProp_UserDomainName;
		{ class } property UserInteractive: Boolean read _GetProp_UserInteractive;
		{ class } property UserName: String read _GetProp_UserName;
		{ class } property Version: IVersion read _GetProp_Version;
		{ class } property WorkingSet: Int64 read _GetProp_WorkingSet;
	end;

	[CoreTypeSignature(SYSTEM_ENVIRONMENT)]
	IEnvironment = interface(IObject)
	['{9F9C46D3-5A13-4CEC-941F-25BC3B269D5A}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ERRORWRAPPER)]
	IErrorWrapper = interface(IObject)
	['{F2137FCE-2032-400A-A0A4-C26A6F2A9E3E}']
	{ private }
		function _GetProp_ErrorCode: Integer;
	{ public }
		property ErrorCode: Integer read _GetProp_ErrorCode;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTATTRIBUTE)]
	IEventAttribute = interface(IAttribute)
	['{B7D1BCF1-8556-4DB1-AC3E-B59CFB6EDF68}']
	{ private }
		function _GetProp_ActivityOptions: TEventActivityOptions_Set;
		procedure _SetProp_ActivityOptions(Value: TEventActivityOptions_Set);
		function _GetProp_Channel: TEventChannel;
		procedure _SetProp_Channel(Value: TEventChannel);
		function _GetProp_EventId: Integer;
		function _GetProp_Keywords: TEventKeywords_Set;
		procedure _SetProp_Keywords(Value: TEventKeywords_Set);
		function _GetProp_Level: TEventLevel;
		procedure _SetProp_Level(Value: TEventLevel);
		function _GetProp_Message: String;
		procedure _SetProp_Message(Value: String);
		function _GetProp_Opcode: TEventOpcode;
		procedure _SetProp_Opcode(Value: TEventOpcode);
		function _GetProp_Tags: TEventTags_Set;
		procedure _SetProp_Tags(Value: TEventTags_Set);
		function _GetProp_Task: TEventTask;
		procedure _SetProp_Task(Value: TEventTask);
		function _GetProp_Version: Byte;
		procedure _SetProp_Version(Value: Byte);
	{ public }
		property ActivityOptions: TEventActivityOptions_Set read _GetProp_ActivityOptions write _SetProp_ActivityOptions;
		property Channel: TEventChannel read _GetProp_Channel write _SetProp_Channel;
		property EventId: Integer read _GetProp_EventId;
		property Keywords: TEventKeywords_Set read _GetProp_Keywords write _SetProp_Keywords;
		property Level: TEventLevel read _GetProp_Level write _SetProp_Level;
		property Message: String read _GetProp_Message write _SetProp_Message;
		property Opcode: TEventOpcode read _GetProp_Opcode write _SetProp_Opcode;
		property Tags: TEventTags_Set read _GetProp_Tags write _SetProp_Tags;
		property Task: TEventTask read _GetProp_Task write _SetProp_Task;
		property Version: Byte read _GetProp_Version write _SetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_EVENTBUILDER)]
	IEventBuilder = interface(IObject)
	['{C78918FE-6987-4ACF-9F54-023CE08261DA}']
	{ public }
		procedure AddOtherMethod(mdBuilder: IMethodBuilder);
		function GetEventToken(): IEventToken;
		procedure SetAddOnMethod(mdBuilder: IMethodBuilder);
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetRaiseMethod(mdBuilder: IMethodBuilder);
		procedure SetRemoveOnMethod(mdBuilder: IMethodBuilder);
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTCOMMANDEVENTARGS)]
	IEventCommandEventArgs = interface(IEventArgs)
	['{F3B7DD96-7EB4-4490-9EBD-8596EF416997}']
	{ private }
		function _GetProp_Arguments: IIDictionary<String, String>;
		function _GetProp_Command: TEventCommand;
	{ public }
		function DisableEvent(eventId: Integer): Boolean;
		function EnableEvent(eventId: Integer): Boolean;
		property Arguments: IIDictionary<String, String> read _GetProp_Arguments;
		property Command: TEventCommand read _GetProp_Command;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTCOUNTER)]
	IEventCounter = interface(IDiagnosticCounter)
	['{2E258D39-99E9-41C8-9C05-7F596297C0AF}']
	{ public }
		procedure WriteMetric(value: Single); overload;
		procedure WriteMetric(value: Double); overload;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTDATA)]
	IEventData = interface(IValueType)
	['{02603499-D770-4338-977F-9EA1F5D7D785}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTDATAATTRIBUTE)]
	IEventDataAttribute = interface(IAttribute)
	['{F833B7EA-DA0B-469D-BC0F-7425997134C2}']
	{ private }
		function _GetProp_Name: String;
		procedure _SetProp_Name(Value: String);
	{ public }
		property Name: String read _GetProp_Name write _SetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTFIELDATTRIBUTE)]
	IEventFieldAttribute = interface(IAttribute)
	['{9B7871B1-6C1F-47E6-AE31-EE015FF07408}']
	{ private }
		function _GetProp_Format: TEventFieldFormat;
		procedure _SetProp_Format(Value: TEventFieldFormat);
		function _GetProp_Tags: TEventFieldTags_Set;
		procedure _SetProp_Tags(Value: TEventFieldTags_Set);
	{ public }
		property Format: TEventFieldFormat read _GetProp_Format write _SetProp_Format;
		property Tags: TEventFieldTags_Set read _GetProp_Tags write _SetProp_Tags;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTIGNOREATTRIBUTE)]
	IEventIgnoreAttribute = interface(IAttribute)
	['{6A731898-EE56-441A-BDC7-069AB8EEAA79}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EVENTINFO)]
	IEventInfo = interface(IMemberInfo)
	['{4BACAEA9-AAA8-4F86-BB84-E53A250400E6}']
	{ private }
		function _GetProp_AddMethod: IMethodInfo;
		function _GetProp_Attributes: TEventAttributes_Set;
		function _GetProp_EventHandlerType: IType;
		function _GetProp_IsMulticast: Boolean;
		function _GetProp_IsSpecialName: Boolean;
		function _GetProp_MemberType: TMemberTypes_Set;
		function _GetProp_RaiseMethod: IMethodInfo;
		function _GetProp_RemoveMethod: IMethodInfo;
	{ public }
		procedure AddEventHandler(target: Variant; handler: IDelegate);
		function GetAddMethod(): IMethodInfo; overload;
		function GetAddMethod(nonPublic: Boolean): IMethodInfo; overload;
		function GetOtherMethods(): TArray<IMethodInfo>; overload;
		function GetOtherMethods(nonPublic: Boolean): TArray<IMethodInfo>; overload;
		function GetRaiseMethod(): IMethodInfo; overload;
		function GetRaiseMethod(nonPublic: Boolean): IMethodInfo; overload;
		function GetRemoveMethod(): IMethodInfo; overload;
		function GetRemoveMethod(nonPublic: Boolean): IMethodInfo; overload;
		procedure RemoveEventHandler(target: Variant; handler: IDelegate);
		property AddMethod: IMethodInfo read _GetProp_AddMethod;
		property Attributes: TEventAttributes_Set read _GetProp_Attributes;
		property EventHandlerType: IType read _GetProp_EventHandlerType;
		property IsMulticast: Boolean read _GetProp_IsMulticast;
		property IsSpecialName: Boolean read _GetProp_IsSpecialName;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
		property RaiseMethod: IMethodInfo read _GetProp_RaiseMethod;
		property RemoveMethod: IMethodInfo read _GetProp_RemoveMethod;
	end;

	IEventListenerClass = interface(ICoreClrClass)
	['{8447636A-89E1-45C8-92B0-26903DEC5111}']
	{ public }
		{ class } function EventSourceIndex(eventSource: IEventSource): Integer;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTLISTENER)]
	IEventListener = interface(IIDisposable)
	['{7E56D04A-B8BC-49BF-93DA-6F7F281F5741}']
	{ private }
		function _GetEvt_EventSourceCreated: TEventHandler<IEventSourceCreatedEventArgs>;
		procedure _SetEvt_EventSourceCreated(Value: TEventHandler<IEventSourceCreatedEventArgs>);
		function _GetEvt_EventWritten: TEventHandler<IEventWrittenEventArgs>;
		procedure _SetEvt_EventWritten(Value: TEventHandler<IEventWrittenEventArgs>);
	{ public }
		procedure DisableEvents(eventSource: IEventSource);
		procedure Dispose();
		procedure EnableEvents(eventSource: IEventSource; level: TEventLevel); overload;
		procedure EnableEvents(eventSource: IEventSource; level: TEventLevel; matchAnyKeyword: TEventKeywords_Set); overload;
		procedure EnableEvents(eventSource: IEventSource; level: TEventLevel; matchAnyKeyword: TEventKeywords_Set; arguments: IIDictionary<String, String>); overload;
		property EventSourceCreated: TEventHandler<IEventSourceCreatedEventArgs> read _GetEvt_EventSourceCreated write _SetEvt_EventSourceCreated;
		property EventWritten: TEventHandler<IEventWrittenEventArgs> read _GetEvt_EventWritten write _SetEvt_EventWritten;
	end;

	IEventSourceClass = interface(ICoreClrClass)
	['{48E3B839-D4B5-4D0F-9F72-0BAFEE770957}']
	{ private }
		{ class } function _GetProp_CurrentThreadActivityId: IGuid;
	{ public }
		{ class } function GenerateManifest(eventSourceType: IType; assemblyPathToIncludeInManifest: String): String; overload;
		{ class } function GenerateManifest(eventSourceType: IType; assemblyPathToIncludeInManifest: String; flags: TEventManifestOptions_Set): String; overload;
		{ class } function GetGuid(eventSourceType: IType): IGuid;
		{ class } function GetName(eventSourceType: IType): String;
		{ class } function GetSources(): IIEnumerable<IEventSource>;
		{ class } procedure SendCommand(eventSource: IEventSource; command: TEventCommand; commandArguments: IIDictionary<String, String>);
		{ class } procedure SetCurrentThreadActivityId(activityId: IGuid); overload;
		{ class } procedure SetCurrentThreadActivityId(activityId: IGuid; var oldActivityThatWillContinue: IGuid); overload;
		{ class } property CurrentThreadActivityId: IGuid read _GetProp_CurrentThreadActivityId;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTSOURCE)]
	IEventSource = interface(IIDisposable)
	['{891F6437-E3C1-4FCF-A2F7-E318E99B10D9}']
	{ private }
		function _GetProp_ConstructionException: IException;
		function _GetProp_Guid: IGuid;
		function _GetProp_Name: String;
		function _GetProp_Settings: TEventSourceSettings_Set;
		function _GetEvt_EventCommandExecuted: TEventHandler<IEventCommandEventArgs>;
		procedure _SetEvt_EventCommandExecuted(Value: TEventHandler<IEventCommandEventArgs>);
	{ public }
		procedure Dispose();
		function GetTrait(key: String): String;
		function IsEnabled(): Boolean; overload;
		function IsEnabled(level: TEventLevel; keywords: TEventKeywords_Set): Boolean; overload;
		function IsEnabled(level: TEventLevel; keywords: TEventKeywords_Set; channel: TEventChannel): Boolean; overload;
		procedure Write(eventName: String); overload;
		procedure Write(eventName: String; options: IEventSourceOptions); overload;
		procedure Write(T: PTypeInfo; eventName: String; data: Variant{T}); overload;
		procedure Write(T: PTypeInfo; eventName: String; options: IEventSourceOptions; data: Variant{T}); overload;
		procedure Write(T: PTypeInfo; eventName: String; var options: IEventSourceOptions; var activityId: IGuid; var relatedActivityId: IGuid; var data: Variant{T}); overload;
		property ConstructionException: IException read _GetProp_ConstructionException;
		property Guid: IGuid read _GetProp_Guid;
		property Name: String read _GetProp_Name;
		property Settings: TEventSourceSettings_Set read _GetProp_Settings;
		property EventCommandExecuted: TEventHandler<IEventCommandEventArgs> read _GetEvt_EventCommandExecuted write _SetEvt_EventCommandExecuted;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTSOURCEATTRIBUTE)]
	IEventSourceAttribute = interface(IAttribute)
	['{4E44E312-BC62-4D3B-AADD-6DE57BAD0900}']
	{ private }
		function _GetProp_Guid: String;
		procedure _SetProp_Guid(Value: String);
		function _GetProp_LocalizationResources: String;
		procedure _SetProp_LocalizationResources(Value: String);
		function _GetProp_Name: String;
		procedure _SetProp_Name(Value: String);
	{ public }
		property Guid: String read _GetProp_Guid write _SetProp_Guid;
		property LocalizationResources: String read _GetProp_LocalizationResources write _SetProp_LocalizationResources;
		property Name: String read _GetProp_Name write _SetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTSOURCECREATEDEVENTARGS)]
	IEventSourceCreatedEventArgs = interface(IEventArgs)
	['{CB0ABF13-C96A-46B3-8CB6-98238AA0B915}']
	{ private }
		function _GetProp_EventSource: IEventSource;
	{ public }
		property EventSource: IEventSource read _GetProp_EventSource;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTSOURCEEXCEPTION)]
	IEventSourceException = interface(IException)
	['{C0A10559-8D7D-48C8-9CF6-F50727B084D8}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTSOURCEOPTIONS)]
	IEventSourceOptions = interface(IValueType)
	['{43D0AC9C-83E2-4FDC-8F06-6DFAD1ABDB0A}']
	{ private }
		function _GetProp_ActivityOptions: TEventActivityOptions_Set;
		procedure _SetProp_ActivityOptions(Value: TEventActivityOptions_Set);
		function _GetProp_Keywords: TEventKeywords_Set;
		procedure _SetProp_Keywords(Value: TEventKeywords_Set);
		function _GetProp_Level: TEventLevel;
		procedure _SetProp_Level(Value: TEventLevel);
		function _GetProp_Opcode: TEventOpcode;
		procedure _SetProp_Opcode(Value: TEventOpcode);
		function _GetProp_Tags: TEventTags_Set;
		procedure _SetProp_Tags(Value: TEventTags_Set);
	{ public }
		property ActivityOptions: TEventActivityOptions_Set read _GetProp_ActivityOptions write _SetProp_ActivityOptions;
		property Keywords: TEventKeywords_Set read _GetProp_Keywords write _SetProp_Keywords;
		property Level: TEventLevel read _GetProp_Level write _SetProp_Level;
		property Opcode: TEventOpcode read _GetProp_Opcode write _SetProp_Opcode;
		property Tags: TEventTags_Set read _GetProp_Tags write _SetProp_Tags;
	end;

	IEventTokenClass = interface(ICoreClrClass)
	['{06DC0D40-DEF9-4D15-93A6-85F21F6CE664}']
	{ private }
		{ class } function _GetFld_Empty: IEventToken;
	{ public }
		{ class } property Empty: IEventToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_EVENTTOKEN)]
	IEventToken = interface(IValueType)
	['{933BACBD-06E2-48B1-A6D0-FDD3E76935AE}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IEventToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_EVENTWRITTENEVENTARGS)]
	IEventWrittenEventArgs = interface(IEventArgs)
	['{FE15578A-0818-4E15-A9FE-136E565D8370}']
	{ private }
		function _GetProp_ActivityId: IGuid;
		function _GetProp_Channel: TEventChannel;
		function _GetProp_EventId: Integer;
		function _GetProp_EventName: String;
		function _GetProp_EventSource: IEventSource;
		function _GetProp_Keywords: TEventKeywords_Set;
		function _GetProp_Level: TEventLevel;
		function _GetProp_Message: String;
		function _GetProp_Opcode: TEventOpcode;
		function _GetProp_OSThreadId: Int64;
		function _GetProp_Payload: IReadOnlyCollection<Variant>;
		function _GetProp_PayloadNames: IReadOnlyCollection<String>;
		function _GetProp_RelatedActivityId: IGuid;
		function _GetProp_Tags: TEventTags_Set;
		function _GetProp_Task: TEventTask;
		function _GetProp_TimeStamp: TDateTime;
		function _GetProp_Version: Byte;
	{ public }
		property ActivityId: IGuid read _GetProp_ActivityId;
		property Channel: TEventChannel read _GetProp_Channel;
		property EventId: Integer read _GetProp_EventId;
		property EventName: String read _GetProp_EventName;
		property EventSource: IEventSource read _GetProp_EventSource;
		property Keywords: TEventKeywords_Set read _GetProp_Keywords;
		property Level: TEventLevel read _GetProp_Level;
		property Message: String read _GetProp_Message;
		property Opcode: TEventOpcode read _GetProp_Opcode;
		property OSThreadId: Int64 read _GetProp_OSThreadId;
		property Payload: IReadOnlyCollection<Variant> read _GetProp_Payload;
		property PayloadNames: IReadOnlyCollection<String> read _GetProp_PayloadNames;
		property RelatedActivityId: IGuid read _GetProp_RelatedActivityId;
		property Tags: TEventTags_Set read _GetProp_Tags;
		property Task: TEventTask read _GetProp_Task;
		property TimeStamp: TDateTime read _GetProp_TimeStamp;
		property Version: Byte read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_EXCEPINFO)]
	IEXCEPINFO = interface(IValueType)
	['{B4CA0EE8-8BCF-4DE9-A5FA-19BC8836BF1A}']
	{ private }
		function _GetFld_bstrDescription: String;
		procedure _SetFld_bstrDescription(Value: String);
		function _GetFld_bstrHelpFile: String;
		procedure _SetFld_bstrHelpFile(Value: String);
		function _GetFld_bstrSource: String;
		procedure _SetFld_bstrSource(Value: String);
		function _GetFld_dwHelpContext: Integer;
		procedure _SetFld_dwHelpContext(Value: Integer);
		function _GetFld_pfnDeferredFillIn: IIntPtr;
		procedure _SetFld_pfnDeferredFillIn(Value: IIntPtr);
		function _GetFld_pvReserved: IIntPtr;
		procedure _SetFld_pvReserved(Value: IIntPtr);
		function _GetFld_scode: Integer;
		procedure _SetFld_scode(Value: Integer);
		function _GetFld_wCode: SmallInt;
		procedure _SetFld_wCode(Value: SmallInt);
		function _GetFld_wReserved: SmallInt;
		procedure _SetFld_wReserved(Value: SmallInt);
	{ public }
		property bstrDescription: String read _GetFld_bstrDescription write _SetFld_bstrDescription;
		property bstrHelpFile: String read _GetFld_bstrHelpFile write _SetFld_bstrHelpFile;
		property bstrSource: String read _GetFld_bstrSource write _SetFld_bstrSource;
		property dwHelpContext: Integer read _GetFld_dwHelpContext write _SetFld_dwHelpContext;
		property pfnDeferredFillIn: IIntPtr read _GetFld_pfnDeferredFillIn write _SetFld_pfnDeferredFillIn;
		property pvReserved: IIntPtr read _GetFld_pvReserved write _SetFld_pvReserved;
		property scode: Integer read _GetFld_scode write _SetFld_scode;
		property wCode: SmallInt read _GetFld_wCode write _SetFld_wCode;
		property wReserved: SmallInt read _GetFld_wReserved write _SetFld_wReserved;
	end;

	IExceptionDispatchInfoClass = interface(ICoreClrClass)
	['{576740EF-66D5-4EA5-AFF9-C96825299AD2}']
	{ public }
		{ class } function Capture(source: IException): IExceptionDispatchInfo;
		{ class } function SetCurrentStackTrace(source: IException): IException;
		{ class } procedure Throw(source: IException);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_EXCEPTIONSERVICES_EXCEPTIONDISPATCHINFO)]
	IExceptionDispatchInfo = interface(IObject)
	['{D1DAD4B8-58FB-413A-B0EB-48A6A6D516AE}']
	{ private }
		function _GetProp_SourceException: IException;
	{ public }
		procedure Throw();
		property SourceException: IException read _GetProp_SourceException;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EXCEPTIONHANDLINGCLAUSE)]
	IExceptionHandlingClause = interface(IObject)
	['{566165B1-D40E-4C67-8023-B1DC2EF757B3}']
	{ private }
		function _GetProp_CatchType: IType;
		function _GetProp_FilterOffset: Integer;
		function _GetProp_Flags: TExceptionHandlingClauseOptions_Set;
		function _GetProp_HandlerLength: Integer;
		function _GetProp_HandlerOffset: Integer;
		function _GetProp_TryLength: Integer;
		function _GetProp_TryOffset: Integer;
	{ public }
		property CatchType: IType read _GetProp_CatchType;
		property FilterOffset: Integer read _GetProp_FilterOffset;
		property Flags: TExceptionHandlingClauseOptions_Set read _GetProp_Flags;
		property HandlerLength: Integer read _GetProp_HandlerLength;
		property HandlerOffset: Integer read _GetProp_HandlerOffset;
		property TryLength: Integer read _GetProp_TryLength;
		property TryOffset: Integer read _GetProp_TryOffset;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_EXCLUDEFROMCODECOVERAGEATTRIBUTE)]
	IExcludeFromCodeCoverageAttribute = interface(IAttribute)
	['{41A79A87-0F71-4EB7-A8A5-807C10FCCE0B}']
	{ private }
		function _GetProp_Justification: String;
		procedure _SetProp_Justification(Value: String);
	{ public }
		property Justification: String read _GetProp_Justification write _SetProp_Justification;
	end;

	IExecutionContextClass = interface(ICoreClrClass)
	['{D222A74A-7089-454E-9652-12AE933F8B15}']
	{ public }
		{ class } function Capture(): IExecutionContext;
		{ class } function IsFlowSuppressed(): Boolean;
		{ class } procedure Restore(executionContext: IExecutionContext);
		{ class } procedure RestoreFlow();
		{ class } procedure Run(executionContext: IExecutionContext; callback: TContextCallback; state: Variant);
		{ class } function SuppressFlow(): IAsyncFlowControl;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_EXECUTIONCONTEXT)]
	IExecutionContext = interface(IObject)
	['{188BEA32-9598-40C7-A52D-2916F12151EB}']
	{ public }
		function CreateCopy(): IExecutionContext;
		procedure Dispose();
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_EXECUTIONENGINEEXCEPTION)]
	IExecutionEngineException = interface(ISystemException)
	['{27B5CF3E-C392-48BA-87DA-3931DA19041E}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_EXTENSIONATTRIBUTE)]
	IExtensionAttribute = interface(IAttribute)
	['{7F8F5B0F-2DB7-4151-B60E-9A234A36B3AE}']
	end;

	[CoreTypeSignature(SYSTEM_MEMBERACCESSEXCEPTION)]
	IMemberAccessException = interface(ISystemException)
	['{5A0B6A60-E521-42C9-8F39-677F1563C915}']
	end;

	[CoreTypeSignature(SYSTEM_FIELDACCESSEXCEPTION)]
	IFieldAccessException = interface(IMemberAccessException)
	['{BF3210FB-05A2-413C-88EC-2BE4280EFAA3}']
	end;

	IFieldInfoClass = interface(ICoreClrClass)
	['{C3916FDB-4E87-4F4D-AA6A-8C874BE4F919}']
	{ public }
		{ class } function GetFieldFromHandle(handle: IRuntimeFieldHandle): IFieldInfo; overload;
		{ class } function GetFieldFromHandle(handle: IRuntimeFieldHandle; declaringType: IRuntimeTypeHandle): IFieldInfo; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_FIELDINFO)]
	IFieldInfo = interface(IMemberInfo)
	['{B594489E-9A44-43B0-B938-C594ED8DEAC3}']
	{ private }
		function _GetProp_Attributes: TFieldAttributes_Set;
		function _GetProp_FieldHandle: IRuntimeFieldHandle;
		function _GetProp_FieldType: IType;
		function _GetProp_IsAssembly: Boolean;
		function _GetProp_IsFamily: Boolean;
		function _GetProp_IsFamilyAndAssembly: Boolean;
		function _GetProp_IsFamilyOrAssembly: Boolean;
		function _GetProp_IsInitOnly: Boolean;
		function _GetProp_IsLiteral: Boolean;
		function _GetProp_IsNotSerialized: Boolean;
		function _GetProp_IsPinvokeImpl: Boolean;
		function _GetProp_IsPrivate: Boolean;
		function _GetProp_IsPublic: Boolean;
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_IsSpecialName: Boolean;
		function _GetProp_IsStatic: Boolean;
		function _GetProp_MemberType: TMemberTypes_Set;
	{ public }
		function GetOptionalCustomModifiers(): TArray<IType>;
		function GetRawConstantValue(): Variant;
		function GetRequiredCustomModifiers(): TArray<IType>;
		function GetValue(obj: Variant): Variant;
		function GetValueDirect(obj: ITypedReference): Variant;
		procedure SetValue(obj: Variant; value: Variant); overload;
		procedure SetValue(obj: Variant; value: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; culture: ICultureInfo); overload;
		procedure SetValueDirect(obj: ITypedReference; value: Variant);
		property Attributes: TFieldAttributes_Set read _GetProp_Attributes;
		property FieldHandle: IRuntimeFieldHandle read _GetProp_FieldHandle;
		property FieldType: IType read _GetProp_FieldType;
		property IsAssembly: Boolean read _GetProp_IsAssembly;
		property IsFamily: Boolean read _GetProp_IsFamily;
		property IsFamilyAndAssembly: Boolean read _GetProp_IsFamilyAndAssembly;
		property IsFamilyOrAssembly: Boolean read _GetProp_IsFamilyOrAssembly;
		property IsInitOnly: Boolean read _GetProp_IsInitOnly;
		property IsLiteral: Boolean read _GetProp_IsLiteral;
		property IsNotSerialized: Boolean read _GetProp_IsNotSerialized;
		property IsPinvokeImpl: Boolean read _GetProp_IsPinvokeImpl;
		property IsPrivate: Boolean read _GetProp_IsPrivate;
		property IsPublic: Boolean read _GetProp_IsPublic;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property IsSpecialName: Boolean read _GetProp_IsSpecialName;
		property IsStatic: Boolean read _GetProp_IsStatic;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_FIELDBUILDER)]
	IFieldBuilder = interface(IFieldInfo)
	['{9BBE16A2-1A8D-43AA-9DDA-8154238AB4EB}']
	{ private }
		function _GetProp_Attributes: TFieldAttributes_Set;
		function _GetProp_DeclaringType: IType;
		function _GetProp_FieldHandle: IRuntimeFieldHandle;
		function _GetProp_FieldType: IType;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_ReflectedType: IType;
	{ public }
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetToken(): IFieldToken;
		function GetValue(obj: Variant): Variant;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		procedure SetConstant(defaultValue: Variant);
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetOffset(iOffset: Integer);
		procedure SetValue(obj: Variant; val: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; culture: ICultureInfo);
		property Attributes: TFieldAttributes_Set read _GetProp_Attributes;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property FieldHandle: IRuntimeFieldHandle read _GetProp_FieldHandle;
		property FieldType: IType read _GetProp_FieldType;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property ReflectedType: IType read _GetProp_ReflectedType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_FIELDOFFSETATTRIBUTE)]
	IFieldOffsetAttribute = interface(IAttribute)
	['{B0925815-C6AB-48CE-9DFD-E49537CEF923}']
	{ private }
		function _GetProp_Value: Integer;
	{ public }
		property Value: Integer read _GetProp_Value;
	end;

	IFieldTokenClass = interface(ICoreClrClass)
	['{F16DC4D4-7260-4155-ABD9-42BA2262A709}']
	{ private }
		{ class } function _GetFld_Empty: IFieldToken;
	{ public }
		{ class } property Empty: IFieldToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_FIELDTOKEN)]
	IFieldToken = interface(IValueType)
	['{FBC92646-C298-4D6B-9479-701249606E41}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IFieldToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_IO_FILELOADEXCEPTION)]
	IFileLoadException = interface(IIOException)
	['{9794207C-7E63-4FF4-B853-D99CF8F6BF4C}']
	{ private }
		function _GetProp_FileName: String;
		function _GetProp_FusionLog: String;
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property FileName: String read _GetProp_FileName;
		property FusionLog: String read _GetProp_FusionLog;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_IO_FILENOTFOUNDEXCEPTION)]
	IFileNotFoundException = interface(IIOException)
	['{1E5CC37E-6F29-445D-A123-78CCD6ABA92A}']
	{ private }
		function _GetProp_FileName: String;
		function _GetProp_FusionLog: String;
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property FileName: String read _GetProp_FileName;
		property FusionLog: String read _GetProp_FusionLog;
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_IO_FILESTREAM)]
	IFileStream = interface(IStream)
	['{383ECF2E-A72C-45F5-8CF9-87C5B0387BD6}']
	{ private }
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanSeek: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Handle: IIntPtr;
		function _GetProp_IsAsync: Boolean;
		function _GetProp_Length: Int64;
		function _GetProp_Name: String;
		function _GetProp_Position: Int64;
		procedure _SetProp_Position(Value: Int64);
		function _GetProp_SafeFileHandle: ISafeFileHandle;
	{ public }
		function BeginRead(array_: TArray<Byte>; offset: Integer; numBytes: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		function BeginWrite(array_: TArray<Byte>; offset: Integer; numBytes: Integer; callback: TAsyncCallback; state: Variant): IIAsyncResult;
		function CopyToAsync(destination: IStream; bufferSize: Integer; cancellationToken: ICancellationToken): ITask;
		function DisposeAsync(): IValueTask;
		function EndRead(asyncResult: IIAsyncResult): Integer;
		procedure EndWrite(asyncResult: IIAsyncResult);
		procedure Flush(); overload;
		procedure Flush(flushToDisk: Boolean); overload;
		function FlushAsync(cancellationToken: ICancellationToken): ITask;
		procedure Lock(position: Int64; length: Int64);
		function Read(array_: TArray<Byte>; offset: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Byte>): Integer; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Byte>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadByte(): Integer;
		function Seek(offset: Int64; origin: TSeekOrigin): Int64;
		procedure SetLength(value: Int64);
		procedure Unlock(position: Int64; length: Int64);
		procedure Write(array_: TArray<Byte>; offset: Integer; count: Integer); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Byte>; cancellationToken: ICancellationToken): IValueTask; overload;
		procedure WriteByte(value: Byte);
		property CanRead: Boolean read _GetProp_CanRead;
		property CanSeek: Boolean read _GetProp_CanSeek;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Handle: IIntPtr read _GetProp_Handle;
		property IsAsync: Boolean read _GetProp_IsAsync;
		property Length: Int64 read _GetProp_Length;
		property Name: String read _GetProp_Name;
		property Position: Int64 read _GetProp_Position write _SetProp_Position;
		property SafeFileHandle: ISafeFileHandle read _GetProp_SafeFileHandle;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_FILETIME)]
	IFILETIME = interface(IValueType)
	['{9041E51C-4539-4939-8590-E72AF4A415EB}']
	{ private }
		function _GetFld_dwHighDateTime: Integer;
		procedure _SetFld_dwHighDateTime(Value: Integer);
		function _GetFld_dwLowDateTime: Integer;
		procedure _SetFld_dwLowDateTime(Value: Integer);
	{ public }
		property dwHighDateTime: Integer read _GetFld_dwHighDateTime write _SetFld_dwHighDateTime;
		property dwLowDateTime: Integer read _GetFld_dwLowDateTime write _SetFld_dwLowDateTime;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_EXCEPTIONSERVICES_FIRSTCHANCEEXCEPTIONEVENTARGS)]
	IFirstChanceExceptionEventArgs = interface(IEventArgs)
	['{0BB485D9-883F-433E-A19D-0F69C4CE76A2}']
	{ private }
		function _GetProp_Exception: IException;
	{ public }
		property Exception: IException read _GetProp_Exception;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_FIXEDADDRESSVALUETYPEATTRIBUTE)]
	IFixedAddressValueTypeAttribute = interface(IAttribute)
	['{47DAB3F4-E65C-44F2-B0B9-C443BF326F2A}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_FIXEDBUFFERATTRIBUTE)]
	IFixedBufferAttribute = interface(IAttribute)
	['{0DBEEC64-F17B-42FE-AD70-9A7A01DB585D}']
	{ private }
		function _GetProp_ElementType: IType;
		function _GetProp_Length: Integer;
	{ public }
		property ElementType: IType read _GetProp_ElementType;
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_FLAGSATTRIBUTE)]
	IFlagsAttribute = interface(IAttribute)
	['{5378AE37-93A4-4907-B401-DD54D64CE487}']
	end;

	IFloatingPointInfoClass = interface(ICoreClrClass)
	['{1F938348-0294-48AF-B032-0D3B96634433}']
	{ private }
		{ class } function _GetFld_Double: IFloatingPointInfo;
		{ class } function _GetFld_Half: IFloatingPointInfo;
		{ class } function _GetFld_Single: IFloatingPointInfo;
	{ public }
		{ class } property &Double: IFloatingPointInfo read _GetFld_Double;
		{ class } property Half: IFloatingPointInfo read _GetFld_Half;
		{ class } property &Single: IFloatingPointInfo read _GetFld_Single;
	end;

	[CoreTypeSignature(SYSTEM_FLOATINGPOINTINFO)]
	IFloatingPointInfo = interface(IValueType)
	['{AD3F96DE-7DEA-4418-83B5-3C9F20B64C7F}']
	{ private }
		function _GetProp_DenormalMantissaBits: Word;
		function _GetProp_DenormalMantissaMask: UInt64;
		function _GetProp_ExponentBias: Integer;
		function _GetProp_InfinityBits: UInt64;
		function _GetProp_MaxBinaryExponent: Integer;
		function _GetProp_MinBinaryExponent: Integer;
		function _GetProp_NormalMantissaBits: Word;
		function _GetProp_NormalMantissaMask: UInt64;
		function _GetProp_OverflowDecimalExponent: Integer;
		function _GetProp_ZeroBits: UInt64;
	{ public }
		property DenormalMantissaBits: Word read _GetProp_DenormalMantissaBits;
		property DenormalMantissaMask: UInt64 read _GetProp_DenormalMantissaMask;
		property ExponentBias: Integer read _GetProp_ExponentBias;
		property InfinityBits: UInt64 read _GetProp_InfinityBits;
		property MaxBinaryExponent: Integer read _GetProp_MaxBinaryExponent;
		property MinBinaryExponent: Integer read _GetProp_MinBinaryExponent;
		property NormalMantissaBits: Word read _GetProp_NormalMantissaBits;
		property NormalMantissaMask: UInt64 read _GetProp_NormalMantissaMask;
		property OverflowDecimalExponent: Integer read _GetProp_OverflowDecimalExponent;
		property ZeroBits: UInt64 read _GetProp_ZeroBits;
	end;

	IFmaClass = interface(ICoreClrClass)
	['{590569DF-DC8D-45C5-BDCF-E235A24AC19E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function MultiplyAdd(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyAdd(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAdd(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplyAdd(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplyAddNegated(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyAddNegated(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAddNegated(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplyAddNegated(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplyAddNegatedScalar(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyAddNegatedScalar(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAddScalar(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyAddScalar(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAddSubtract(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplyAddSubtract(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplyAddSubtract(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplyAddSubtract(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplySubtract(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplySubtract(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplySubtract(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplySubtract(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplySubtractAdd(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplySubtractAdd(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplySubtractAdd(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplySubtractAdd(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplySubtractNegated(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplySubtractNegated(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplySubtractNegated(a: IVector256<Single>; b: IVector256<Single>; c: IVector256<Single>): IVector256<Single>; overload;
		{ class } function MultiplySubtractNegated(a: IVector256<Double>; b: IVector256<Double>; c: IVector256<Double>): IVector256<Double>; overload;
		{ class } function MultiplySubtractNegatedScalar(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplySubtractNegatedScalar(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } function MultiplySubtractScalar(a: IVector128<Single>; b: IVector128<Single>; c: IVector128<Single>): IVector128<Single>; overload;
		{ class } function MultiplySubtractScalar(a: IVector128<Double>; b: IVector128<Double>; c: IVector128<Double>): IVector128<Double>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_FMA)]
	IFma = interface(IAvx)
	['{EB48FB56-8473-489E-835E-CAE6D5B6B4AB}']
	end;

	IX64_5Class = interface(ICoreClrClass)
	['{203F2ACA-EFAC-46E1-A28E-C9BBBF623E82}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_6)]
	IX64_5 = interface(IX64_1)
	['{57A8591F-0595-4E03-87C9-802D2DBD2B4A}']
	end;

	[CoreTypeSignature(SYSTEM_IFORMATTABLE)]
	IIFormattable = interface(IObject)
	['{C3148AFE-8064-41BC-8F13-F44230BABA2B}']
	{ public }
		function ToString(format: String; formatProvider: IIFormatProvider): String;
	end;

	IFormattableStringClass = interface(ICoreClrClass)
	['{3FC7B16D-5C9C-46B4-A7FF-87738277EFEB}']
	{ public }
		{ class } function CurrentCulture(formattable: IFormattableString): String;
		{ class } function Invariant(formattable: IFormattableString): String;
	end;

	[CoreTypeSignature(SYSTEM_FORMATTABLESTRING)]
	IFormattableString = interface(IIFormattable)
	['{457F1071-6FD6-4A13-AAA3-EAB63FECB09C}']
	{ private }
		function _GetProp_ArgumentCount: Integer;
		function _GetProp_Format: String;
	{ public }
		function GetArgument(index: Integer): Variant;
		function GetArguments(): TArray<Variant>;
		function ToString(formatProvider: IIFormatProvider): String;
		property ArgumentCount: Integer read _GetProp_ArgumentCount;
		property Format: String read _GetProp_Format;
	end;

	IFormattableStringFactoryClass = interface(ICoreClrClass)
	['{567167A7-1418-4903-AB5D-07E618652138}']
	{ public }
		{ class } function Create(format: String; arguments: TArray<Variant>): IFormattableString;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_FORMATTABLESTRINGFACTORY)]
	IFormattableStringFactory = interface(IObject)
	['{784EB42F-0B2F-4170-8226-B8B88DDE180B}']
	end;

	[CoreTypeSignature(SYSTEM_IEQUATABLE_1)]
	IIEquatable<T> = interface(IObject)
	['{26C7A15D-3CC8-4354-A65B-34288C0AEA43}']
	{ public }
		function Equals(other: T): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_FRAMEWORKNAME)]
	IFrameworkName = interface(IIEquatable<ICoreClrInstance{IFrameworkName}>)
	['{E2DE343A-E3D2-4699-AC15-EA99EA5C0D02}']
	{ private }
		function _GetProp_FullName: String;
		function _GetProp_Identifier: String;
		function _GetProp_Profile: String;
		function _GetProp_Version: IVersion;
	{ public }
		function Equals(other: IFrameworkName): Boolean;
		property FullName: String read _GetProp_FullName;
		property Identifier: String read _GetProp_Identifier;
		property Profile: String read _GetProp_Profile;
		property Version: IVersion read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_FUNCDESC)]
	IFUNCDESC = interface(IValueType)
	['{5180D7DE-6C3C-4DC0-A1E1-22BA892EFA71}']
	{ private }
		function _GetFld_callconv: TCALLCONV;
		procedure _SetFld_callconv(Value: TCALLCONV);
		function _GetFld_cParams: SmallInt;
		procedure _SetFld_cParams(Value: SmallInt);
		function _GetFld_cParamsOpt: SmallInt;
		procedure _SetFld_cParamsOpt(Value: SmallInt);
		function _GetFld_cScodes: SmallInt;
		procedure _SetFld_cScodes(Value: SmallInt);
		function _GetFld_elemdescFunc: IELEMDESC;
		procedure _SetFld_elemdescFunc(Value: IELEMDESC);
		function _GetFld_funckind: TFUNCKIND;
		procedure _SetFld_funckind(Value: TFUNCKIND);
		function _GetFld_invkind: TINVOKEKIND_Set;
		procedure _SetFld_invkind(Value: TINVOKEKIND_Set);
		function _GetFld_lprgelemdescParam: IIntPtr;
		procedure _SetFld_lprgelemdescParam(Value: IIntPtr);
		function _GetFld_lprgscode: IIntPtr;
		procedure _SetFld_lprgscode(Value: IIntPtr);
		function _GetFld_memid: Integer;
		procedure _SetFld_memid(Value: Integer);
		function _GetFld_oVft: SmallInt;
		procedure _SetFld_oVft(Value: SmallInt);
		function _GetFld_wFuncFlags: SmallInt;
		procedure _SetFld_wFuncFlags(Value: SmallInt);
	{ public }
		property callconv: TCALLCONV read _GetFld_callconv write _SetFld_callconv;
		property cParams: SmallInt read _GetFld_cParams write _SetFld_cParams;
		property cParamsOpt: SmallInt read _GetFld_cParamsOpt write _SetFld_cParamsOpt;
		property cScodes: SmallInt read _GetFld_cScodes write _SetFld_cScodes;
		property elemdescFunc: IELEMDESC read _GetFld_elemdescFunc write _SetFld_elemdescFunc;
		property funckind: TFUNCKIND read _GetFld_funckind write _SetFld_funckind;
		property invkind: TINVOKEKIND_Set read _GetFld_invkind write _SetFld_invkind;
		property lprgelemdescParam: IIntPtr read _GetFld_lprgelemdescParam write _SetFld_lprgelemdescParam;
		property lprgscode: IIntPtr read _GetFld_lprgscode write _SetFld_lprgscode;
		property memid: Integer read _GetFld_memid write _SetFld_memid;
		property oVft: SmallInt read _GetFld_oVft write _SetFld_oVft;
		property wFuncFlags: SmallInt read _GetFld_wFuncFlags write _SetFld_wFuncFlags;
	end;

	IGCClass = interface(ICoreClrClass)
	['{E2344CDA-2563-4E6D-8CED-AB367081D4D6}']
	{ private }
		{ class } function _GetProp_MaxGeneration: Integer;
	{ public }
		{ class } procedure AddMemoryPressure(bytesAllocated: Int64);
		{ class } function AllocateArray(T: PTypeInfo; length: Integer; pinned: Boolean): ICoreClrBridgeArray<Variant{T}>;
		{ class } function AllocateUninitializedArray(T: PTypeInfo; length: Integer; pinned: Boolean): ICoreClrBridgeArray<Variant{T}>;
		{ class } procedure CancelFullGCNotification();
		{ class } procedure Collect(generation: Integer); overload;
		{ class } procedure Collect(); overload;
		{ class } procedure Collect(generation: Integer; mode: TGCCollectionMode); overload;
		{ class } procedure Collect(generation: Integer; mode: TGCCollectionMode; blocking: Boolean); overload;
		{ class } procedure Collect(generation: Integer; mode: TGCCollectionMode; blocking: Boolean; compacting: Boolean); overload;
		{ class } function CollectionCount(generation: Integer): Integer;
		{ class } procedure EndNoGCRegion();
		{ class } function GetAllocatedBytesForCurrentThread(): Int64;
		{ class } function GetGCMemoryInfo(): IGCMemoryInfo; overload;
		{ class } function GetGCMemoryInfo(kind: TGCKind): IGCMemoryInfo; overload;
		{ class } function GetGeneration(obj: Variant): Integer; overload;
		{ class } function GetGeneration(wo: IWeakReference): Integer; overload;
		{ class } function GetTotalAllocatedBytes(precise: Boolean): Int64;
		{ class } function GetTotalMemory(forceFullCollection: Boolean): Int64;
		{ class } procedure KeepAlive(obj: Variant);
		{ class } procedure RegisterForFullGCNotification(maxGenerationThreshold: Integer; largeObjectHeapThreshold: Integer);
		{ class } procedure RemoveMemoryPressure(bytesAllocated: Int64);
		{ class } procedure ReRegisterForFinalize(obj: Variant);
		{ class } procedure SuppressFinalize(obj: Variant);
		{ class } function TryStartNoGCRegion(totalSize: Int64): Boolean; overload;
		{ class } function TryStartNoGCRegion(totalSize: Int64; lohSize: Int64): Boolean; overload;
		{ class } function TryStartNoGCRegion(totalSize: Int64; disallowFullBlockingGC: Boolean): Boolean; overload;
		{ class } function TryStartNoGCRegion(totalSize: Int64; lohSize: Int64; disallowFullBlockingGC: Boolean): Boolean; overload;
		{ class } function WaitForFullGCApproach(): TGCNotificationStatus; overload;
		{ class } function WaitForFullGCApproach(millisecondsTimeout: Integer): TGCNotificationStatus; overload;
		{ class } function WaitForFullGCComplete(): TGCNotificationStatus; overload;
		{ class } function WaitForFullGCComplete(millisecondsTimeout: Integer): TGCNotificationStatus; overload;
		{ class } procedure WaitForPendingFinalizers();
		{ class } property MaxGeneration: Integer read _GetProp_MaxGeneration;
	end;

	[CoreTypeSignature(SYSTEM_GC)]
	IGC = interface(IObject)
	['{0333C909-020C-49BB-88D2-8AE468F31638}']
	end;

	[CoreTypeSignature(SYSTEM_GCGENERATIONINFO)]
	IGCGenerationInfo = interface(IValueType)
	['{B0127052-271C-43A3-99FD-BA546A7F9E11}']
	{ private }
		function _GetProp_FragmentationAfterBytes: Int64;
		function _GetProp_FragmentationBeforeBytes: Int64;
		function _GetProp_SizeAfterBytes: Int64;
		function _GetProp_SizeBeforeBytes: Int64;
	{ public }
		property FragmentationAfterBytes: Int64 read _GetProp_FragmentationAfterBytes;
		property FragmentationBeforeBytes: Int64 read _GetProp_FragmentationBeforeBytes;
		property SizeAfterBytes: Int64 read _GetProp_SizeAfterBytes;
		property SizeBeforeBytes: Int64 read _GetProp_SizeBeforeBytes;
	end;

	IGCHandleClass = interface(ICoreClrClass)
	['{8AD20B07-EEE6-4119-A5D2-6A91D8708461}']
	{ public }
		{ class } function Alloc(value: Variant): IGCHandle; overload;
		{ class } function Alloc(value: Variant; type_: TGCHandleType): IGCHandle; overload;
		{ class } function FromIntPtr(value: IIntPtr): IGCHandle;
		{ class } function ToIntPtr(value: IGCHandle): IIntPtr;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_GCHANDLE)]
	IGCHandle = interface(IValueType)
	['{C2773A5D-40E8-4D0B-9D2C-4752E187A2D4}']
	{ private }
		function _GetProp_IsAllocated: Boolean;
		function _GetProp_Target: Variant;
		procedure _SetProp_Target(Value: Variant);
	{ public }
		function AddrOfPinnedObject(): IIntPtr;
		procedure Free();
		property IsAllocated: Boolean read _GetProp_IsAllocated;
		property Target: Variant read _GetProp_Target write _SetProp_Target;
	end;

	[CoreTypeSignature(SYSTEM_GCMEMORYINFO)]
	IGCMemoryInfo = interface(IValueType)
	['{5D2CCDE5-DE39-4C04-937C-984E8B25DFA6}']
	{ private }
		function _GetProp_Compacted: Boolean;
		function _GetProp_Concurrent: Boolean;
		function _GetProp_FinalizationPendingCount: Int64;
		function _GetProp_FragmentedBytes: Int64;
		function _GetProp_Generation: Integer;
		function _GetProp_GenerationInfo: IReadOnlySpan<IGCGenerationInfo>;
		function _GetProp_HeapSizeBytes: Int64;
		function _GetProp_HighMemoryLoadThresholdBytes: Int64;
		function _GetProp_Index: Int64;
		function _GetProp_MemoryLoadBytes: Int64;
		function _GetProp_PauseDurations: IReadOnlySpan<ITimeSpan>;
		function _GetProp_PauseTimePercentage: Double;
		function _GetProp_PinnedObjectsCount: Int64;
		function _GetProp_PromotedBytes: Int64;
		function _GetProp_TotalAvailableMemoryBytes: Int64;
		function _GetProp_TotalCommittedBytes: Int64;
	{ public }
		property Compacted: Boolean read _GetProp_Compacted;
		property Concurrent: Boolean read _GetProp_Concurrent;
		property FinalizationPendingCount: Int64 read _GetProp_FinalizationPendingCount;
		property FragmentedBytes: Int64 read _GetProp_FragmentedBytes;
		property Generation: Integer read _GetProp_Generation;
		property GenerationInfo: IReadOnlySpan<IGCGenerationInfo> read _GetProp_GenerationInfo;
		property HeapSizeBytes: Int64 read _GetProp_HeapSizeBytes;
		property HighMemoryLoadThresholdBytes: Int64 read _GetProp_HighMemoryLoadThresholdBytes;
		property Index: Int64 read _GetProp_Index;
		property MemoryLoadBytes: Int64 read _GetProp_MemoryLoadBytes;
		property PauseDurations: IReadOnlySpan<ITimeSpan> read _GetProp_PauseDurations;
		property PauseTimePercentage: Double read _GetProp_PauseTimePercentage;
		property PinnedObjectsCount: Int64 read _GetProp_PinnedObjectsCount;
		property PromotedBytes: Int64 read _GetProp_PromotedBytes;
		property TotalAvailableMemoryBytes: Int64 read _GetProp_TotalAvailableMemoryBytes;
		property TotalCommittedBytes: Int64 read _GetProp_TotalCommittedBytes;
	end;

	IGCSettingsClass = interface(ICoreClrClass)
	['{99E23591-F246-4037-B044-3BCE0CF50724}']
	{ private }
		{ class } function _GetProp_IsServerGC: Boolean;
		{ class } function _GetProp_LargeObjectHeapCompactionMode: TGCLargeObjectHeapCompactionMode;
		{ class } procedure _SetProp_LargeObjectHeapCompactionMode(Value: TGCLargeObjectHeapCompactionMode);
		{ class } function _GetProp_LatencyMode: TGCLatencyMode;
		{ class } procedure _SetProp_LatencyMode(Value: TGCLatencyMode);
	{ public }
		{ class } property IsServerGC: Boolean read _GetProp_IsServerGC;
		{ class } property LargeObjectHeapCompactionMode: TGCLargeObjectHeapCompactionMode read _GetProp_LargeObjectHeapCompactionMode write _SetProp_LargeObjectHeapCompactionMode;
		{ class } property LatencyMode: TGCLatencyMode read _GetProp_LatencyMode write _SetProp_LatencyMode;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_GCSETTINGS)]
	IGCSettings = interface(IObject)
	['{313E7A36-4BF2-4424-8858-8A17669E0113}']
	end;

	[CoreTypeSignature(SYSTEM_CODEDOM_COMPILER_GENERATEDCODEATTRIBUTE)]
	IGeneratedCodeAttribute = interface(IAttribute)
	['{83FE43C7-7012-491E-B83C-FE1E37798E6C}']
	{ private }
		function _GetProp_Tool: String;
		function _GetProp_Version: String;
	{ public }
		property Tool: String read _GetProp_Tool;
		property Version: String read _GetProp_Version;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_GENERICCOMPARER_1)]
	IGenericComparer<T> = interface(IComparer<T>)
	['{AB3E5E94-7C99-4630-8E5A-3A0CD6498543}']
	{ public }
		function Compare(x: T; y: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_GENERICEQUALITYCOMPARER_1)]
	IGenericEqualityComparer<T> = interface(IEqualityComparer<T>)
	['{F27045C5-A372-46FC-93D3-F2854C1D03A0}']
	{ public }
		function Equals(x: T; y: T): Boolean;
		function GetHashCode(obj: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_GENERICTYPEPARAMETERBUILDER)]
	IGenericTypeParameterBuilder = interface(ITypeInfo)
	['{E9E02AB4-24ED-4B07-9E35-9DED170A24A4}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_AssemblyQualifiedName: String;
		function _GetProp_BaseType: IType;
		function _GetProp_ContainsGenericParameters: Boolean;
		function _GetProp_DeclaringMethod: IMethodBase;
		function _GetProp_DeclaringType: IType;
		function _GetProp_FullName: String;
		function _GetProp_GenericParameterAttributes: TGenericParameterAttributes_Set;
		function _GetProp_GenericParameterPosition: Integer;
		function _GetProp_GUID: IGuid;
		function _GetProp_IsByRefLike: Boolean;
		function _GetProp_IsConstructedGenericType: Boolean;
		function _GetProp_IsGenericParameter: Boolean;
		function _GetProp_IsGenericType: Boolean;
		function _GetProp_IsGenericTypeDefinition: Boolean;
		function _GetProp_IsSZArray: Boolean;
		function _GetProp_IsTypeDefinition: Boolean;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_Namespace: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_TypeHandle: IRuntimeTypeHandle;
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		function GetConstructors(bindingAttr: TBindingFlags_Set): TArray<IConstructorInfo>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetElementType(): IType;
		function GetEvent(name: String; bindingAttr: TBindingFlags_Set): IEventInfo;
		function GetEvents(): TArray<IEventInfo>; overload;
		function GetEvents(bindingAttr: TBindingFlags_Set): TArray<IEventInfo>; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetGenericArguments(): TArray<IType>;
		function GetGenericTypeDefinition(): IType;
		function GetInterface(name: String; ignoreCase: Boolean): IType;
		function GetInterfaceMap(interfaceType: IType): IInterfaceMapping;
		function GetInterfaces(): TArray<IType>;
		function GetMember(name: String; type_: TMemberTypes_Set; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetNestedType(name: String; bindingAttr: TBindingFlags_Set): IType;
		function GetNestedTypes(bindingAttr: TBindingFlags_Set): TArray<IType>;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant;
		function IsAssignableFrom(typeInfo: ITypeInfo): Boolean; overload;
		function IsAssignableFrom(c: IType): Boolean; overload;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function IsSubclassOf(c: IType): Boolean;
		function MakeArrayType(): IType; overload;
		function MakeArrayType(rank: Integer): IType; overload;
		function MakeByRefType(): IType;
		function MakeGenericType(typeArguments: ICoreClrBridgeArray<IType>): IType;
		function MakePointerType(): IType;
		procedure SetBaseTypeConstraint(baseTypeConstraint: IType);
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetGenericParameterAttributes(genericParameterAttributes: TGenericParameterAttributes_Set);
		procedure SetInterfaceConstraints(interfaceConstraints: ICoreClrBridgeArray<IType>);
		property Assembly: IAssembly read _GetProp_Assembly;
		property AssemblyQualifiedName: String read _GetProp_AssemblyQualifiedName;
		property BaseType: IType read _GetProp_BaseType;
		property ContainsGenericParameters: Boolean read _GetProp_ContainsGenericParameters;
		property DeclaringMethod: IMethodBase read _GetProp_DeclaringMethod;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property FullName: String read _GetProp_FullName;
		property GenericParameterAttributes: TGenericParameterAttributes_Set read _GetProp_GenericParameterAttributes;
		property GenericParameterPosition: Integer read _GetProp_GenericParameterPosition;
		property GUID: IGuid read _GetProp_GUID;
		property IsByRefLike: Boolean read _GetProp_IsByRefLike;
		property IsConstructedGenericType: Boolean read _GetProp_IsConstructedGenericType;
		property IsGenericParameter: Boolean read _GetProp_IsGenericParameter;
		property IsGenericType: Boolean read _GetProp_IsGenericType;
		property IsGenericTypeDefinition: Boolean read _GetProp_IsGenericTypeDefinition;
		property IsSZArray: Boolean read _GetProp_IsSZArray;
		property IsTypeDefinition: Boolean read _GetProp_IsTypeDefinition;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property Namespace: String read _GetProp_Namespace;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property TypeHandle: IRuntimeTypeHandle read _GetProp_TypeHandle;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	IGlobalizationExtensionsClass = interface(ICoreClrClass)
	['{0B4EB9FF-4E9B-4BC4-A509-1D035822B052}']
	{ public }
		{ class } function GetStringComparer(compareInfo: ICompareInfo; options: TCompareOptions_Set): IStringComparer;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_GLOBALIZATIONEXTENSIONS)]
	IGlobalizationExtensions = interface(IObject)
	['{B2612F6B-02D9-42B8-8A26-1740A91D5C5B}']
	end;

	IGregorianCalendarClass = interface(ICoreClrClass)
	['{4AF965F6-53D0-404A-B690-95B7FC26BC8F}']
	{ private }
		{ class } function _GetFld_ADEra: Integer;
	{ public }
		{ class } property ADEra: Integer read _GetFld_ADEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_GREGORIANCALENDAR)]
	IGregorianCalendar = interface(ICalendar)
	['{FAA2F3CB-546B-4FC4-B000-85A2691437A7}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_CalendarType: TGregorianCalendarTypes;
		procedure _SetProp_CalendarType(Value: TGregorianCalendarTypes);
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property CalendarType: TGregorianCalendarTypes read _GetProp_CalendarType write _SetProp_CalendarType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IGuidClass = interface(ICoreClrClass)
	['{6EF29389-CC68-457C-A64C-6AF1C3974F61}']
	{ private }
		{ class } function _GetFld_Empty: IGuid;
	{ public }
		{ class } function NewGuid(): IGuid;
		{ class } function Parse(input: String): IGuid; overload;
		{ class } function Parse(input: IReadOnlySpan<Char>): IGuid; overload;
		{ class } function ParseExact(input: String; format: String): IGuid; overload;
		{ class } function ParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>): IGuid; overload;
		{ class } function TryParse(input: String; var result_: IGuid): Boolean; overload;
		{ class } function TryParse(input: IReadOnlySpan<Char>; var result_: IGuid): Boolean; overload;
		{ class } function TryParseExact(input: String; format: String; var result_: IGuid): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; var result_: IGuid): Boolean; overload;
		{ class } property Empty: IGuid read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_GUID)]
	IGuid = interface(IValueType)
	['{AF035C87-D6FF-48F0-9AAE-E1A4FCA1ACFF}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: IGuid): Integer; overload;
		function Equals(g: IGuid): Boolean;
		function ToByteArray(): TArray<Byte>;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>): Boolean;
		function TryWriteBytes(destination: ISpan<Byte>): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_GUIDATTRIBUTE)]
	IGuidAttribute = interface(IAttribute)
	['{9B1EE7B5-ED10-4A31-85C3-B8653687425F}']
	{ private }
		function _GetProp_Value: String;
	{ public }
		property Value: String read _GetProp_Value;
	end;

	IHalfClass = interface(ICoreClrClass)
	['{199C31CC-8CC7-4D46-A302-151A686D9137}']
	{ private }
		{ class } function _GetProp_Epsilon: IHalf;
		{ class } function _GetProp_MaxValue: IHalf;
		{ class } function _GetProp_MinValue: IHalf;
		{ class } function _GetProp_NaN: IHalf;
		{ class } function _GetProp_NegativeInfinity: IHalf;
		{ class } function _GetProp_PositiveInfinity: IHalf;
	{ public }
		{ class } function IsFinite(value: IHalf): Boolean;
		{ class } function IsInfinity(value: IHalf): Boolean;
		{ class } function IsNaN(value: IHalf): Boolean;
		{ class } function IsNegative(value: IHalf): Boolean;
		{ class } function IsNegativeInfinity(value: IHalf): Boolean;
		{ class } function IsNormal(value: IHalf): Boolean;
		{ class } function IsPositiveInfinity(value: IHalf): Boolean;
		{ class } function IsSubnormal(value: IHalf): Boolean;
		{ class } function Parse(s: String): IHalf; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): IHalf; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): IHalf; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): IHalf; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): IHalf; overload;
		{ class } function TryParse(s: String; var result_: IHalf): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: IHalf): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IHalf): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IHalf): Boolean; overload;
		{ class } property Epsilon: IHalf read _GetProp_Epsilon;
		{ class } property MaxValue: IHalf read _GetProp_MaxValue;
		{ class } property MinValue: IHalf read _GetProp_MinValue;
		{ class } property NaN: IHalf read _GetProp_NaN;
		{ class } property NegativeInfinity: IHalf read _GetProp_NegativeInfinity;
		{ class } property PositiveInfinity: IHalf read _GetProp_PositiveInfinity;
	end;

	[CoreTypeSignature(SYSTEM_HALF)]
	IHalf = interface(IValueType)
	['{328F01C2-A842-4886-B385-3B87B8941FE0}']
	{ public }
		function CompareTo(obj: Variant): Integer; overload;
		function CompareTo(other: IHalf): Integer; overload;
		function Equals(other: IHalf): Boolean;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_EXCEPTIONSERVICES_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONSATTRIBUTE)]
	IHandleProcessCorruptedStateExceptionsAttribute = interface(IAttribute)
	['{27707BE9-541F-4C3B-9C65-AB2E10CB2217}']
	end;

	IHandleRefClass = interface(ICoreClrClass)
	['{8F0FCBC2-5A59-4849-97BE-6A0F09F69EEB}']
	{ public }
		{ class } function ToIntPtr(value: IHandleRef): IIntPtr;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_HANDLEREF)]
	IHandleRef = interface(IValueType)
	['{2DA1FB11-3393-4872-90AB-BD3CA7F8C61F}']
	{ private }
		function _GetProp_Handle: IIntPtr;
		function _GetProp_Wrapper: Variant;
	{ public }
		property Handle: IIntPtr read _GetProp_Handle;
		property Wrapper: Variant read _GetProp_Wrapper;
	end;

	IHashCodeClass = interface(ICoreClrClass)
	['{4A1252AF-0BC2-4EE3-85E5-BA7AA4CA669F}']
	{ public }
		{ class } function Combine(T1: PTypeInfo; value1: Variant{T1}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}; value4: Variant{T4}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}; value4: Variant{T4}; value5: Variant{T5}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}; value4: Variant{T4}; value5: Variant{T5}; value6: Variant{T6}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}; value4: Variant{T4}; value5: Variant{T5}; value6: Variant{T6}; value7: Variant{T7}): Integer; overload;
		{ class } function Combine(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; value1: Variant{T1}; value2: Variant{T2}; value3: Variant{T3}; value4: Variant{T4}; value5: Variant{T5}; value6: Variant{T6}; value7: Variant{T7}; value8: Variant{T8}): Integer; overload;
	end;

	[CoreTypeSignature(SYSTEM_HASHCODE)]
	IHashCode = interface(IValueType)
	['{0F276104-8029-40A9-A0B5-D320B9F7F609}']
	{ public }
		procedure Add(T: PTypeInfo; value: Variant{T}); overload;
		procedure Add(T: PTypeInfo; value: Variant{T}; comparer: IIEqualityComparer<Variant{T}>); overload;
		function ToHashCode(): Integer;
	end;

	IHashtableClass = interface(ICoreClrClass)
	['{8EF5F903-271B-41E0-BF39-C854D604A77D}']
	{ public }
		{ class } function Synchronized(table: IHashtable): IHashtable;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_HASHTABLE)]
	IHashtable = interface(IObject)
	['{1E2E387E-1A87-4E1B-9155-725FD0B2E41D}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_Item(key: Variant): Variant;
		procedure _SetProp_Item(key: Variant; Value: Variant);
		function _GetProp_Keys: IICollection;
		function _GetProp_SyncRoot: Variant;
		function _GetProp_Values: IICollection;
	{ public }
		procedure Add(key: Variant; value: Variant);
		procedure Clear();
		function Clone(): Variant;
		function Contains(key: Variant): Boolean;
		function ContainsKey(key: Variant): Boolean;
		function ContainsValue(value: Variant): Boolean;
		procedure CopyTo(array_: IArray; arrayIndex: Integer);
		function GetEnumerator(): IIDictionaryEnumerator;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure OnDeserialization(sender: Variant);
		procedure Remove(key: Variant);
		property Count: Integer read _GetProp_Count;
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property Item[key: Variant]: Variant read _GetProp_Item write _SetProp_Item; default;
		property Keys: IICollection read _GetProp_Keys;
		property SyncRoot: Variant read _GetProp_SyncRoot;
		property Values: IICollection read _GetProp_Values;
	end;

	IHebrewCalendarClass = interface(ICoreClrClass)
	['{13C86638-0E01-43B1-BF5A-6FC440646B6C}']
	{ private }
		{ class } function _GetFld_HebrewEra: Integer;
	{ public }
		{ class } property HebrewEra: Integer read _GetFld_HebrewEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_HEBREWCALENDAR)]
	IHebrewCalendar = interface(ICalendar)
	['{1A6DBBD7-A9D9-48D0-810E-433BE250C254}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IHijriCalendarClass = interface(ICoreClrClass)
	['{18D458D9-EF6F-4813-9F1E-28EB2D95B453}']
	{ private }
		{ class } function _GetFld_HijriEra: Integer;
	{ public }
		{ class } property HijriEra: Integer read _GetFld_HijriEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_HIJRICALENDAR)]
	IHijriCalendar = interface(ICalendar)
	['{5A3B1C39-F878-4819-A7EA-4D7C6DF25318}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_HijriAdjustment: Integer;
		procedure _SetProp_HijriAdjustment(Value: Integer);
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property HijriAdjustment: Integer read _GetProp_HijriAdjustment write _SetProp_HijriAdjustment;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	[CoreTypeSignature(SYSTEM_IASYNCDISPOSABLE)]
	IIAsyncDisposable = interface(IObject)
	['{3C305D0A-EB51-480C-A834-06DBE89C5F8D}']
	{ public }
		function DisposeAsync(): IValueTask;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IASYNCENUMERABLE_1)]
	IIAsyncEnumerable<T> = interface(IObject)
	['{AD512745-1E34-4C05-891D-94605DCB1614}']
	{ public }
		function GetAsyncEnumerator(cancellationToken: ICancellationToken): IIAsyncEnumerator<T>;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IASYNCENUMERATOR_1)]
	IIAsyncEnumerator<T> = interface(IObject)
	['{BE3D2C8F-9750-407C-B620-AFFD92BDF444}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		function MoveNextAsync(): IValueTask<Boolean>;
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_IASYNCRESULT)]
	IIAsyncResult = interface(IObject)
	['{FFCF3970-10D5-447B-AA6E-7E073747DB69}']
	{ private }
		function _GetProp_AsyncState: Variant;
		function _GetProp_AsyncWaitHandle: IWaitHandle;
		function _GetProp_CompletedSynchronously: Boolean;
		function _GetProp_IsCompleted: Boolean;
	{ public }
		property AsyncState: Variant read _GetProp_AsyncState;
		property AsyncWaitHandle: IWaitHandle read _GetProp_AsyncWaitHandle;
		property CompletedSynchronously: Boolean read _GetProp_CompletedSynchronously;
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_IASYNCSTATEMACHINE)]
	IIAsyncStateMachine = interface(IObject)
	['{6BF62C44-D2D8-40C7-8939-96D75B71BD0F}']
	{ public }
		procedure MoveNext();
		procedure SetStateMachine(stateMachine: IIAsyncStateMachine);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IBINDCTX)]
	IIBindCtx = interface(IObject)
	['{BF05B97C-754F-483A-9EED-4F3EA050451A}']
	{ public }
		procedure EnumObjectParam(var ppenum: IIEnumString);
		procedure GetBindOptions(var pbindopts: IBIND_OPTS);
		procedure GetObjectParam(pszKey: String; var ppunk: Variant);
		procedure GetRunningObjectTable(var pprot: IIRunningObjectTable);
		procedure RegisterObjectBound(punk: Variant);
		procedure RegisterObjectParam(pszKey: String; punk: Variant);
		procedure ReleaseBoundObjects();
		procedure RevokeObjectBound(punk: Variant);
		function RevokeObjectParam(pszKey: String): Integer;
		procedure SetBindOptions(var pbindopts: IBIND_OPTS);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ICASTABLE)]
	IICastable = interface(IObject)
	['{5F0A466E-2F44-44AC-94A2-76934E23350F}']
	{ public }
		function GetImplType(interfaceType: IRuntimeTypeHandle): IRuntimeTypeHandle;
		function IsInstanceOfInterface(interfaceType: IRuntimeTypeHandle; var castError: IException): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ICOLLECTION)]
	IICollection = interface(IObject)
	['{955521D5-B848-42A6-9C1F-89950CC430E4}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_SyncRoot: Variant;
	{ public }
		procedure CopyTo(array_: IArray; index: Integer);
		property Count: Integer read _GetProp_Count;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property SyncRoot: Variant read _GetProp_SyncRoot;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ICOLLECTION_1)]
	IICollection<T> = interface(IObject)
	['{C2028A69-611F-4E45-A2E6-E1F82E1E201B}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsReadOnly: Boolean;
	{ public }
		procedure Add(item: T);
		procedure Clear();
		function Contains(item: T): Boolean;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; arrayIndex: Integer);
		function Remove(item: T): Boolean;
		property Count: Integer read _GetProp_Count;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
	end;

	[CoreTypeSignature(SYSTEM_ICOMPARABLE)]
	IIComparable = interface(IObject)
	['{FB85FFBD-7E9F-4E20-80F3-DC76D286CFB5}']
	{ public }
		function CompareTo(obj: Variant): Integer;
	end;

	[CoreTypeSignature(SYSTEM_ICOMPARABLE_1)]
	IIComparable<T> = interface(IObject)
	['{752AC302-B02D-43A1-9D0F-05858EFFE913}']
	{ public }
		function CompareTo(other: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ICOMPARER)]
	IIComparer = interface(IObject)
	['{126112D1-89BC-42FC-8E0A-F0A81241293D}']
	{ public }
		function Compare(x: Variant; y: Variant): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ICOMPARER_1)]
	IIComparer<T> = interface(IObject)
	['{B6C0DC44-8757-4F7B-9FEB-971BCC1A7288}']
	{ public }
		function Compare(x: T; y: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ICONNECTIONPOINT)]
	IIConnectionPoint = interface(IObject)
	['{17861A36-F300-4E14-B0E0-AFF75AC92A58}']
	{ public }
		procedure Advise(pUnkSink: Variant; var pdwCookie: Integer);
		procedure EnumConnections(var ppEnum: IIEnumConnections);
		procedure GetConnectionInterface(var pIID: IGuid);
		procedure GetConnectionPointContainer(var ppCPC: IIConnectionPointContainer);
		procedure Unadvise(dwCookie: Integer);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ICONNECTIONPOINTCONTAINER)]
	IIConnectionPointContainer = interface(IObject)
	['{E8353B51-19F9-490E-9372-A8B6643CDB4C}']
	{ public }
		procedure EnumConnectionPoints(var ppEnum: IIEnumConnectionPoints);
		procedure FindConnectionPoint(var riid: IGuid; var ppCP: IIConnectionPoint);
	end;

	[CoreTypeSignature(SYSTEM_ICONVERTIBLE)]
	IIConvertible = interface(IObject)
	['{4AA86A9F-9D22-455E-91FC-B99CBA51B406}']
	{ public }
		function GetTypeCode(): TTypeCode;
		function ToBoolean(provider: IIFormatProvider): Boolean;
		function ToByte(provider: IIFormatProvider): Byte;
		function ToChar(provider: IIFormatProvider): Char;
		function ToDateTime(provider: IIFormatProvider): TDateTime;
		function ToDecimal(provider: IIFormatProvider): IDecimal;
		function ToDouble(provider: IIFormatProvider): Double;
		function ToInt16(provider: IIFormatProvider): SmallInt;
		function ToInt32(provider: IIFormatProvider): Integer;
		function ToInt64(provider: IIFormatProvider): Int64;
		function ToSByte(provider: IIFormatProvider): Shortint;
		function ToSingle(provider: IIFormatProvider): Single;
		function ToString(provider: IIFormatProvider): String;
		function ToType(conversionType: IType; provider: IIFormatProvider): Variant;
		function ToUInt16(provider: IIFormatProvider): Word;
		function ToUInt32(provider: IIFormatProvider): longword;
		function ToUInt64(provider: IIFormatProvider): UInt64;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ICRITICALNOTIFYCOMPLETION)]
	IICriticalNotifyCompletion = interface(IObject)
	['{71580446-926A-4FA3-863F-C1B142E44B43}']
	{ public }
		procedure UnsafeOnCompleted(continuation: TClrAction);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ICUSTOMADAPTER)]
	IICustomAdapter = interface(IObject)
	['{F4F05E94-2AB1-490F-858D-9938960677F3}']
	{ public }
		function GetUnderlyingObject(): Variant;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ICUSTOMFACTORY)]
	IICustomFactory = interface(IObject)
	['{D733C4DF-2EF2-4794-B79F-4DCFD3D4B330}']
	{ public }
		function CreateInstance(serverType: IType): IMarshalByRefObject;
	end;

	[CoreTypeSignature(SYSTEM_ICUSTOMFORMATTER)]
	IICustomFormatter = interface(IObject)
	['{6E410DC0-EA27-44A0-93A2-A7BBC933A71A}']
	{ public }
		function Format(format: String; arg: Variant; formatProvider: IIFormatProvider): String;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ICUSTOMMARSHALER)]
	IICustomMarshaler = interface(IObject)
	['{BA66BE01-A94B-4986-830A-311AB2E3D86E}']
	{ public }
		procedure CleanUpManagedData(ManagedObj: Variant);
		procedure CleanUpNativeData(pNativeData: IIntPtr);
		function GetNativeDataSize(): Integer;
		function MarshalManagedToNative(ManagedObj: Variant): IIntPtr;
		function MarshalNativeToManaged(pNativeData: IIntPtr): Variant;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_ICUSTOMQUERYINTERFACE)]
	IICustomQueryInterface = interface(IObject)
	['{DB0122A1-E801-40C3-B844-5372118A888C}']
	{ public }
		function GetInterface(var iid: IGuid; var ppv: IIntPtr): TCustomQueryInterfaceResult;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IDICTIONARY)]
	IIDictionary = interface(IObject)
	['{FF9C80F6-EDCB-4D9A-B101-9AC357E72E0F}']
	{ private }
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_Item(key: Variant): Variant;
		procedure _SetProp_Item(key: Variant; Value: Variant);
		function _GetProp_Keys: IICollection;
		function _GetProp_Values: IICollection;
	{ public }
		procedure Add(key: Variant; value: Variant);
		procedure Clear();
		function Contains(key: Variant): Boolean;
		function GetEnumerator(): IIDictionaryEnumerator;
		procedure Remove(key: Variant);
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property Item[key: Variant]: Variant read _GetProp_Item write _SetProp_Item; default;
		property Keys: IICollection read _GetProp_Keys;
		property Values: IICollection read _GetProp_Values;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IDICTIONARY_2)]
	IIDictionary<TKey,TValue> = interface(IObject)
	['{671FAE70-5F9F-485E-A2A8-44872D7EF328}']
	{ private }
		function _GetProp_Item(key: TKey): TValue;
		procedure _SetProp_Item(key: TKey; Value: TValue);
		function _GetProp_Keys: IICollection<TKey>;
		function _GetProp_Values: IICollection<TValue>;
	{ public }
		procedure Add(key: TKey; value: TValue);
		function ContainsKey(key: TKey): Boolean;
		function Remove(key: TKey): Boolean;
		function TryGetValue(key: TKey; var value: TValue): Boolean;
		property Item[key: TKey]: TValue read _GetProp_Item write _SetProp_Item; default;
		property Keys: IICollection<TKey> read _GetProp_Keys;
		property Values: IICollection<TValue> read _GetProp_Values;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IDICTIONARYENUMERATOR)]
	IIDictionaryEnumerator = interface(IObject)
	['{2264609B-1624-46CA-A85A-73FE15858E0D}']
	{ private }
		function _GetProp_Entry: IDictionaryEntry;
		function _GetProp_Key: Variant;
		function _GetProp_Value: Variant;
	{ public }
		property Entry: IDictionaryEntry read _GetProp_Entry;
		property Key: Variant read _GetProp_Key;
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IDLDESC)]
	IIDLDESC = interface(IValueType)
	['{BF6EB949-96F7-4B1B-9E58-F17DB574BC45}']
	{ private }
		function _GetFld_dwReserved: IIntPtr;
		procedure _SetFld_dwReserved(Value: IIntPtr);
		function _GetFld_wIDLFlags: TIDLFLAG_Set;
		procedure _SetFld_wIDLFlags(Value: TIDLFLAG_Set);
	{ public }
		property dwReserved: IIntPtr read _GetFld_dwReserved write _SetFld_dwReserved;
		property wIDLFlags: TIDLFLAG_Set read _GetFld_wIDLFlags write _SetFld_wIDLFlags;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_IDNMAPPING)]
	IIdnMapping = interface(IObject)
	['{C167F4D4-8AE8-4D4B-A816-A20A7E70A4D6}']
	{ private }
		function _GetProp_AllowUnassigned: Boolean;
		procedure _SetProp_AllowUnassigned(Value: Boolean);
		function _GetProp_UseStd3AsciiRules: Boolean;
		procedure _SetProp_UseStd3AsciiRules(Value: Boolean);
	{ public }
		function GetAscii(unicode: String): String; overload;
		function GetAscii(unicode: String; index: Integer): String; overload;
		function GetAscii(unicode: String; index: Integer; count: Integer): String; overload;
		function GetUnicode(ascii: String): String; overload;
		function GetUnicode(ascii: String; index: Integer): String; overload;
		function GetUnicode(ascii: String; index: Integer; count: Integer): String; overload;
		property AllowUnassigned: Boolean read _GetProp_AllowUnassigned write _SetProp_AllowUnassigned;
		property UseStd3AsciiRules: Boolean read _GetProp_UseStd3AsciiRules write _SetProp_UseStd3AsciiRules;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_IDYNAMICINTERFACECASTABLE)]
	IIDynamicInterfaceCastable = interface(IObject)
	['{2E4FB04A-A7EA-40E8-9658-7494714E6630}']
	{ public }
		function GetInterfaceImplementation(interfaceType: IRuntimeTypeHandle): IRuntimeTypeHandle;
		function IsInterfaceImplemented(interfaceType: IRuntimeTypeHandle; throwIfNotImplemented: Boolean): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IENUMCONNECTIONPOINTS)]
	IIEnumConnectionPoints = interface(IObject)
	['{67CE39D2-1B72-4A49-8B63-2DEC5FD4C559}']
	{ public }
		procedure Clone(var ppenum: IIEnumConnectionPoints);
		function Next(celt: Integer; var rgelt: ICoreClrBridgeArray<IIConnectionPoint>; pceltFetched: IIntPtr): Integer;
		procedure Reset();
		function Skip(celt: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IENUMCONNECTIONS)]
	IIEnumConnections = interface(IObject)
	['{51CA771D-54AB-4986-AA31-8542CF9550D6}']
	{ public }
		procedure Clone(var ppenum: IIEnumConnections);
		function Next(celt: Integer; var rgelt: ICoreClrBridgeArray<ICONNECTDATA>; pceltFetched: IIntPtr): Integer;
		procedure Reset();
		function Skip(celt: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IENUMERABLE)]
	IIEnumerable = interface(IObject)
	['{DF8672C6-0596-4C1C-8070-DE25BCE8E676}']
	{ public }
		function GetEnumerator(): IIEnumerator;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1)]
	IIEnumerable<T> = interface(IObject)
	['{7C756A6D-AD29-4E65-AC6F-AE0D1BB93F2B}']
	{ public }
		function GetEnumerator(): IIEnumerator<T>;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IENUMERATOR)]
	IIEnumerator = interface(IObject)
	['{D515D96C-D5D1-426A-A4F9-0A9B3C2D1B46}']
	{ private }
		function _GetProp_Current: Variant;
	{ public }
		function MoveNext(): Boolean;
		procedure Reset();
		property Current: Variant read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IENUMERATOR_1)]
	IIEnumerator<T> = interface(IObject)
	['{C21D08BD-A737-4FDD-A922-CA10F2C8D86F}']
	{ private }
		function _GetProp_Current: T;
	{ public }
		property Current: T read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IENUMMONIKER)]
	IIEnumMoniker = interface(IObject)
	['{B7B76D0D-E955-429E-98EC-C7C3B64B4A22}']
	{ public }
		procedure Clone(var ppenum: IIEnumMoniker);
		function Next(celt: Integer; var rgelt: ICoreClrBridgeArray<IIMoniker>; pceltFetched: IIntPtr): Integer;
		procedure Reset();
		function Skip(celt: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IENUMSTRING)]
	IIEnumString = interface(IObject)
	['{35F036CD-D383-4D93-AE44-B1F43BF4D961}']
	{ public }
		procedure Clone(var ppenum: IIEnumString);
		function Next(celt: Integer; var rgelt: TArray<String>; pceltFetched: IIntPtr): Integer;
		procedure Reset();
		function Skip(celt: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IENUMVARIANT)]
	IIEnumVARIANT = interface(IObject)
	['{6ED4A7DE-6827-431C-98F6-0EF45C871559}']
	{ public }
		function Clone(): IIEnumVARIANT;
		function Next(celt: Integer; var rgVar: TArray<Variant>; pceltFetched: IIntPtr): Integer;
		function Reset(): Integer;
		function Skip(celt: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IEQUALITYCOMPARER)]
	IIEqualityComparer = interface(IObject)
	['{BDB5C01A-72B5-4A70-AA58-D1E8FDC5C274}']
	{ public }
		function Equals(x: Variant; y: Variant): Boolean;
		function GetHashCode(obj: Variant): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IEQUALITYCOMPARER_1)]
	IIEqualityComparer<T> = interface(IObject)
	['{2BD62393-20E4-4CC9-8EDB-259B68234CDC}']
	{ public }
		function Equals(x: T; y: T): Boolean;
		function GetHashCode(obj: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_IFORMATPROVIDER)]
	IIFormatProvider = interface(IObject)
	['{221B2530-6FEA-4ADD-88CE-172CAD0A7863}']
	{ public }
		function GetFormat(formatType: IType): Variant;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_IFORMATTERCONVERTER)]
	IIFormatterConverter = interface(IObject)
	['{2726DAB8-3F9C-4A59-89BF-4EB0B01146F9}']
	{ public }
		function Convert(value: Variant; type_: IType): Variant; overload;
		function Convert(value: Variant; typeCode: TTypeCode): Variant; overload;
		function ToBoolean(value: Variant): Boolean;
		function ToByte(value: Variant): Byte;
		function ToChar(value: Variant): Char;
		function ToDateTime(value: Variant): TDateTime;
		function ToDecimal(value: Variant): IDecimal;
		function ToDouble(value: Variant): Double;
		function ToInt16(value: Variant): SmallInt;
		function ToInt32(value: Variant): Integer;
		function ToInt64(value: Variant): Int64;
		function ToSByte(value: Variant): Shortint;
		function ToSingle(value: Variant): Single;
		function ToString(value: Variant): String;
		function ToUInt16(value: Variant): Word;
		function ToUInt32(value: Variant): longword;
		function ToUInt64(value: Variant): UInt64;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_IHASHCODEPROVIDER)]
	IIHashCodeProvider = interface(IObject)
	['{607AE034-FE79-45F7-95AF-3563220A0835}']
	{ public }
		function GetHashCode(obj: Variant): Integer;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PRINCIPAL_IIDENTITY)]
	IIIdentity = interface(IObject)
	['{F90ACDD6-FBB2-4229-B774-12BCE62942EB}']
	{ private }
		function _GetProp_AuthenticationType: String;
		function _GetProp_IsAuthenticated: Boolean;
		function _GetProp_Name: String;
	{ public }
		property AuthenticationType: String read _GetProp_AuthenticationType;
		property IsAuthenticated: Boolean read _GetProp_IsAuthenticated;
		property Name: String read _GetProp_Name;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_ILGENERATOR)]
	IILGenerator = interface(IObject)
	['{DF932A46-873E-4354-98E9-EA16F3077048}']
	{ private }
		function _GetProp_ILOffset: Integer;
	{ public }
		procedure BeginCatchBlock(exceptionType: IType);
		procedure BeginExceptFilterBlock();
		function BeginExceptionBlock(): ILabel;
		procedure BeginFaultBlock();
		procedure BeginFinallyBlock();
		procedure BeginScope();
		function DeclareLocal(localType: IType): ILocalBuilder; overload;
		function DeclareLocal(localType: IType; pinned: Boolean): ILocalBuilder; overload;
		function DefineLabel(): ILabel;
		procedure Emit(opcode: IOpCode); overload;
		procedure Emit(opcode: IOpCode; arg: Byte); overload;
		procedure Emit(opcode: IOpCode; arg: Shortint); overload;
		procedure Emit(opcode: IOpCode; arg: SmallInt); overload;
		procedure Emit(opcode: IOpCode; arg: Integer); overload;
		procedure Emit(opcode: IOpCode; meth: IMethodInfo); overload;
		procedure Emit(opcode: IOpCode; signature: ISignatureHelper); overload;
		procedure Emit(opcode: IOpCode; con: IConstructorInfo); overload;
		procedure Emit(opcode: IOpCode; cls: IType); overload;
		procedure Emit(opcode: IOpCode; arg: Int64); overload;
		procedure Emit(opcode: IOpCode; arg: Single); overload;
		procedure Emit(opcode: IOpCode; arg: Double); overload;
		procedure Emit(opcode: IOpCode; label_: ILabel); overload;
		procedure Emit(opcode: IOpCode; labels: ICoreClrBridgeArray<ILabel>); overload;
		procedure Emit(opcode: IOpCode; field: IFieldInfo); overload;
		procedure Emit(opcode: IOpCode; str: String); overload;
		procedure Emit(opcode: IOpCode; local: ILocalBuilder); overload;
		procedure EmitCall(opcode: IOpCode; methodInfo: IMethodInfo; optionalParameterTypes: ICoreClrBridgeArray<IType>);
		procedure EmitCalli(opcode: IOpCode; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>; optionalParameterTypes: ICoreClrBridgeArray<IType>); overload;
		procedure EmitCalli(opcode: IOpCode; unmanagedCallConv: TCallingConvention; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>); overload;
		procedure EmitWriteLine(value: String); overload;
		procedure EmitWriteLine(localBuilder: ILocalBuilder); overload;
		procedure EmitWriteLine(fld: IFieldInfo); overload;
		procedure EndExceptionBlock();
		procedure EndScope();
		procedure MarkLabel(loc: ILabel);
		procedure MarkSequencePoint(document: IISymbolDocumentWriter; startLine: Integer; startColumn: Integer; endLine: Integer; endColumn: Integer);
		procedure ThrowException(excType: IType);
		procedure UsingNamespace(usingNamespace: String);
		property ILOffset: Integer read _GetProp_ILOffset;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ILIST)]
	IIList = interface(IObject)
	['{063E240F-528D-4902-9CF9-6E1E4CEC01B7}']
	{ private }
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_Item(index: Integer): Variant;
		procedure _SetProp_Item(index: Integer; Value: Variant);
	{ public }
		function Add(value: Variant): Integer;
		procedure Clear();
		function Contains(value: Variant): Boolean;
		function IndexOf(value: Variant): Integer;
		procedure Insert(index: Integer; value: Variant);
		procedure Remove(value: Variant);
		procedure RemoveAt(index: Integer);
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property Item[index: Integer]: Variant read _GetProp_Item write _SetProp_Item; default;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ILIST_1)]
	IIList<T> = interface(IObject)
	['{EDEA86BC-80D2-4F79-BDDF-4150C61E911D}']
	{ private }
		function _GetProp_Item(index: Integer): T;
		procedure _SetProp_Item(index: Integer; Value: T);
	{ public }
		function IndexOf(item: T): Integer;
		procedure Insert(index: Integer; item: T);
		procedure RemoveAt(index: Integer);
		property Item[index: Integer]: T read _GetProp_Item write _SetProp_Item; default;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_IMEMORYOWNER_1)]
	IIMemoryOwner<T> = interface(IObject)
	['{BE9FC9AD-A650-46EF-AD84-1B45F6E9C597}']
	{ private }
		function _GetProp_Memory: IMemory<T>;
	{ public }
		property Memory: IMemory<T> read _GetProp_Memory;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IMONIKER)]
	IIMoniker = interface(IObject)
	['{1EB244AF-25FB-4615-95DF-415C564BB53A}']
	{ public }
		procedure BindToObject(pbc: IIBindCtx; pmkToLeft: IIMoniker; var riidResult: IGuid; var ppvResult: Variant);
		procedure BindToStorage(pbc: IIBindCtx; pmkToLeft: IIMoniker; var riid: IGuid; var ppvObj: Variant);
		procedure CommonPrefixWith(pmkOther: IIMoniker; var ppmkPrefix: IIMoniker);
		procedure ComposeWith(pmkRight: IIMoniker; fOnlyIfNotGeneric: Boolean; var ppmkComposite: IIMoniker);
		procedure Enum(fForward: Boolean; var ppenumMoniker: IIEnumMoniker);
		procedure GetClassID(var pClassID: IGuid);
		procedure GetDisplayName(pbc: IIBindCtx; pmkToLeft: IIMoniker; var ppszDisplayName: String);
		procedure GetSizeMax(var pcbSize: Int64);
		procedure GetTimeOfLastChange(pbc: IIBindCtx; pmkToLeft: IIMoniker; var pFileTime: IFILETIME);
		procedure Hash(var pdwHash: Integer);
		procedure Inverse(var ppmk: IIMoniker);
		function IsDirty(): Integer;
		function IsEqual(pmkOtherMoniker: IIMoniker): Integer;
		function IsRunning(pbc: IIBindCtx; pmkToLeft: IIMoniker; pmkNewlyRunning: IIMoniker): Integer;
		function IsSystemMoniker(var pdwMksys: Integer): Integer;
		procedure Load(pStm: IIStream);
		procedure ParseDisplayName(pbc: IIBindCtx; pmkToLeft: IIMoniker; pszDisplayName: String; var pchEaten: Integer; var ppmkOut: IIMoniker);
		procedure Reduce(pbc: IIBindCtx; dwReduceHowFar: Integer; var ppmkToLeft: IIMoniker; var ppmkReduced: IIMoniker);
		procedure RelativePathTo(pmkOther: IIMoniker; var ppmkRelPath: IIMoniker);
		procedure Save(pStm: IIStream; fClearDirty: Boolean);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_INATTRIBUTE)]
	IInAttribute = interface(IAttribute)
	['{099AF724-2BEA-4D07-AD95-B15E8A09A0CD}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_INCREMENTINGEVENTCOUNTER)]
	IIncrementingEventCounter = interface(IDiagnosticCounter)
	['{1D6BCD29-0FFE-412B-94F8-EF1D114C8971}']
	{ private }
		function _GetProp_DisplayRateTimeScale: ITimeSpan;
		procedure _SetProp_DisplayRateTimeScale(Value: ITimeSpan);
	{ public }
		procedure Increment(increment: Double);
		property DisplayRateTimeScale: ITimeSpan read _GetProp_DisplayRateTimeScale write _SetProp_DisplayRateTimeScale;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_INCREMENTINGPOLLINGCOUNTER)]
	IIncrementingPollingCounter = interface(IDiagnosticCounter)
	['{E84A423E-AB7C-4E7D-82F5-177409596F8A}']
	{ private }
		function _GetProp_DisplayRateTimeScale: ITimeSpan;
		procedure _SetProp_DisplayRateTimeScale(Value: ITimeSpan);
	{ public }
		property DisplayRateTimeScale: ITimeSpan read _GetProp_DisplayRateTimeScale write _SetProp_DisplayRateTimeScale;
	end;

	ITextWriterClass = interface(ICoreClrClass)
	['{565392A4-86A0-4231-8331-32D29FB3F278}']
	{ private }
		{ class } function _GetFld_Null: ITextWriter;
	{ public }
		{ class } function Synchronized(writer: ITextWriter): ITextWriter;
		{ class } property Null: ITextWriter read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_TEXTWRITER)]
	ITextWriter = interface(IMarshalByRefObject)
	['{299D1FB6-B8E3-4ED3-8437-CDC78116C2FD}']
	{ private }
		function _GetProp_Encoding: IEncoding;
		function _GetProp_FormatProvider: IIFormatProvider;
		function _GetProp_NewLine: String;
		procedure _SetProp_NewLine(Value: String);
	{ public }
		procedure Close();
		procedure Dispose();
		function DisposeAsync(): IValueTask;
		procedure Flush();
		function FlushAsync(): ITask;
		procedure Write(value: Boolean); overload;
		procedure Write(value: Integer); overload;
		procedure Write(value: longword); overload;
		procedure Write(value: Int64); overload;
		procedure Write(value: UInt64); overload;
		procedure Write(value: Single); overload;
		procedure Write(value: Double); overload;
		procedure Write(value: IDecimal); overload;
		procedure Write(value: Variant); overload;
		procedure Write(value: IStringBuilder); overload;
		procedure Write(buffer: TArray<Char>); overload;
		procedure Write(value: Char); overload;
		procedure Write(buffer: IReadOnlySpan<Char>); overload;
		procedure Write(value: String); overload;
		procedure Write(format: String; arg0: Variant); overload;
		procedure Write(format: String; arg: TArray<Variant>); overload;
		procedure Write(format: String; arg0: Variant; arg1: Variant); overload;
		procedure Write(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		procedure Write(format: String; arg0: Variant; arg1: Variant; arg2: Variant); overload;
		function WriteAsync(value: IStringBuilder; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(value: Char): ITask; overload;
		function WriteAsync(value: String): ITask; overload;
		function WriteAsync(buffer: TArray<Char>): ITask; overload;
		function WriteAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		procedure WriteLine(); overload;
		procedure WriteLine(value: Char); overload;
		procedure WriteLine(buffer: TArray<Char>); overload;
		procedure WriteLine(value: Boolean); overload;
		procedure WriteLine(value: Integer); overload;
		procedure WriteLine(value: longword); overload;
		procedure WriteLine(value: Int64); overload;
		procedure WriteLine(value: UInt64); overload;
		procedure WriteLine(value: Single); overload;
		procedure WriteLine(value: Double); overload;
		procedure WriteLine(value: IDecimal); overload;
		procedure WriteLine(value: IStringBuilder); overload;
		procedure WriteLine(value: Variant); overload;
		procedure WriteLine(value: String); overload;
		procedure WriteLine(buffer: IReadOnlySpan<Char>); overload;
		procedure WriteLine(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		procedure WriteLine(format: String; arg0: Variant; arg1: Variant); overload;
		procedure WriteLine(format: String; arg0: Variant); overload;
		procedure WriteLine(format: String; arg: TArray<Variant>); overload;
		procedure WriteLine(format: String; arg0: Variant; arg1: Variant; arg2: Variant); overload;
		function WriteLineAsync(value: IStringBuilder; cancellationToken: ICancellationToken): ITask; overload;
		function WriteLineAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		function WriteLineAsync(): ITask; overload;
		function WriteLineAsync(value: Char): ITask; overload;
		function WriteLineAsync(value: String): ITask; overload;
		function WriteLineAsync(buffer: TArray<Char>): ITask; overload;
		function WriteLineAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		property Encoding: IEncoding read _GetProp_Encoding;
		property FormatProvider: IIFormatProvider read _GetProp_FormatProvider;
		property NewLine: String read _GetProp_NewLine write _SetProp_NewLine;
	end;

	IIndentedTextWriterClass = interface(ICoreClrClass)
	['{E505C80E-30B1-4795-85DC-A8BFFB48B361}']
	{ private }
		{ class } function _GetFld_DefaultTabString: String;
	{ public }
		{ class } property DefaultTabString: String read _GetFld_DefaultTabString;
	end;

	[CoreTypeSignature(SYSTEM_CODEDOM_COMPILER_INDENTEDTEXTWRITER)]
	IIndentedTextWriter = interface(ITextWriter)
	['{5D123B6A-1564-436B-992B-22C167631915}']
	{ private }
		function _GetProp_Encoding: IEncoding;
		function _GetProp_Indent: Integer;
		procedure _SetProp_Indent(Value: Integer);
		function _GetProp_InnerWriter: ITextWriter;
		function _GetProp_NewLine: String;
		procedure _SetProp_NewLine(Value: String);
	{ public }
		procedure Close();
		procedure Flush();
		procedure Write(s: String); overload;
		procedure Write(value: Boolean); overload;
		procedure Write(value: Char); overload;
		procedure Write(buffer: TArray<Char>); overload;
		procedure Write(value: Double); overload;
		procedure Write(value: Single); overload;
		procedure Write(value: Integer); overload;
		procedure Write(value: Int64); overload;
		procedure Write(value: Variant); overload;
		procedure Write(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		procedure Write(format: String; arg0: Variant; arg1: Variant); overload;
		procedure Write(format: String; arg0: Variant); overload;
		procedure Write(format: String; arg: TArray<Variant>); overload;
		procedure WriteLine(s: String); overload;
		procedure WriteLine(value: Boolean); overload;
		procedure WriteLine(value: Char); overload;
		procedure WriteLine(buffer: TArray<Char>); overload;
		procedure WriteLine(value: Double); overload;
		procedure WriteLine(value: Single); overload;
		procedure WriteLine(value: Integer); overload;
		procedure WriteLine(value: Int64); overload;
		procedure WriteLine(value: Variant); overload;
		procedure WriteLine(value: longword); overload;
		procedure WriteLine(); overload;
		procedure WriteLine(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		procedure WriteLine(format: String; arg0: Variant; arg1: Variant); overload;
		procedure WriteLine(format: String; arg0: Variant); overload;
		procedure WriteLine(format: String; arg: TArray<Variant>); overload;
		procedure WriteLineNoTabs(s: String);
		property Encoding: IEncoding read _GetProp_Encoding;
		property Indent: Integer read _GetProp_Indent write _SetProp_Indent;
		property InnerWriter: ITextWriter read _GetProp_InnerWriter;
		property NewLine: String read _GetProp_NewLine write _SetProp_NewLine;
	end;

	IIndexClass = interface(ICoreClrClass)
	['{22AE3309-16E6-4DFF-9431-F8D10B6B2D3B}']
	{ private }
		{ class } function _GetProp_End: IIndex;
		{ class } function _GetProp_Start: IIndex;
	{ public }
		{ class } function FromEnd(value: Integer): IIndex;
		{ class } function FromStart(value: Integer): IIndex;
		{ class } property &End: IIndex read _GetProp_End;
		{ class } property Start: IIndex read _GetProp_Start;
	end;

	[CoreTypeSignature(SYSTEM_INDEX)]
	IIndex = interface(IValueType)
	['{A0C76D64-8805-483E-9A0C-CB2ADAA39822}']
	{ private }
		function _GetProp_IsFromEnd: Boolean;
		function _GetProp_Value: Integer;
	{ public }
		function Equals(other: IIndex): Boolean;
		function GetOffset(length: Integer): Integer;
		property IsFromEnd: Boolean read _GetProp_IsFromEnd;
		property Value: Integer read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_INDEXERNAMEATTRIBUTE)]
	IIndexerNameAttribute = interface(IAttribute)
	['{FD2C5FC1-E924-4176-9D3B-B217F1CB461C}']
	end;

	[CoreTypeSignature(SYSTEM_INDEXOUTOFRANGEEXCEPTION)]
	IIndexOutOfRangeException = interface(ISystemException)
	['{B25C36F8-2C85-4DAD-9C1B-1EC9A75E5374}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_INOTIFYCOMPLETION)]
	IINotifyCompletion = interface(IObject)
	['{DB60C487-F05F-4DD5-B553-5B3CDA58E47F}']
	{ public }
		procedure OnCompleted(continuation: TClrAction);
	end;

	[CoreTypeSignature(SYSTEM_INSUFFICIENTEXECUTIONSTACKEXCEPTION)]
	IInsufficientExecutionStackException = interface(ISystemException)
	['{6BFA2A96-7234-421A-9550-B61E27713A2B}']
	end;

	[CoreTypeSignature(SYSTEM_OUTOFMEMORYEXCEPTION)]
	IOutOfMemoryException = interface(ISystemException)
	['{533650D6-CC4B-414E-B903-C290CB9E63C8}']
	end;

	[CoreTypeSignature(SYSTEM_INSUFFICIENTMEMORYEXCEPTION)]
	IInsufficientMemoryException = interface(IOutOfMemoryException)
	['{56EC2E59-7D67-48E5-B0B6-74087CF9B98F}']
	end;

	IInt16Class = interface(ICoreClrClass)
	['{212BC50A-5C11-4DA6-8D1B-9923A48E8B6A}']
	{ private }
		{ class } function _GetFld_MaxValue: SmallInt;
		{ class } function _GetFld_MinValue: SmallInt;
	{ public }
		{ class } function Parse(s: String): SmallInt; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): SmallInt; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): SmallInt; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): SmallInt; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): SmallInt; overload;
		{ class } function TryParse(s: String; var result_: SmallInt): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: SmallInt): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: SmallInt): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: SmallInt): Boolean; overload;
		{ class } property MaxValue: SmallInt read _GetFld_MaxValue;
		{ class } property MinValue: SmallInt read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_INT16)]
	IInt16 = interface(IValueType)
	['{29F26C69-1D7F-48DD-8D57-4CC1E4A7E5C7}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: SmallInt): Integer; overload;
		function Equals(obj: SmallInt): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IInt32Class = interface(ICoreClrClass)
	['{D15B15C1-DB35-4F1F-BBC2-F71B4D992309}']
	{ private }
		{ class } function _GetFld_MaxValue: Integer;
		{ class } function _GetFld_MinValue: Integer;
	{ public }
		{ class } function Parse(s: String): Integer; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Integer; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Integer; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Integer; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Integer; overload;
		{ class } function TryParse(s: String; var result_: Integer): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Integer): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Integer): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Integer): Boolean; overload;
		{ class } property MaxValue: Integer read _GetFld_MaxValue;
		{ class } property MinValue: Integer read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_INT32)]
	IInt32 = interface(IValueType)
	['{D74BDE1E-9B55-4F55-8EB9-90C32A6FD323}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Integer): Integer; overload;
		function Equals(obj: Integer): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IInt64Class = interface(ICoreClrClass)
	['{64C6ED66-C679-422F-B76B-1FD34AA15ECF}']
	{ private }
		{ class } function _GetFld_MaxValue: Int64;
		{ class } function _GetFld_MinValue: Int64;
	{ public }
		{ class } function Parse(s: String): Int64; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Int64; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Int64; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Int64; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Int64; overload;
		{ class } function TryParse(s: String; var result_: Int64): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Int64): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Int64): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Int64): Boolean; overload;
		{ class } property MaxValue: Int64 read _GetFld_MaxValue;
		{ class } property MinValue: Int64 read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_INT64_)]
	IInt64 = interface(IValueType)
	['{5B00697C-6957-45FA-AEF7-7D6B51D888C9}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Int64): Integer; overload;
		function Equals(obj: Int64): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_INTERFACEMAPPING)]
	IInterfaceMapping = interface(IValueType)
	['{14291D32-445A-41EE-85BE-35E849E5542B}']
	{ private }
		function _GetFld_InterfaceMethods: ICoreClrBridgeArray<IMethodInfo>;
		procedure _SetFld_InterfaceMethods(Value: ICoreClrBridgeArray<IMethodInfo>);
		function _GetFld_InterfaceType: IType;
		procedure _SetFld_InterfaceType(Value: IType);
		function _GetFld_TargetMethods: ICoreClrBridgeArray<IMethodInfo>;
		procedure _SetFld_TargetMethods(Value: ICoreClrBridgeArray<IMethodInfo>);
		function _GetFld_TargetType: IType;
		procedure _SetFld_TargetType(Value: IType);
	{ public }
		property InterfaceMethods: ICoreClrBridgeArray<IMethodInfo> read _GetFld_InterfaceMethods write _SetFld_InterfaceMethods;
		property InterfaceType: IType read _GetFld_InterfaceType write _SetFld_InterfaceType;
		property TargetMethods: ICoreClrBridgeArray<IMethodInfo> read _GetFld_TargetMethods write _SetFld_TargetMethods;
		property TargetType: IType read _GetFld_TargetType write _SetFld_TargetType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_INTERFACETYPEATTRIBUTE)]
	IInterfaceTypeAttribute = interface(IAttribute)
	['{032B0D6F-8FD0-447F-A641-32D2BDBCE5AB}']
	{ private }
		function _GetProp_Value: TComInterfaceType;
	{ public }
		property Value: TComInterfaceType read _GetProp_Value;
	end;

	IInterlockedClass = interface(ICoreClrClass)
	['{D703F998-21DA-4C0A-8B87-DFA2577F7E40}']
	{ public }
		{ class } function Add(var location1: Integer; value: Integer): Integer; overload;
		{ class } function Add(var location1: Int64; value: Int64): Int64; overload;
		{ class } function Add(var location1: longword; value: longword): longword; overload;
		{ class } function Add(var location1: UInt64; value: UInt64): UInt64; overload;
		{ class } function &And(var location1: Integer; value: Integer): Integer; overload;
		{ class } function &And(var location1: longword; value: longword): longword; overload;
		{ class } function &And(var location1: Int64; value: Int64): Int64; overload;
		{ class } function &And(var location1: UInt64; value: UInt64): UInt64; overload;
		{ class } function CompareExchange(var location1: Integer; value: Integer; comparand: Integer): Integer; overload;
		{ class } function CompareExchange(var location1: Int64; value: Int64; comparand: Int64): Int64; overload;
		{ class } function CompareExchange(var location1: Single; value: Single; comparand: Single): Single; overload;
		{ class } function CompareExchange(var location1: Double; value: Double; comparand: Double): Double; overload;
		{ class } function CompareExchange(var location1: Variant; value: Variant; comparand: Variant): Variant; overload;
		{ class } function CompareExchange(var location1: IIntPtr; value: IIntPtr; comparand: IIntPtr): IIntPtr; overload;
		{ class } function CompareExchange(T: PTypeInfo; var location1: Variant{T}; value: Variant{T}; comparand: Variant{T}): Variant{T}; overload;
		{ class } function CompareExchange(var location1: longword; value: longword; comparand: longword): longword; overload;
		{ class } function CompareExchange(var location1: UInt64; value: UInt64; comparand: UInt64): UInt64; overload;
		{ class } function Decrement(var location: Integer): Integer; overload;
		{ class } function Decrement(var location: Int64): Int64; overload;
		{ class } function Decrement(var location: longword): longword; overload;
		{ class } function Decrement(var location: UInt64): UInt64; overload;
		{ class } function Exchange(var location1: Integer; value: Integer): Integer; overload;
		{ class } function Exchange(var location1: Int64; value: Int64): Int64; overload;
		{ class } function Exchange(var location1: Single; value: Single): Single; overload;
		{ class } function Exchange(var location1: Double; value: Double): Double; overload;
		{ class } function Exchange(var location1: Variant; value: Variant): Variant; overload;
		{ class } function Exchange(var location1: IIntPtr; value: IIntPtr): IIntPtr; overload;
		{ class } function Exchange(T: PTypeInfo; var location1: Variant{T}; value: Variant{T}): Variant{T}; overload;
		{ class } function Exchange(var location1: longword; value: longword): longword; overload;
		{ class } function Exchange(var location1: UInt64; value: UInt64): UInt64; overload;
		{ class } function Increment(var location: Integer): Integer; overload;
		{ class } function Increment(var location: Int64): Int64; overload;
		{ class } function Increment(var location: longword): longword; overload;
		{ class } function Increment(var location: UInt64): UInt64; overload;
		{ class } procedure MemoryBarrier();
		{ class } procedure MemoryBarrierProcessWide();
		{ class } function &Or(var location1: Integer; value: Integer): Integer; overload;
		{ class } function &Or(var location1: longword; value: longword): longword; overload;
		{ class } function &Or(var location1: Int64; value: Int64): Int64; overload;
		{ class } function &Or(var location1: UInt64; value: UInt64): UInt64; overload;
		{ class } function Read(var location: Int64): Int64; overload;
		{ class } function Read(var location: UInt64): UInt64; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_INTERLOCKED)]
	IInterlocked = interface(IObject)
	['{AAEECA4E-8BBF-4F2D-862C-98E6BFF6E034}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_INTERNALSVISIBLETOATTRIBUTE)]
	IInternalsVisibleToAttribute = interface(IAttribute)
	['{4C802B32-ED2B-428A-A3AA-4AD73BC09D4A}']
	{ private }
		function _GetProp_AllInternalsVisible: Boolean;
		procedure _SetProp_AllInternalsVisible(Value: Boolean);
		function _GetProp_AssemblyName: String;
	{ public }
		property AllInternalsVisible: Boolean read _GetProp_AllInternalsVisible write _SetProp_AllInternalsVisible;
		property AssemblyName: String read _GetProp_AssemblyName;
	end;

	IIntPtrClass = interface(ICoreClrClass)
	['{7C11D337-D06E-40B0-BB5F-1DA257ED10AE}']
	{ private }
		{ class } function _GetFld_Zero: IIntPtr;
		{ class } function _GetProp_MaxValue: IIntPtr;
		{ class } function _GetProp_MinValue: IIntPtr;
		{ class } function _GetProp_Size: Integer;
	{ public }
		{ class } function Add(pointer: IIntPtr; offset: Integer): IIntPtr;
		{ class } function Parse(s: String): IIntPtr; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): IIntPtr; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): IIntPtr; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): IIntPtr; overload;
		{ class } function Subtract(pointer: IIntPtr; offset: Integer): IIntPtr;
		{ class } function TryParse(s: String; var result_: IIntPtr): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IIntPtr): Boolean; overload;
		{ class } property Zero: IIntPtr read _GetFld_Zero;
		{ class } property MaxValue: IIntPtr read _GetProp_MaxValue;
		{ class } property MinValue: IIntPtr read _GetProp_MinValue;
		{ class } property Size: Integer read _GetProp_Size;
	end;

	[CoreTypeSignature(SYSTEM_INTPTR)]
	IIntPtr = interface(IValueType)
	['{09080550-FCE9-45F2-A828-A14B183F1420}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: IIntPtr): Integer; overload;
		function Equals(other: IIntPtr): Boolean;
		function ToInt32(): Integer;
		function ToInt64(): Int64;
		function ToPointer(): ICoreClrInstance;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
	end;

	IIntrospectionExtensionsClass = interface(ICoreClrClass)
	['{2A196296-AF84-4D35-B306-B0A8840F24F4}']
	{ public }
		{ class } function GetTypeInfo(type_: IType): ITypeInfo;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_INTROSPECTIONEXTENSIONS)]
	IIntrospectionExtensions = interface(IObject)
	['{C2D7927F-DCE0-4DD1-B84D-6778A2361ED3}']
	end;

	[CoreTypeSignature(SYSTEM_INVALIDCASTEXCEPTION)]
	IInvalidCastException = interface(ISystemException)
	['{7B04C281-3326-4AAD-B776-3E0A7B2C28DF}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_INVALIDCOMOBJECTEXCEPTION)]
	IInvalidComObjectException = interface(ISystemException)
	['{A360DA88-A5F2-4B53-BF7C-4E1A19D3DC45}']
	end;

	[CoreTypeSignature(SYSTEM_IO_INVALIDDATAEXCEPTION)]
	IInvalidDataException = interface(ISystemException)
	['{7C771E5D-7A3E-4B3C-B1A4-ABFF808C9286}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_INVALIDFILTERCRITERIAEXCEPTION)]
	IInvalidFilterCriteriaException = interface(IApplicationException)
	['{5990A1B0-EC3E-4BE9-BE7C-36F71C7CC648}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_INVALIDOLEVARIANTTYPEEXCEPTION)]
	IInvalidOleVariantTypeException = interface(ISystemException)
	['{8D3CF574-D9D9-44C5-8E19-791A7D9CBD8F}']
	end;

	[CoreTypeSignature(SYSTEM_INVALIDOPERATIONEXCEPTION)]
	IInvalidOperationException = interface(ISystemException)
	['{6A8ACADA-49C7-465D-B0C0-1E8BFB046D2D}']
	end;

	[CoreTypeSignature(SYSTEM_INVALIDPROGRAMEXCEPTION)]
	IInvalidProgramException = interface(ISystemException)
	['{8444B3FE-ADD3-4D80-A610-41459CDC105A}']
	end;

	[CoreTypeSignature(SYSTEM_INVALIDTIMEZONEEXCEPTION)]
	IInvalidTimeZoneException = interface(IException)
	['{2F805BA8-3751-4B26-884E-B4913F6ADE33}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_IOBJECTREFERENCE)]
	IIObjectReference = interface(IObject)
	['{F122A479-5C12-4063-867C-AFABD1E0479A}']
	{ public }
		function GetRealObject(context: IStreamingContext): Variant;
	end;

	[CoreTypeSignature(SYSTEM_IOBSERVABLE_1)]
	IIObservable<T> = interface(IObject)
	['{8CFE6F10-4A24-4256-BE34-89D2B229617D}']
	{ public }
		function Subscribe(observer: IIObserver<T>): IIDisposable;
	end;

	[CoreTypeSignature(SYSTEM_IOBSERVER_1)]
	IIObserver<T> = interface(IObject)
	['{55CC811B-2E5F-4F09-8200-8BDD50DB0A91}']
	{ public }
		procedure OnCompleted();
		procedure OnError(error: IException);
		procedure OnNext(value: T);
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_IPERMISSION)]
	IIPermission = interface(IObject)
	['{283527ED-F538-4729-80B6-09D78A1EF1E8}']
	{ public }
		function Copy(): IIPermission;
		procedure Demand();
		function Intersect(target: IIPermission): IIPermission;
		function IsSubsetOf(target: IIPermission): Boolean;
		function Union(target: IIPermission): IIPermission;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IPERSISTFILE)]
	IIPersistFile = interface(IObject)
	['{72820445-E051-4B0D-A5E6-0F1E16B568E5}']
	{ public }
		procedure GetClassID(var pClassID: IGuid);
		procedure GetCurFile(var ppszFileName: String);
		function IsDirty(): Integer;
		procedure Load(pszFileName: String; dwMode: Integer);
		procedure Save(pszFileName: String; fRemember: Boolean);
		procedure SaveCompleted(pszFileName: String);
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_IPINNABLE)]
	IIPinnable = interface(IObject)
	['{F64AFA65-5195-4ED0-8C8F-CE6A6F8DDACB}']
	{ public }
		function Pin(elementIndex: Integer): IMemoryHandle;
		procedure Unpin();
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PRINCIPAL_IPRINCIPAL)]
	IIPrincipal = interface(IObject)
	['{1BF6B43A-3AE6-41D3-ACCE-93D778D2F30F}']
	{ private }
		function _GetProp_Identity: IIIdentity;
	{ public }
		function IsInRole(role: String): Boolean;
		property Identity: IIIdentity read _GetProp_Identity;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_CONCURRENT_IPRODUCERCONSUMERCOLLECTION_1)]
	IIProducerConsumerCollection<T> = interface(IObject)
	['{23088088-3695-427C-88F2-65EC4F03FA9A}']
	{ public }
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; index: Integer);
		function ToArray(): TArray<T>;
		function TryAdd(item: T): Boolean;
		function TryTake(var item: T): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_IPROGRESS_1)]
	IIProgress<T> = interface(IObject)
	['{398FE055-DB4A-4F7E-BE76-E78FB73DED46}']
	{ public }
		procedure Report(value: T);
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IREADONLYCOLLECTION_1)]
	IIReadOnlyCollection<T> = interface(IObject)
	['{915AE7E0-1FF2-434A-9153-BDA118908690}']
	{ private }
		function _GetProp_Count: Integer;
	{ public }
		property Count: Integer read _GetProp_Count;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IREADONLYDICTIONARY_2)]
	IIReadOnlyDictionary<TKey,TValue> = interface(IObject)
	['{C79E1BD1-F652-4228-BBCA-DDC4B650C6D4}']
	{ private }
		function _GetProp_Item(key: TKey): TValue;
		function _GetProp_Keys: IIEnumerable<TKey>;
		function _GetProp_Values: IIEnumerable<TValue>;
	{ public }
		function ContainsKey(key: TKey): Boolean;
		function TryGetValue(key: TKey; var value: TValue): Boolean;
		property Item[key: TKey]: TValue read _GetProp_Item; default;
		property Keys: IIEnumerable<TKey> read _GetProp_Keys;
		property Values: IIEnumerable<TValue> read _GetProp_Values;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IREADONLYLIST_1)]
	IIReadOnlyList<T> = interface(IObject)
	['{1DD8E8AB-FEFB-4BA2-B792-24E0C2B09AEA}']
	{ private }
		function _GetProp_Item(index: Integer): T;
	{ public }
		property Item[index: Integer]: T read _GetProp_Item; default;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_IREADONLYSET_1)]
	IIReadOnlySet<T> = interface(IObject)
	['{37333BA6-C56D-4C69-9E64-1F8A4966F2AF}']
	{ public }
		function Contains(item: T): Boolean;
		function IsProperSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsProperSupersetOf(other: IIEnumerable<T>): Boolean;
		function IsSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsSupersetOf(other: IIEnumerable<T>): Boolean;
		function Overlaps(other: IIEnumerable<T>): Boolean;
		function SetEquals(other: IIEnumerable<T>): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_IREFLECT)]
	IIReflect = interface(IObject)
	['{4254A9C5-6C45-4F71-A1C4-99A0EA48810C}']
	{ private }
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetMember(name: String; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set): IMethodInfo; overload;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>;
		function GetProperty(name: String; bindingAttr: TBindingFlags_Set): IPropertyInfo; overload;
		function GetProperty(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; returnType: IType; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IPropertyInfo; overload;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_IREFLECTABLETYPE)]
	IIReflectableType = interface(IObject)
	['{F296D98D-B1EE-44EC-B5B1-D81A65ECE188}']
	{ public }
		function GetTypeInfo(): ITypeInfo;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_IRESOURCEREADER)]
	IIResourceReader = interface(IObject)
	['{D605CA1C-8348-4BF1-BD68-1A9DD7943D19}']
	{ public }
		procedure Close();
		function GetEnumerator(): IIDictionaryEnumerator;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_IRUNNINGOBJECTTABLE)]
	IIRunningObjectTable = interface(IObject)
	['{89057D8D-EDFF-435D-843B-67410CBDE9D9}']
	{ public }
		procedure EnumRunning(var ppenumMoniker: IIEnumMoniker);
		function GetObject(pmkObjectName: IIMoniker; var ppunkObject: Variant): Integer;
		function GetTimeOfLastChange(pmkObjectName: IIMoniker; var pfiletime: IFILETIME): Integer;
		function IsRunning(pmkObjectName: IIMoniker): Integer;
		procedure NoteChangeTime(dwRegister: Integer; var pfiletime: IFILETIME);
		function &Register(grfFlags: Integer; punkObject: Variant; pmkObjectName: IIMoniker): Integer;
		procedure Revoke(dwRegister: Integer);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ISAFESERIALIZATIONDATA)]
	IISafeSerializationData = interface(IObject)
	['{0C24141A-EA32-4181-8542-C99F9D6B0769}']
	{ public }
		procedure CompleteDeserialization(deserialized: Variant);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISBYREFLIKEATTRIBUTE)]
	IIsByRefLikeAttribute = interface(IAttribute)
	['{84EA15BF-9AEC-42CC-A484-7469D3C853A5}']
	end;

	IIsConstClass = interface(ICoreClrClass)
	['{DD7E5DA9-A5F1-4C60-BEF6-F6DF9F874678}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISCONST)]
	IIsConst = interface(IObject)
	['{859E831F-1AD5-4EB5-ACB9-2784ACD166A5}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_ISECURITYENCODABLE)]
	IISecurityEncodable = interface(IObject)
	['{63E7C5E0-7F71-4FE7-B76B-86877E065571}']
	{ public }
		procedure FromXml(e: ISecurityElement);
		function ToXml(): ISecurityElement;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_ISET_1)]
	IISet<T> = interface(IObject)
	['{3DBCCAB1-1362-4E2C-80EF-F1E1DF1B44A2}']
	{ public }
		function Add(item: T): Boolean;
		procedure ExceptWith(other: IIEnumerable<T>);
		procedure IntersectWith(other: IIEnumerable<T>);
		function IsProperSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsProperSupersetOf(other: IIEnumerable<T>): Boolean;
		function IsSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsSupersetOf(other: IIEnumerable<T>): Boolean;
		function Overlaps(other: IIEnumerable<T>): Boolean;
		function SetEquals(other: IIEnumerable<T>): Boolean;
		procedure SymmetricExceptWith(other: IIEnumerable<T>);
		procedure UnionWith(other: IIEnumerable<T>);
	end;

	IIsExternalInitClass = interface(ICoreClrClass)
	['{8B6452CF-7557-464B-9FF1-080CE8957452}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISEXTERNALINIT)]
	IIsExternalInit = interface(IObject)
	['{95214F47-21DA-482D-9E50-A28B477F6A9C}']
	end;

	IISOWeekClass = interface(ICoreClrClass)
	['{2A70028C-B20A-4998-8BDB-F8816BC89DE1}']
	{ public }
		{ class } function GetWeekOfYear(date: TDateTime): Integer;
		{ class } function GetWeeksInYear(year: Integer): Integer;
		{ class } function GetYear(date: TDateTime): Integer;
		{ class } function GetYearEnd(year: Integer): TDateTime;
		{ class } function GetYearStart(year: Integer): TDateTime;
		{ class } function ToDateTime(year: Integer; week: Integer; dayOfWeek: TDayOfWeek): TDateTime;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_ISOWEEK)]
	IISOWeek = interface(IObject)
	['{3FEAF08E-44F5-474B-B0C3-FDBA201E4251}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISREADONLYATTRIBUTE)]
	IIsReadOnlyAttribute = interface(IAttribute)
	['{5DFD080A-0EE2-463F-9A64-4D9B901E9758}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_ISTACKWALK)]
	IIStackWalk = interface(IObject)
	['{EB717F1C-C236-4F31-8415-1E4C3FDFA80A}']
	{ public }
		procedure Assert();
		procedure Demand();
		procedure Deny();
		procedure PermitOnly();
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ISTREAM)]
	IIStream = interface(IObject)
	['{6BBA6ADA-1151-4595-8429-322AF5D69550}']
	{ public }
		procedure Clone(var ppstm: IIStream);
		procedure Commit(grfCommitFlags: Integer);
		procedure CopyTo(pstm: IIStream; cb: Int64; pcbRead: IIntPtr; pcbWritten: IIntPtr);
		procedure LockRegion(libOffset: Int64; cb: Int64; dwLockType: Integer);
		procedure Read(var pv: TArray<Byte>; cb: Integer; pcbRead: IIntPtr);
		procedure Revert();
		procedure Seek(dlibMove: Int64; dwOrigin: Integer; plibNewPosition: IIntPtr);
		procedure SetSize(libNewSize: Int64);
		procedure Stat(var pstatstg: ISTATSTG; grfStatFlag: Integer);
		procedure UnlockRegion(libOffset: Int64; cb: Int64; dwLockType: Integer);
		procedure Write(pv: TArray<Byte>; cb: Integer; pcbWritten: IIntPtr);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISTRONGBOX)]
	IIStrongBox = interface(IObject)
	['{2CA1BE23-413D-411F-A6B2-125604A60B98}']
	{ private }
		function _GetProp_Value: Variant;
		procedure _SetProp_Value(Value: Variant);
	{ public }
		property Value: Variant read _GetProp_Value write _SetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ISTRUCTURALCOMPARABLE)]
	IIStructuralComparable = interface(IObject)
	['{43DC6249-C5A4-46FC-BE25-6B61CF358B46}']
	{ public }
		function CompareTo(other: Variant; comparer: IIComparer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_ISTRUCTURALEQUATABLE)]
	IIStructuralEquatable = interface(IObject)
	['{90EAB203-F0AC-4B7F-9605-90F14DD03B6D}']
	{ public }
		function Equals(other: Variant; comparer: IIEqualityComparer): Boolean;
		function GetHashCode(comparer: IIEqualityComparer): Integer;
	end;

	IIsVolatileClass = interface(ICoreClrClass)
	['{78DDE9E1-318A-4B8C-AD5D-F66B8B1C5D95}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ISVOLATILE)]
	IIsVolatile = interface(IObject)
	['{A16C95B8-532C-416C-9D4D-E658750DE646}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_SYMBOLSTORE_ISYMBOLDOCUMENTWRITER)]
	IISymbolDocumentWriter = interface(IObject)
	['{C56A4677-4560-4D63-905C-4BAE174616E5}']
	{ public }
		procedure SetCheckSum(algorithmId: IGuid; checkSum: TArray<Byte>);
		procedure SetSource(source: TArray<Byte>);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ITERATORSTATEMACHINEATTRIBUTE)]
	IIteratorStateMachineAttribute = interface(IStateMachineAttribute)
	['{08858CDB-2F95-4295-A832-76E3A025A8A2}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_ITHREADPOOLWORKITEM)]
	IIThreadPoolWorkItem = interface(IObject)
	['{1EFBC8AC-0D31-46BE-98FE-B935BDAA9921}']
	{ public }
		procedure Execute();
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_ITUPLE)]
	IITuple = interface(IObject)
	['{849B8E5D-F48B-4BD0-BEDC-771C2062F47A}']
	{ private }
		function _GetProp_Item(index: Integer): Variant;
		function _GetProp_Length: Integer;
	{ public }
		property Item[index: Integer]: Variant read _GetProp_Item; default;
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ITYPECOMP)]
	IITypeComp = interface(IObject)
	['{1DB40901-843A-4B4D-A903-931739DEF91B}']
	{ public }
		procedure Bind(szName: String; lHashVal: Integer; wFlags: SmallInt; var ppTInfo: IITypeInfo; var pDescKind: TDESCKIND; var pBindPtr: IBINDPTR);
		procedure BindType(szName: String; lHashVal: Integer; var ppTInfo: IITypeInfo; var ppTComp: IITypeComp);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ITYPEINFO)]
	IITypeInfo = interface(IObject)
	['{F123B715-9675-4EC4-BD25-FC05006ADE37}']
	{ public }
		procedure AddressOfMember(memid: Integer; invKind: TINVOKEKIND_Set; var ppv: IIntPtr);
		procedure CreateInstance(pUnkOuter: Variant; var riid: IGuid; var ppvObj: Variant);
		procedure GetContainingTypeLib(var ppTLB: IITypeLib; var pIndex: Integer);
		procedure GetDllEntry(memid: Integer; invKind: TINVOKEKIND_Set; pBstrDllName: IIntPtr; pBstrName: IIntPtr; pwOrdinal: IIntPtr);
		procedure GetDocumentation(index: Integer; var strName: String; var strDocString: String; var dwHelpContext: Integer; var strHelpFile: String);
		procedure GetFuncDesc(index: Integer; var ppFuncDesc: IIntPtr);
		procedure GetIDsOfNames(rgszNames: TArray<String>; cNames: Integer; var pMemId: TArray<Integer>);
		procedure GetImplTypeFlags(index: Integer; var pImplTypeFlags: TIMPLTYPEFLAGS_Set);
		procedure GetMops(memid: Integer; var pBstrMops: String);
		procedure GetNames(memid: Integer; var rgBstrNames: TArray<String>; cMaxNames: Integer; var pcNames: Integer);
		procedure GetRefTypeInfo(hRef: Integer; var ppTI: IITypeInfo);
		procedure GetRefTypeOfImplType(index: Integer; var href: Integer);
		procedure GetTypeAttr(var ppTypeAttr: IIntPtr);
		procedure GetTypeComp(var ppTComp: IITypeComp);
		procedure GetVarDesc(index: Integer; var ppVarDesc: IIntPtr);
		procedure Invoke(pvInstance: Variant; memid: Integer; wFlags: SmallInt; var pDispParams: IDISPPARAMS; pVarResult: IIntPtr; pExcepInfo: IIntPtr; var puArgErr: Integer);
		procedure ReleaseFuncDesc(pFuncDesc: IIntPtr);
		procedure ReleaseTypeAttr(pTypeAttr: IIntPtr);
		procedure ReleaseVarDesc(pVarDesc: IIntPtr);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ITYPEINFO2)]
	IITypeInfo2 = interface(IObject)
	['{D698AA0A-6E9C-479A-B8A9-A1E1058AF1A1}']
	{ public }
		procedure AddressOfMember(memid: Integer; invKind: TINVOKEKIND_Set; var ppv: IIntPtr);
		procedure CreateInstance(pUnkOuter: Variant; var riid: IGuid; var ppvObj: Variant);
		procedure GetAllCustData(pCustData: IIntPtr);
		procedure GetAllFuncCustData(index: Integer; pCustData: IIntPtr);
		procedure GetAllImplTypeCustData(index: Integer; pCustData: IIntPtr);
		procedure GetAllParamCustData(indexFunc: Integer; indexParam: Integer; pCustData: IIntPtr);
		procedure GetAllVarCustData(index: Integer; pCustData: IIntPtr);
		procedure GetContainingTypeLib(var ppTLB: IITypeLib; var pIndex: Integer);
		procedure GetCustData(var guid: IGuid; var pVarVal: Variant);
		procedure GetDllEntry(memid: Integer; invKind: TINVOKEKIND_Set; pBstrDllName: IIntPtr; pBstrName: IIntPtr; pwOrdinal: IIntPtr);
		procedure GetDocumentation(index: Integer; var strName: String; var strDocString: String; var dwHelpContext: Integer; var strHelpFile: String);
		procedure GetDocumentation2(memid: Integer; var pbstrHelpString: String; var pdwHelpStringContext: Integer; var pbstrHelpStringDll: String);
		procedure GetFuncCustData(index: Integer; var guid: IGuid; var pVarVal: Variant);
		procedure GetFuncDesc(index: Integer; var ppFuncDesc: IIntPtr);
		procedure GetFuncIndexOfMemId(memid: Integer; invKind: TINVOKEKIND_Set; var pFuncIndex: Integer);
		procedure GetIDsOfNames(rgszNames: TArray<String>; cNames: Integer; var pMemId: TArray<Integer>);
		procedure GetImplTypeCustData(index: Integer; var guid: IGuid; var pVarVal: Variant);
		procedure GetImplTypeFlags(index: Integer; var pImplTypeFlags: TIMPLTYPEFLAGS_Set);
		procedure GetMops(memid: Integer; var pBstrMops: String);
		procedure GetNames(memid: Integer; var rgBstrNames: TArray<String>; cMaxNames: Integer; var pcNames: Integer);
		procedure GetParamCustData(indexFunc: Integer; indexParam: Integer; var guid: IGuid; var pVarVal: Variant);
		procedure GetRefTypeInfo(hRef: Integer; var ppTI: IITypeInfo);
		procedure GetRefTypeOfImplType(index: Integer; var href: Integer);
		procedure GetTypeAttr(var ppTypeAttr: IIntPtr);
		procedure GetTypeComp(var ppTComp: IITypeComp);
		procedure GetTypeFlags(var pTypeFlags: Integer);
		procedure GetTypeKind(var pTypeKind: TTYPEKIND);
		procedure GetVarCustData(index: Integer; var guid: IGuid; var pVarVal: Variant);
		procedure GetVarDesc(index: Integer; var ppVarDesc: IIntPtr);
		procedure GetVarIndexOfMemId(memid: Integer; var pVarIndex: Integer);
		procedure Invoke(pvInstance: Variant; memid: Integer; wFlags: SmallInt; var pDispParams: IDISPPARAMS; pVarResult: IIntPtr; pExcepInfo: IIntPtr; var puArgErr: Integer);
		procedure ReleaseFuncDesc(pFuncDesc: IIntPtr);
		procedure ReleaseTypeAttr(pTypeAttr: IIntPtr);
		procedure ReleaseVarDesc(pVarDesc: IIntPtr);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ITYPELIB)]
	IITypeLib = interface(IObject)
	['{20B358B7-F652-4F59-9801-B7247EC635D8}']
	{ public }
		procedure FindName(szNameBuf: String; lHashVal: Integer; var ppTInfo: ICoreClrBridgeArray<IITypeInfo>; var rgMemId: TArray<Integer>; var pcFound: SmallInt);
		procedure GetDocumentation(index: Integer; var strName: String; var strDocString: String; var dwHelpContext: Integer; var strHelpFile: String);
		procedure GetLibAttr(var ppTLibAttr: IIntPtr);
		procedure GetTypeComp(var ppTComp: IITypeComp);
		procedure GetTypeInfo(index: Integer; var ppTI: IITypeInfo);
		function GetTypeInfoCount(): Integer;
		procedure GetTypeInfoOfGuid(var guid: IGuid; var ppTInfo: IITypeInfo);
		procedure GetTypeInfoType(index: Integer; var pTKind: TTYPEKIND);
		function IsName(szNameBuf: String; lHashVal: Integer): Boolean;
		procedure ReleaseTLibAttr(pTLibAttr: IIntPtr);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_ITYPELIB2)]
	IITypeLib2 = interface(IObject)
	['{DFC44580-7B9C-48B3-9466-1D4787A6E8B7}']
	{ public }
		procedure FindName(szNameBuf: String; lHashVal: Integer; var ppTInfo: ICoreClrBridgeArray<IITypeInfo>; var rgMemId: TArray<Integer>; var pcFound: SmallInt);
		procedure GetAllCustData(pCustData: IIntPtr);
		procedure GetCustData(var guid: IGuid; var pVarVal: Variant);
		procedure GetDocumentation(index: Integer; var strName: String; var strDocString: String; var dwHelpContext: Integer; var strHelpFile: String);
		procedure GetDocumentation2(index: Integer; var pbstrHelpString: String; var pdwHelpStringContext: Integer; var pbstrHelpStringDll: String);
		procedure GetLibAttr(var ppTLibAttr: IIntPtr);
		procedure GetLibStatistics(pcUniqueNames: IIntPtr; var pcchUniqueNames: Integer);
		procedure GetTypeComp(var ppTComp: IITypeComp);
		procedure GetTypeInfo(index: Integer; var ppTI: IITypeInfo);
		function GetTypeInfoCount(): Integer;
		procedure GetTypeInfoOfGuid(var guid: IGuid; var ppTInfo: IITypeInfo);
		procedure GetTypeInfoType(index: Integer; var pTKind: TTYPEKIND);
		function IsName(szNameBuf: String; lHashVal: Integer): Boolean;
		procedure ReleaseTLibAttr(pTLibAttr: IIntPtr);
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_SOURCES_IVALUETASKSOURCE)]
	IIValueTaskSource = interface(IObject)
	['{651223FA-8FE6-4B51-9028-16D9AD1B785A}']
	{ public }
		procedure GetResult(token: SmallInt);
		function GetStatus(token: SmallInt): TValueTaskSourceStatus;
		procedure OnCompleted(continuation: TClrAction<Variant>; state: Variant; token: SmallInt; flags: TValueTaskSourceOnCompletedFlags_Set);
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_SOURCES_IVALUETASKSOURCE_1)]
	IIValueTaskSource<TResult> = interface(IObject)
	['{FC3E0DE0-92A3-4891-8C3C-7CF4E55673A4}']
	{ public }
		function GetResult(token: SmallInt): TResult;
		function GetStatus(token: SmallInt): TValueTaskSourceStatus;
		procedure OnCompleted(continuation: TClrAction<Variant>; state: Variant; token: SmallInt; flags: TValueTaskSourceOnCompletedFlags_Set);
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_JAPANESECALENDAR)]
	IJapaneseCalendar = interface(ICalendar)
	['{33DF59D5-90ED-4150-88B7-1C3E68DC7F90}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetWeekOfYear(time: TDateTime; rule: TCalendarWeekRule; firstDayOfWeek: TDayOfWeek): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IJapaneseLunisolarCalendarClass = interface(ICoreClrClass)
	['{F61F0746-26D4-4E4E-8883-82937B9F54F3}']
	{ private }
		{ class } function _GetFld_JapaneseEra: Integer;
	{ public }
		{ class } property JapaneseEra: Integer read _GetFld_JapaneseEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_JAPANESELUNISOLARCALENDAR)]
	IJapaneseLunisolarCalendar = interface(IEastAsianLunisolarCalendar)
	['{077DFF9E-80D4-4A03-8C0B-626DD62A4A3B}']
	{ private }
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
	end;

	IJulianCalendarClass = interface(ICoreClrClass)
	['{D2AE0628-55AF-4C12-9004-9EA057C3811E}']
	{ private }
		{ class } function _GetFld_JulianEra: Integer;
	{ public }
		{ class } property JulianEra: Integer read _GetFld_JulianEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_JULIANCALENDAR)]
	IJulianCalendar = interface(ICalendar)
	['{0CA12E45-C64A-4F8B-B524-0191D643FB18}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_KEYNOTFOUNDEXCEPTION)]
	IKeyNotFoundException = interface(ISystemException)
	['{4F26A233-5245-41C2-8861-4D73B224B2D8}']
	end;

	IKeyValuePairClass = interface(ICoreClrClass)
	['{9005B925-DE3D-44AD-80B5-549347DE3A91}']
	{ public }
		{ class } function Create(TKey: PTypeInfo; TValue: PTypeInfo; key: Variant{TKey}; value: Variant{TValue}): IKeyValuePair<Variant{TKey},Variant{TValue}>;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_KEYVALUEPAIR)]
	IKeyValuePair = interface(IObject)
	['{E7D2F168-7D7D-4729-8A79-A9FE02AD40CA}']
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_KEYVALUEPAIR_2)]
	IKeyValuePair<TKey,TValue> = interface(IValueType)
	['{F91B09EB-738F-4804-96C0-8C4A94128AA0}']
	{ private }
		function _GetProp_Key: TKey;
		function _GetProp_Value: TValue;
	{ public }
		procedure Deconstruct(var key: TKey; var value: TValue);
		property Key: TKey read _GetProp_Key;
		property Value: TValue read _GetProp_Value;
	end;

	IKeywordsClass = interface(ICoreClrClass)
	['{92067BCF-7B2B-4971-851F-13BB106A014A}']
	{ private }
		{ class } function _GetFld_AsyncCausalityOperation: TEventKeywords_Set;
		{ class } function _GetFld_AsyncCausalityRelation: TEventKeywords_Set;
		{ class } function _GetFld_AsyncCausalitySynchronousWork: TEventKeywords_Set;
		{ class } function _GetFld_AsyncMethod: TEventKeywords_Set;
		{ class } function _GetFld_Debug: TEventKeywords_Set;
		{ class } function _GetFld_DebugActivityId: TEventKeywords_Set;
		{ class } function _GetFld_Parallel: TEventKeywords_Set;
		{ class } function _GetFld_Tasks: TEventKeywords_Set;
		{ class } function _GetFld_TasksFlowActivityIds: TEventKeywords_Set;
		{ class } function _GetFld_TasksSetActivityIds: TEventKeywords_Set;
		{ class } function _GetFld_TaskStops: TEventKeywords_Set;
		{ class } function _GetFld_TaskTransfer: TEventKeywords_Set;
	{ public }
		{ class } property AsyncCausalityOperation: TEventKeywords_Set read _GetFld_AsyncCausalityOperation;
		{ class } property AsyncCausalityRelation: TEventKeywords_Set read _GetFld_AsyncCausalityRelation;
		{ class } property AsyncCausalitySynchronousWork: TEventKeywords_Set read _GetFld_AsyncCausalitySynchronousWork;
		{ class } property AsyncMethod: TEventKeywords_Set read _GetFld_AsyncMethod;
		{ class } property Debug: TEventKeywords_Set read _GetFld_Debug;
		{ class } property DebugActivityId: TEventKeywords_Set read _GetFld_DebugActivityId;
		{ class } property Parallel: TEventKeywords_Set read _GetFld_Parallel;
		{ class } property Tasks: TEventKeywords_Set read _GetFld_Tasks;
		{ class } property TasksFlowActivityIds: TEventKeywords_Set read _GetFld_TasksFlowActivityIds;
		{ class } property TasksSetActivityIds: TEventKeywords_Set read _GetFld_TasksSetActivityIds;
		{ class } property TaskStops: TEventKeywords_Set read _GetFld_TaskStops;
		{ class } property TaskTransfer: TEventKeywords_Set read _GetFld_TaskTransfer;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_KEYWORDS)]
	IKeywords = interface(IObject)
	['{AD242EB4-B009-4C41-B198-52C146184329}']
	end;

	IKeywords_1Class = interface(ICoreClrClass)
	['{DAA4AE34-A498-4B56-B6F9-E8054F7BC8C2}']
	{ private }
		{ class } function _GetFld_ThreadPool: TEventKeywords_Set;
		{ class } function _GetFld_ThreadTransfer: TEventKeywords_Set;
	{ public }
		{ class } property ThreadPool: TEventKeywords_Set read _GetFld_ThreadPool;
		{ class } property ThreadTransfer: TEventKeywords_Set read _GetFld_ThreadTransfer;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_KEYWORDS)]
	IKeywords_1 = interface(IObject)
	['{34F089AE-81E0-4B8B-9C49-3F2C1A7CF3A8}']
	end;

	IKeywords_2Class = interface(ICoreClrClass)
	['{A4E58010-2951-4A56-9862-486643F38844}']
	{ private }
		{ class } function _GetFld_AppDomainResourceManagementKeyword: TEventKeywords_Set;
		{ class } function _GetFld_AssemblyLoaderKeyword: TEventKeywords_Set;
		{ class } function _GetFld_CodeSymbolsKeyword: TEventKeywords_Set;
		{ class } function _GetFld_CompilationDiagnosticKeyword: TEventKeywords_Set;
		{ class } function _GetFld_CompilationKeyword: TEventKeywords_Set;
		{ class } function _GetFld_ContentionKeyword: TEventKeywords_Set;
		{ class } function _GetFld_DebuggerKeyword: TEventKeywords_Set;
		{ class } function _GetFld_EndEnumerationKeyword: TEventKeywords_Set;
		{ class } function _GetFld_EventSourceKeyword: TEventKeywords_Set;
		{ class } function _GetFld_ExceptionKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCHandleKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCHeapAndTypeNamesKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCHeapCollectKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCHeapDumpKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCHeapSurvivalAndMovementKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCSampledObjectAllocationHighKeyword: TEventKeywords_Set;
		{ class } function _GetFld_GCSampledObjectAllocationLowKeyword: TEventKeywords_Set;
		{ class } function _GetFld_InteropKeyword: TEventKeywords_Set;
		{ class } function _GetFld_JitKeyword: TEventKeywords_Set;
		{ class } function _GetFld_JittedMethodILToNativeMapKeyword: TEventKeywords_Set;
		{ class } function _GetFld_JitTracingKeyword: TEventKeywords_Set;
		{ class } function _GetFld_LoaderKeyword: TEventKeywords_Set;
		{ class } function _GetFld_MethodDiagnosticKeyword: TEventKeywords_Set;
		{ class } function _GetFld_MonitoringKeyword: TEventKeywords_Set;
		{ class } function _GetFld_NGenKeyword: TEventKeywords_Set;
		{ class } function _GetFld_OverrideAndSuppressNGenEventsKeyword: TEventKeywords_Set;
		{ class } function _GetFld_PerfTrackKeyword: TEventKeywords_Set;
		{ class } function _GetFld_SecurityKeyword: TEventKeywords_Set;
		{ class } function _GetFld_StackKeyword: TEventKeywords_Set;
		{ class } function _GetFld_StartEnumerationKeyword: TEventKeywords_Set;
		{ class } function _GetFld_ThreadingKeyword: TEventKeywords_Set;
		{ class } function _GetFld_ThreadTransferKeyword: TEventKeywords_Set;
		{ class } function _GetFld_TypeDiagnosticKeyword: TEventKeywords_Set;
		{ class } function _GetFld_TypeKeyword: TEventKeywords_Set;
	{ public }
		{ class } property AppDomainResourceManagementKeyword: TEventKeywords_Set read _GetFld_AppDomainResourceManagementKeyword;
		{ class } property AssemblyLoaderKeyword: TEventKeywords_Set read _GetFld_AssemblyLoaderKeyword;
		{ class } property CodeSymbolsKeyword: TEventKeywords_Set read _GetFld_CodeSymbolsKeyword;
		{ class } property CompilationDiagnosticKeyword: TEventKeywords_Set read _GetFld_CompilationDiagnosticKeyword;
		{ class } property CompilationKeyword: TEventKeywords_Set read _GetFld_CompilationKeyword;
		{ class } property ContentionKeyword: TEventKeywords_Set read _GetFld_ContentionKeyword;
		{ class } property DebuggerKeyword: TEventKeywords_Set read _GetFld_DebuggerKeyword;
		{ class } property EndEnumerationKeyword: TEventKeywords_Set read _GetFld_EndEnumerationKeyword;
		{ class } property EventSourceKeyword: TEventKeywords_Set read _GetFld_EventSourceKeyword;
		{ class } property ExceptionKeyword: TEventKeywords_Set read _GetFld_ExceptionKeyword;
		{ class } property GCHandleKeyword: TEventKeywords_Set read _GetFld_GCHandleKeyword;
		{ class } property GCHeapAndTypeNamesKeyword: TEventKeywords_Set read _GetFld_GCHeapAndTypeNamesKeyword;
		{ class } property GCHeapCollectKeyword: TEventKeywords_Set read _GetFld_GCHeapCollectKeyword;
		{ class } property GCHeapDumpKeyword: TEventKeywords_Set read _GetFld_GCHeapDumpKeyword;
		{ class } property GCHeapSurvivalAndMovementKeyword: TEventKeywords_Set read _GetFld_GCHeapSurvivalAndMovementKeyword;
		{ class } property GCKeyword: TEventKeywords_Set read _GetFld_GCKeyword;
		{ class } property GCSampledObjectAllocationHighKeyword: TEventKeywords_Set read _GetFld_GCSampledObjectAllocationHighKeyword;
		{ class } property GCSampledObjectAllocationLowKeyword: TEventKeywords_Set read _GetFld_GCSampledObjectAllocationLowKeyword;
		{ class } property InteropKeyword: TEventKeywords_Set read _GetFld_InteropKeyword;
		{ class } property JitKeyword: TEventKeywords_Set read _GetFld_JitKeyword;
		{ class } property JittedMethodILToNativeMapKeyword: TEventKeywords_Set read _GetFld_JittedMethodILToNativeMapKeyword;
		{ class } property JitTracingKeyword: TEventKeywords_Set read _GetFld_JitTracingKeyword;
		{ class } property LoaderKeyword: TEventKeywords_Set read _GetFld_LoaderKeyword;
		{ class } property MethodDiagnosticKeyword: TEventKeywords_Set read _GetFld_MethodDiagnosticKeyword;
		{ class } property MonitoringKeyword: TEventKeywords_Set read _GetFld_MonitoringKeyword;
		{ class } property NGenKeyword: TEventKeywords_Set read _GetFld_NGenKeyword;
		{ class } property OverrideAndSuppressNGenEventsKeyword: TEventKeywords_Set read _GetFld_OverrideAndSuppressNGenEventsKeyword;
		{ class } property PerfTrackKeyword: TEventKeywords_Set read _GetFld_PerfTrackKeyword;
		{ class } property SecurityKeyword: TEventKeywords_Set read _GetFld_SecurityKeyword;
		{ class } property StackKeyword: TEventKeywords_Set read _GetFld_StackKeyword;
		{ class } property StartEnumerationKeyword: TEventKeywords_Set read _GetFld_StartEnumerationKeyword;
		{ class } property ThreadingKeyword: TEventKeywords_Set read _GetFld_ThreadingKeyword;
		{ class } property ThreadTransferKeyword: TEventKeywords_Set read _GetFld_ThreadTransferKeyword;
		{ class } property TypeDiagnosticKeyword: TEventKeywords_Set read _GetFld_TypeDiagnosticKeyword;
		{ class } property TypeKeyword: TEventKeywords_Set read _GetFld_TypeKeyword;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_KEYWORDS_2)]
	IKeywords_2 = interface(IObject)
	['{6FA08E55-C393-45B1-B537-46C3F4640A53}']
	end;

	IKoreanCalendarClass = interface(ICoreClrClass)
	['{C81B328C-648C-4D5F-AB57-1E4AFC478201}']
	{ private }
		{ class } function _GetFld_KoreanEra: Integer;
	{ public }
		{ class } property KoreanEra: Integer read _GetFld_KoreanEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_KOREANCALENDAR)]
	IKoreanCalendar = interface(ICalendar)
	['{4F537AD5-ACAE-49C4-AB4F-09BA6DB1B636}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetWeekOfYear(time: TDateTime; rule: TCalendarWeekRule; firstDayOfWeek: TDayOfWeek): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IKoreanLunisolarCalendarClass = interface(ICoreClrClass)
	['{C5B2368E-C1B4-4A6B-B639-1FD9859780DC}']
	{ private }
		{ class } function _GetFld_GregorianEra: Integer;
	{ public }
		{ class } property GregorianEra: Integer read _GetFld_GregorianEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_KOREANLUNISOLARCALENDAR)]
	IKoreanLunisolarCalendar = interface(IEastAsianLunisolarCalendar)
	['{22D71875-0A1D-46C7-B72C-AAB0184EBEE8}']
	{ private }
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_LABEL_)]
	ILabel = interface(IValueType)
	['{8F0006FD-5A6A-470B-9C4D-432A58BEAEFF}']
	{ public }
		function Equals(obj: ILabel): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_LAZY_1)]
	ILazy<T> = interface(IObject)
	['{C3A7C1C8-2CDC-4960-85AC-C77FAF14CF69}']
	{ private }
		function _GetProp_IsValueCreated: Boolean;
		function _GetProp_Value: T;
	{ public }
		property IsValueCreated: Boolean read _GetProp_IsValueCreated;
		property Value: T read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_LAZY_2)]
	ILazy<T,TMetadata> = interface(ILazy<T>)
	['{C0CD41E1-8590-4385-85EE-42A8E119FC80}']
	{ private }
		function _GetProp_Metadata: TMetadata;
	{ public }
		property Metadata: TMetadata read _GetProp_Metadata;
	end;

	ILazyInitializerClass = interface(ICoreClrClass)
	['{546C4211-8780-45FD-BF5F-34E3753726B5}']
	{ public }
		{ class } function EnsureInitialized(T: PTypeInfo; var target: Variant{T}): Variant{T}; overload;
		{ class } function EnsureInitialized(T: PTypeInfo; var target: Variant{T}; valueFactory: TClrFunc<Variant{T}>): Variant{T}; overload;
		{ class } function EnsureInitialized(T: PTypeInfo; var target: Variant{T}; var initialized: Boolean; var syncLock: Variant): Variant{T}; overload;
		{ class } function EnsureInitialized(T: PTypeInfo; var target: Variant{T}; var syncLock: Variant; valueFactory: TClrFunc<Variant{T}>): Variant{T}; overload;
		{ class } function EnsureInitialized(T: PTypeInfo; var target: Variant{T}; var initialized: Boolean; var syncLock: Variant; valueFactory: TClrFunc<Variant{T}>): Variant{T}; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_LAZYINITIALIZER)]
	ILazyInitializer = interface(IObject)
	['{99E07081-DFBA-4FF8-8855-8B94782F30F4}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_LCIDCONVERSIONATTRIBUTE)]
	ILCIDConversionAttribute = interface(IAttribute)
	['{9C452B92-2175-4CB3-A2C0-AB996C9A00AE}']
	{ private }
		function _GetProp_Value: Integer;
	{ public }
		property Value: Integer read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_LIST_1)]
	IList<T> = interface(IObject)
	['{FD62D6DF-10A0-434E-BFB9-7FE059E9DBCF}']
	{ private }
		function _GetProp_Capacity: Integer;
		procedure _SetProp_Capacity(Value: Integer);
		function _GetProp_Count: Integer;
		function _GetProp_Item(index: Integer): T;
		procedure _SetProp_Item(index: Integer; Value: T);
	{ public }
		procedure Add(item: T);
		procedure AddRange(collection: IIEnumerable<T>);
		function AsReadOnly(): IReadOnlyCollection<T>;
		function BinarySearch(index: Integer; count: Integer; item: T; comparer: IIComparer<T>): Integer; overload;
		function BinarySearch(item: T): Integer; overload;
		function BinarySearch(item: T; comparer: IIComparer<T>): Integer; overload;
		procedure Clear();
		function Contains(item: T): Boolean;
		function ConvertAll(TOutput: PTypeInfo; converter: TConverter<T, Variant{TOutput}>): IList<Variant{TOutput}>;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>); overload;
		procedure CopyTo(index: Integer; array_: ICoreClrBridgeArray<T>; arrayIndex: Integer; count: Integer); overload;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; arrayIndex: Integer); overload;
		function Exists(match: TClrPredicate<T>): Boolean;
		function Find(match: TClrPredicate<T>): T;
		function FindAll(match: TClrPredicate<T>): IList<T>;
		function FindIndex(match: TClrPredicate<T>): Integer; overload;
		function FindIndex(startIndex: Integer; match: TClrPredicate<T>): Integer; overload;
		function FindIndex(startIndex: Integer; count: Integer; match: TClrPredicate<T>): Integer; overload;
		function FindLast(match: TClrPredicate<T>): T;
		function FindLastIndex(match: TClrPredicate<T>): Integer; overload;
		function FindLastIndex(startIndex: Integer; match: TClrPredicate<T>): Integer; overload;
		function FindLastIndex(startIndex: Integer; count: Integer; match: TClrPredicate<T>): Integer; overload;
		procedure ForEach(action: TClrAction<T>);
		function GetEnumerator(): IList_Enumerator<T>;
		function GetRange(index: Integer; count: Integer): IList<T>;
		function IndexOf(item: T): Integer; overload;
		function IndexOf(item: T; index: Integer): Integer; overload;
		function IndexOf(item: T; index: Integer; count: Integer): Integer; overload;
		procedure Insert(index: Integer; item: T);
		procedure InsertRange(index: Integer; collection: IIEnumerable<T>);
		function LastIndexOf(item: T): Integer; overload;
		function LastIndexOf(item: T; index: Integer): Integer; overload;
		function LastIndexOf(item: T; index: Integer; count: Integer): Integer; overload;
		function Remove(item: T): Boolean;
		function RemoveAll(match: TClrPredicate<T>): Integer;
		procedure RemoveAt(index: Integer);
		procedure RemoveRange(index: Integer; count: Integer);
		procedure Reverse(); overload;
		procedure Reverse(index: Integer; count: Integer); overload;
		procedure Sort(); overload;
		procedure Sort(comparer: IIComparer<T>); overload;
		procedure Sort(comparison: TComparison<T>); overload;
		procedure Sort(index: Integer; count: Integer; comparer: IIComparer<T>); overload;
		function ToArray(): TArray<T>;
		procedure TrimExcess();
		function TrueForAll(match: TClrPredicate<T>): Boolean;
		property Capacity: Integer read _GetProp_Capacity write _SetProp_Capacity;
		property Count: Integer read _GetProp_Count;
		property Item[index: Integer]: T read _GetProp_Item write _SetProp_Item; default;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_LISTDICTIONARYINTERNAL)]
	IListDictionaryInternal = interface(IObject)
	['{0D326DEA-8F78-470E-B1B0-248A470B08A2}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsFixedSize: Boolean;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_Item(key: Variant): Variant;
		procedure _SetProp_Item(key: Variant; Value: Variant);
		function _GetProp_Keys: IICollection;
		function _GetProp_SyncRoot: Variant;
		function _GetProp_Values: IICollection;
	{ public }
		procedure Add(key: Variant; value: Variant);
		procedure Clear();
		function Contains(key: Variant): Boolean;
		procedure CopyTo(array_: IArray; index: Integer);
		function GetEnumerator(): IIDictionaryEnumerator;
		procedure Remove(key: Variant);
		property Count: Integer read _GetProp_Count;
		property IsFixedSize: Boolean read _GetProp_IsFixedSize;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property Item[key: Variant]: Variant read _GetProp_Item write _SetProp_Item; default;
		property Keys: IICollection read _GetProp_Keys;
		property SyncRoot: Variant read _GetProp_SyncRoot;
		property Values: IICollection read _GetProp_Values;
	end;

	[CoreTypeSignature(SYSTEM_LOADEROPTIMIZATIONATTRIBUTE)]
	ILoaderOptimizationAttribute = interface(IAttribute)
	['{F71A90D9-AF3E-4DA8-A765-E55FC728F88F}']
	{ private }
		function _GetProp_Value: TLoaderOptimization;
	{ public }
		property Value: TLoaderOptimization read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_LOCALVARIABLEINFO)]
	ILocalVariableInfo = interface(IObject)
	['{59E0082C-56C8-4EC6-82F1-CCFB460D0723}']
	{ private }
		function _GetProp_IsPinned: Boolean;
		function _GetProp_LocalIndex: Integer;
		function _GetProp_LocalType: IType;
	{ public }
		property IsPinned: Boolean read _GetProp_IsPinned;
		property LocalIndex: Integer read _GetProp_LocalIndex;
		property LocalType: IType read _GetProp_LocalType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_LOCALBUILDER)]
	ILocalBuilder = interface(ILocalVariableInfo)
	['{52DB378D-CE9D-48BF-98E7-6DE69BAC9358}']
	{ private }
		function _GetProp_IsPinned: Boolean;
		function _GetProp_LocalIndex: Integer;
		function _GetProp_LocalType: IType;
	{ public }
		procedure SetLocalSymInfo(name: String); overload;
		procedure SetLocalSymInfo(name: String; startOffset: Integer; endOffset: Integer); overload;
		property IsPinned: Boolean read _GetProp_IsPinned;
		property LocalIndex: Integer read _GetProp_LocalIndex;
		property LocalType: IType read _GetProp_LocalType;
	end;

	[CoreTypeSignature(SYSTEM_LOCALDATASTORESLOT)]
	ILocalDataStoreSlot = interface(IObject)
	['{F7A2E9A9-389D-453D-8785-81D0C3D53904}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_LOCKRECURSIONEXCEPTION)]
	ILockRecursionException = interface(IException)
	['{E4ABE183-E94C-4DB3-8374-6FD69885A014}']
	end;

	ILzcntClass = interface(ICoreClrClass)
	['{86499F2B-A462-4255-AD92-62C24D8DBC42}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function LeadingZeroCount(value: longword): longword;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_LZCNT)]
	ILzcnt = interface(IX86Base)
	['{7D36E15F-792B-4901-852B-5BAEEEE2C049}']
	end;

	IX64_6Class = interface(ICoreClrClass)
	['{A70E0D80-0BB2-4411-8CCA-A44E2881708E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function LeadingZeroCount(value: UInt64): UInt64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_7)]
	IX64_6 = interface(IX64_15)
	['{670ADC3E-943C-4E1D-9031-6225E1079E76}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_MANIFESTRESOURCEINFO)]
	IManifestResourceInfo = interface(IObject)
	['{67AAA5DE-1173-4FB0-823A-9F8CB02CD587}']
	{ private }
		function _GetProp_FileName: String;
		function _GetProp_ReferencedAssembly: IAssembly;
		function _GetProp_ResourceLocation: TResourceLocation_Set;
	{ public }
		property FileName: String read _GetProp_FileName;
		property ReferencedAssembly: IAssembly read _GetProp_ReferencedAssembly;
		property ResourceLocation: TResourceLocation_Set read _GetProp_ResourceLocation;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_MANUALRESETEVENT)]
	IManualResetEvent = interface(IEventWaitHandle)
	['{DA22923A-42C9-4291-8DC9-36336C08202D}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_MANUALRESETEVENTSLIM)]
	IManualResetEventSlim = interface(IIDisposable)
	['{42A48BD8-9FF3-49B8-B6D7-493F3C87B98B}']
	{ private }
		function _GetProp_IsSet: Boolean;
		function _GetProp_SpinCount: Integer;
		function _GetProp_WaitHandle: IWaitHandle;
	{ public }
		procedure Dispose();
		procedure Reset();
		procedure &Set();
		procedure Wait(); overload;
		procedure Wait(cancellationToken: ICancellationToken); overload;
		function Wait(timeout: ITimeSpan): Boolean; overload;
		function Wait(millisecondsTimeout: Integer): Boolean; overload;
		function Wait(timeout: ITimeSpan; cancellationToken: ICancellationToken): Boolean; overload;
		function Wait(millisecondsTimeout: Integer; cancellationToken: ICancellationToken): Boolean; overload;
		property IsSet: Boolean read _GetProp_IsSet;
		property SpinCount: Integer read _GetProp_SpinCount;
		property WaitHandle: IWaitHandle read _GetProp_WaitHandle;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_SOURCES_MANUALRESETVALUETASKSOURCECORE_1)]
	IManualResetValueTaskSourceCore<TResult> = interface(IValueType)
	['{CE423CD5-C32B-43FB-A1F3-4653AEA16B71}']
	{ private }
		function _GetProp_RunContinuationsAsynchronously: Boolean;
		procedure _SetProp_RunContinuationsAsynchronously(Value: Boolean);
		function _GetProp_Version: SmallInt;
	{ public }
		function GetResult(token: SmallInt): TResult;
		function GetStatus(token: SmallInt): TValueTaskSourceStatus;
		procedure OnCompleted(continuation: TClrAction<Variant>; state: Variant; token: SmallInt; flags: TValueTaskSourceOnCompletedFlags_Set);
		procedure Reset();
		procedure SetException(error: IException);
		procedure SetResult(result_: TResult);
		property RunContinuationsAsynchronously: Boolean read _GetProp_RunContinuationsAsynchronously write _SetProp_RunContinuationsAsynchronously;
		property Version: SmallInt read _GetProp_Version;
	end;

	IMarshalClass = interface(ICoreClrClass)
	['{C7348BD7-FD3B-4F33-8D5B-5B8569B27C70}']
	{ private }
		{ class } function _GetFld_SystemDefaultCharSize: Integer;
		{ class } function _GetFld_SystemMaxDBCSCharSize: Integer;
	{ public }
		{ class } function AddRef(pUnk: IIntPtr): Integer;
		{ class } function AllocCoTaskMem(cb: Integer): IIntPtr;
		{ class } function AllocHGlobal(cb: Integer): IIntPtr; overload;
		{ class } function AllocHGlobal(cb: IIntPtr): IIntPtr; overload;
		{ class } function AreComObjectsAvailableForCleanup(): Boolean;
		{ class } function BindToMoniker(monikerName: String): Variant;
		{ class } procedure ChangeWrapperHandleStrength(otp: Variant; fIsWeak: Boolean);
		{ class } procedure CleanupUnusedObjectsInCurrentContext();
		{ class } procedure Copy(source: TArray<Integer>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<Char>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<SmallInt>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<Int64>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<Single>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<Double>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: TArray<Byte>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: ICoreClrBridgeArray<IIntPtr>; startIndex: Integer; destination: IIntPtr; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Integer>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Char>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<SmallInt>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Int64>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Single>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Double>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: TArray<Byte>; startIndex: Integer; length: Integer); overload;
		{ class } procedure Copy(source: IIntPtr; destination: ICoreClrBridgeArray<IIntPtr>; startIndex: Integer; length: Integer); overload;
		{ class } function CreateAggregatedObject(pOuter: IIntPtr; o: Variant): IIntPtr; overload;
		{ class } function CreateAggregatedObject(T: PTypeInfo; pOuter: IIntPtr; o: Variant{T}): IIntPtr; overload;
		{ class } function CreateWrapperOfType(o: Variant; t: IType): Variant; overload;
		{ class } function CreateWrapperOfType(T: PTypeInfo; TWrapper: PTypeInfo; o: Variant{T}): Variant{TWrapper}; overload;
		{ class } procedure DestroyStructure(T: PTypeInfo; ptr: IIntPtr); overload;
		{ class } procedure DestroyStructure(ptr: IIntPtr; structuretype: IType); overload;
		{ class } function FinalReleaseComObject(o: Variant): Integer;
		{ class } procedure FreeBSTR(ptr: IIntPtr);
		{ class } procedure FreeCoTaskMem(ptr: IIntPtr);
		{ class } procedure FreeHGlobal(hglobal: IIntPtr);
		{ class } function GenerateGuidForType(type_: IType): IGuid;
		{ class } function GenerateProgIdForType(type_: IType): String;
		{ class } function GetComInterfaceForObject(o: Variant; T: IType): IIntPtr; overload;
		{ class } function GetComInterfaceForObject(T: PTypeInfo; TInterface: PTypeInfo; o: Variant{T}): IIntPtr; overload;
		{ class } function GetComInterfaceForObject(o: Variant; T: IType; mode: TCustomQueryInterfaceMode): IIntPtr; overload;
		{ class } function GetComObjectData(obj: Variant; key: Variant): Variant;
		{ class } function GetDelegateForFunctionPointer(ptr: IIntPtr; t: IType): IDelegate; overload;
		{ class } function GetDelegateForFunctionPointer(TDelegate: PTypeInfo; ptr: IIntPtr): Variant{TDelegate}; overload;
		{ class } function GetEndComSlot(t: IType): Integer;
		{ class } function GetExceptionCode(): Integer;
		{ class } function GetExceptionForHR(errorCode: Integer): IException; overload;
		{ class } function GetExceptionForHR(errorCode: Integer; errorInfo: IIntPtr): IException; overload;
		{ class } function GetExceptionPointers(): IIntPtr;
		{ class } function GetFunctionPointerForDelegate(d: IDelegate): IIntPtr; overload;
		{ class } function GetFunctionPointerForDelegate(TDelegate: PTypeInfo; d: Variant{TDelegate}): IIntPtr; overload;
		{ class } function GetHINSTANCE(m: IModule): IIntPtr;
		{ class } function GetHRForException(e: IException): Integer;
		{ class } function GetHRForLastWin32Error(): Integer;
		{ class } function GetIDispatchForObject(o: Variant): IIntPtr;
		{ class } function GetIUnknownForObject(o: Variant): IIntPtr;
		{ class } function GetLastWin32Error(): Integer;
		{ class } procedure GetNativeVariantForObject(obj: Variant; pDstNativeVariant: IIntPtr); overload;
		{ class } procedure GetNativeVariantForObject(T: PTypeInfo; obj: Variant{T}; pDstNativeVariant: IIntPtr); overload;
		{ class } function GetObjectForIUnknown(pUnk: IIntPtr): Variant;
		{ class } function GetObjectForNativeVariant(pSrcNativeVariant: IIntPtr): Variant;
		{ class } function GetObjectsForNativeVariants(T: PTypeInfo; aSrcNativeVariant: IIntPtr; cVars: Integer): ICoreClrBridgeArray<Variant{T}>;
		{ class } function GetStartComSlot(t: IType): Integer;
		{ class } function GetTypedObjectForIUnknown(pUnk: IIntPtr; t: IType): Variant;
		{ class } function GetTypeFromCLSID(clsid: IGuid): IType;
		{ class } function GetTypeInfoName(typeInfo: IITypeInfo): String;
		{ class } function GetUniqueObjectForIUnknown(unknown: IIntPtr): Variant;
		{ class } function IsComObject(o: Variant): Boolean;
		{ class } function IsTypeVisibleFromCom(t: IType): Boolean;
		{ class } function OffsetOf(T: PTypeInfo; fieldName: String): IIntPtr; overload;
		{ class } function OffsetOf(t: IType; fieldName: String): IIntPtr; overload;
		{ class } procedure Prelink(m: IMethodInfo);
		{ class } procedure PrelinkAll(c: IType);
		{ class } function PtrToStringAnsi(ptr: IIntPtr): String; overload;
		{ class } function PtrToStringAnsi(ptr: IIntPtr; len: Integer): String; overload;
		{ class } function PtrToStringAuto(ptr: IIntPtr; len: Integer): String; overload;
		{ class } function PtrToStringAuto(ptr: IIntPtr): String; overload;
		{ class } function PtrToStringBSTR(ptr: IIntPtr): String;
		{ class } function PtrToStringUni(ptr: IIntPtr): String; overload;
		{ class } function PtrToStringUni(ptr: IIntPtr; len: Integer): String; overload;
		{ class } function PtrToStringUTF8(ptr: IIntPtr): String; overload;
		{ class } function PtrToStringUTF8(ptr: IIntPtr; byteLen: Integer): String; overload;
		{ class } function PtrToStructure(T: PTypeInfo; ptr: IIntPtr): Variant{T}; overload;
		{ class } function PtrToStructure(ptr: IIntPtr; structureType: IType): Variant; overload;
		{ class } procedure PtrToStructure(ptr: IIntPtr; structure: Variant); overload;
		{ class } procedure PtrToStructure(T: PTypeInfo; ptr: IIntPtr; structure: Variant{T}); overload;
		{ class } function QueryInterface(pUnk: IIntPtr; var iid: IGuid; var ppv: IIntPtr): Integer;
		{ class } function ReadByte(ptr: IIntPtr; ofs: Integer): Byte; overload;
		{ class } function ReadByte(ptr: Variant; ofs: Integer): Byte; overload;
		{ class } function ReadByte(ptr: IIntPtr): Byte; overload;
		{ class } function ReadInt16(ptr: IIntPtr; ofs: Integer): SmallInt; overload;
		{ class } function ReadInt16(ptr: Variant; ofs: Integer): SmallInt; overload;
		{ class } function ReadInt16(ptr: IIntPtr): SmallInt; overload;
		{ class } function ReadInt32(ptr: IIntPtr; ofs: Integer): Integer; overload;
		{ class } function ReadInt32(ptr: Variant; ofs: Integer): Integer; overload;
		{ class } function ReadInt32(ptr: IIntPtr): Integer; overload;
		{ class } function ReadInt64(ptr: IIntPtr; ofs: Integer): Int64; overload;
		{ class } function ReadInt64(ptr: Variant; ofs: Integer): Int64; overload;
		{ class } function ReadInt64(ptr: IIntPtr): Int64; overload;
		{ class } function ReadIntPtr(ptr: Variant; ofs: Integer): IIntPtr; overload;
		{ class } function ReadIntPtr(ptr: IIntPtr; ofs: Integer): IIntPtr; overload;
		{ class } function ReadIntPtr(ptr: IIntPtr): IIntPtr; overload;
		{ class } function ReAllocCoTaskMem(pv: IIntPtr; cb: Integer): IIntPtr;
		{ class } function ReAllocHGlobal(pv: IIntPtr; cb: IIntPtr): IIntPtr;
		{ class } function Release(pUnk: IIntPtr): Integer;
		{ class } function ReleaseComObject(o: Variant): Integer;
		{ class } function SecureStringToBSTR(s: ISecureString): IIntPtr;
		{ class } function SecureStringToCoTaskMemAnsi(s: ISecureString): IIntPtr;
		{ class } function SecureStringToCoTaskMemUnicode(s: ISecureString): IIntPtr;
		{ class } function SecureStringToGlobalAllocAnsi(s: ISecureString): IIntPtr;
		{ class } function SecureStringToGlobalAllocUnicode(s: ISecureString): IIntPtr;
		{ class } function SetComObjectData(obj: Variant; key: Variant; data: Variant): Boolean;
		{ class } function SizeOf(structure: Variant): Integer; overload;
		{ class } function SizeOf(T: PTypeInfo; structure: Variant{T}): Integer; overload;
		{ class } function SizeOf(t: IType): Integer; overload;
		{ class } function SizeOf(T: PTypeInfo): Integer;
 overload;
		{ class } function StringToBSTR(s: String): IIntPtr;
		{ class } function StringToCoTaskMemAnsi(s: String): IIntPtr;
		{ class } function StringToCoTaskMemAuto(s: String): IIntPtr;
		{ class } function StringToCoTaskMemUni(s: String): IIntPtr;
		{ class } function StringToCoTaskMemUTF8(s: String): IIntPtr;
		{ class } function StringToHGlobalAnsi(s: String): IIntPtr;
		{ class } function StringToHGlobalAuto(s: String): IIntPtr;
		{ class } function StringToHGlobalUni(s: String): IIntPtr;
		{ class } procedure StructureToPtr(T: PTypeInfo; structure: Variant{T}; ptr: IIntPtr; fDeleteOld: Boolean); overload;
		{ class } procedure StructureToPtr(structure: Variant; ptr: IIntPtr; fDeleteOld: Boolean); overload;
		{ class } procedure ThrowExceptionForHR(errorCode: Integer); overload;
		{ class } procedure ThrowExceptionForHR(errorCode: Integer; errorInfo: IIntPtr); overload;
		{ class } function UnsafeAddrOfPinnedArrayElement(arr: IArray; index: Integer): IIntPtr; overload;
		{ class } function UnsafeAddrOfPinnedArrayElement(T: PTypeInfo; arr: ICoreClrBridgeArray<Variant{T}>; index: Integer): IIntPtr; overload;
		{ class } procedure WriteByte(ptr: IIntPtr; ofs: Integer; val: Byte); overload;
		{ class } procedure WriteByte(ptr: Variant; ofs: Integer; val: Byte); overload;
		{ class } procedure WriteByte(ptr: IIntPtr; val: Byte); overload;
		{ class } procedure WriteInt16(ptr: IIntPtr; ofs: Integer; val: SmallInt); overload;
		{ class } procedure WriteInt16(ptr: IIntPtr; ofs: Integer; val: Char); overload;
		{ class } procedure WriteInt16(var ptr: Variant; ofs: Integer; val: Char); overload;
		{ class } procedure WriteInt16(ptr: Variant; ofs: Integer; val: SmallInt); overload;
		{ class } procedure WriteInt16(ptr: IIntPtr; val: SmallInt); overload;
		{ class } procedure WriteInt16(ptr: IIntPtr; val: Char); overload;
		{ class } procedure WriteInt32(ptr: IIntPtr; ofs: Integer; val: Integer); overload;
		{ class } procedure WriteInt32(ptr: Variant; ofs: Integer; val: Integer); overload;
		{ class } procedure WriteInt32(ptr: IIntPtr; val: Integer); overload;
		{ class } procedure WriteInt64(ptr: IIntPtr; ofs: Integer; val: Int64); overload;
		{ class } procedure WriteInt64(ptr: Variant; ofs: Integer; val: Int64); overload;
		{ class } procedure WriteInt64(ptr: IIntPtr; val: Int64); overload;
		{ class } procedure WriteIntPtr(ptr: IIntPtr; ofs: Integer; val: IIntPtr); overload;
		{ class } procedure WriteIntPtr(ptr: Variant; ofs: Integer; val: IIntPtr); overload;
		{ class } procedure WriteIntPtr(ptr: IIntPtr; val: IIntPtr); overload;
		{ class } procedure ZeroFreeBSTR(s: IIntPtr);
		{ class } procedure ZeroFreeCoTaskMemAnsi(s: IIntPtr);
		{ class } procedure ZeroFreeCoTaskMemUnicode(s: IIntPtr);
		{ class } procedure ZeroFreeCoTaskMemUTF8(s: IIntPtr);
		{ class } procedure ZeroFreeGlobalAllocAnsi(s: IIntPtr);
		{ class } procedure ZeroFreeGlobalAllocUnicode(s: IIntPtr);
		{ class } property SystemDefaultCharSize: Integer read _GetFld_SystemDefaultCharSize;
		{ class } property SystemMaxDBCSCharSize: Integer read _GetFld_SystemMaxDBCSCharSize;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_MARSHAL)]
	IMarshal = interface(IObject)
	['{E171ABC0-E43A-4B88-9C0D-914755EA2E0F}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_MARSHALASATTRIBUTE)]
	IMarshalAsAttribute = interface(IAttribute)
	['{9697A6D4-70AA-4F38-A3A1-805116A78F97}']
	{ private }
		function _GetFld_ArraySubType: TUnmanagedType;
		procedure _SetFld_ArraySubType(Value: TUnmanagedType);
		function _GetFld_IidParameterIndex: Integer;
		procedure _SetFld_IidParameterIndex(Value: Integer);
		function _GetFld_MarshalCookie: String;
		procedure _SetFld_MarshalCookie(Value: String);
		function _GetFld_MarshalType: String;
		procedure _SetFld_MarshalType(Value: String);
		function _GetFld_MarshalTypeRef: IType;
		procedure _SetFld_MarshalTypeRef(Value: IType);
		function _GetFld_SafeArraySubType: TVarEnum;
		procedure _SetFld_SafeArraySubType(Value: TVarEnum);
		function _GetFld_SafeArrayUserDefinedSubType: IType;
		procedure _SetFld_SafeArrayUserDefinedSubType(Value: IType);
		function _GetFld_SizeConst: Integer;
		procedure _SetFld_SizeConst(Value: Integer);
		function _GetFld_SizeParamIndex: SmallInt;
		procedure _SetFld_SizeParamIndex(Value: SmallInt);
		function _GetProp_Value: TUnmanagedType;
	{ public }
		property ArraySubType: TUnmanagedType read _GetFld_ArraySubType write _SetFld_ArraySubType;
		property IidParameterIndex: Integer read _GetFld_IidParameterIndex write _SetFld_IidParameterIndex;
		property MarshalCookie: String read _GetFld_MarshalCookie write _SetFld_MarshalCookie;
		property MarshalType: String read _GetFld_MarshalType write _SetFld_MarshalType;
		property MarshalTypeRef: IType read _GetFld_MarshalTypeRef write _SetFld_MarshalTypeRef;
		property SafeArraySubType: TVarEnum read _GetFld_SafeArraySubType write _SetFld_SafeArraySubType;
		property SafeArrayUserDefinedSubType: IType read _GetFld_SafeArrayUserDefinedSubType write _SetFld_SafeArrayUserDefinedSubType;
		property SizeConst: Integer read _GetFld_SizeConst write _SetFld_SizeConst;
		property SizeParamIndex: SmallInt read _GetFld_SizeParamIndex write _SetFld_SizeParamIndex;
		property Value: TUnmanagedType read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_MARSHALDIRECTIVEEXCEPTION)]
	IMarshalDirectiveException = interface(ISystemException)
	['{E097097B-A066-42A3-9B67-A90825E20F93}']
	end;

	IMathClass = interface(ICoreClrClass)
	['{DE30665C-D6CB-4F49-A28D-FB87E48A3F9C}']
	{ private }
		{ class } function _GetFld_E: Double;
		{ class } function _GetFld_PI: Double;
		{ class } function _GetFld_Tau: Double;
	{ public }
		{ class } function Abs(value: Double): Double; overload;
		{ class } function Abs(value: Single): Single; overload;
		{ class } function Abs(value: SmallInt): SmallInt; overload;
		{ class } function Abs(value: Integer): Integer; overload;
		{ class } function Abs(value: Int64): Int64; overload;
		{ class } function Abs(value: Shortint): Shortint; overload;
		{ class } function Abs(value: IDecimal): IDecimal; overload;
		{ class } function Acos(d: Double): Double;
		{ class } function Acosh(d: Double): Double;
		{ class } function Asin(d: Double): Double;
		{ class } function Asinh(d: Double): Double;
		{ class } function Atan(d: Double): Double;
		{ class } function Atan2(y: Double; x: Double): Double;
		{ class } function Atanh(d: Double): Double;
		{ class } function BigMul(a: Integer; b: Integer): Int64; overload;
		{ class } function BigMul(a: UInt64; b: UInt64; var low: UInt64): UInt64; overload;
		{ class } function BigMul(a: Int64; b: Int64; var low: Int64): Int64; overload;
		{ class } function BitDecrement(x: Double): Double;
		{ class } function BitIncrement(x: Double): Double;
		{ class } function Cbrt(d: Double): Double;
		{ class } function Ceiling(a: Double): Double; overload;
		{ class } function Ceiling(d: IDecimal): IDecimal; overload;
		{ class } function Clamp(value: Byte; min: Byte; max: Byte): Byte; overload;
		{ class } function Clamp(value: IDecimal; min: IDecimal; max: IDecimal): IDecimal; overload;
		{ class } function Clamp(value: Double; min: Double; max: Double): Double; overload;
		{ class } function Clamp(value: SmallInt; min: SmallInt; max: SmallInt): SmallInt; overload;
		{ class } function Clamp(value: Integer; min: Integer; max: Integer): Integer; overload;
		{ class } function Clamp(value: Int64; min: Int64; max: Int64): Int64; overload;
		{ class } function Clamp(value: Shortint; min: Shortint; max: Shortint): Shortint; overload;
		{ class } function Clamp(value: Single; min: Single; max: Single): Single; overload;
		{ class } function Clamp(value: Word; min: Word; max: Word): Word; overload;
		{ class } function Clamp(value: longword; min: longword; max: longword): longword; overload;
		{ class } function Clamp(value: UInt64; min: UInt64; max: UInt64): UInt64; overload;
		{ class } function CopySign(x: Double; y: Double): Double;
		{ class } function Cos(d: Double): Double;
		{ class } function Cosh(value: Double): Double;
		{ class } function DivRem(a: Integer; b: Integer; var result_: Integer): Integer; overload;
		{ class } function DivRem(a: Int64; b: Int64; var result_: Int64): Int64; overload;
		{ class } function Exp(d: Double): Double;
		{ class } function Floor(d: Double): Double; overload;
		{ class } function Floor(d: IDecimal): IDecimal; overload;
		{ class } function FusedMultiplyAdd(x: Double; y: Double; z: Double): Double;
		{ class } function IEEERemainder(x: Double; y: Double): Double;
		{ class } function ILogB(x: Double): Integer;
		{ class } function Log(d: Double): Double; overload;
		{ class } function Log(a: Double; newBase: Double): Double; overload;
		{ class } function Log10(d: Double): Double;
		{ class } function Log2(x: Double): Double;
		{ class } function Max(val1: Byte; val2: Byte): Byte; overload;
		{ class } function Max(val1: IDecimal; val2: IDecimal): IDecimal; overload;
		{ class } function Max(val1: Double; val2: Double): Double; overload;
		{ class } function Max(val1: SmallInt; val2: SmallInt): SmallInt; overload;
		{ class } function Max(val1: Integer; val2: Integer): Integer; overload;
		{ class } function Max(val1: Int64; val2: Int64): Int64; overload;
		{ class } function Max(val1: Shortint; val2: Shortint): Shortint; overload;
		{ class } function Max(val1: Single; val2: Single): Single; overload;
		{ class } function Max(val1: Word; val2: Word): Word; overload;
		{ class } function Max(val1: longword; val2: longword): longword; overload;
		{ class } function Max(val1: UInt64; val2: UInt64): UInt64; overload;
		{ class } function MaxMagnitude(x: Double; y: Double): Double;
		{ class } function Min(val1: Byte; val2: Byte): Byte; overload;
		{ class } function Min(val1: IDecimal; val2: IDecimal): IDecimal; overload;
		{ class } function Min(val1: Double; val2: Double): Double; overload;
		{ class } function Min(val1: SmallInt; val2: SmallInt): SmallInt; overload;
		{ class } function Min(val1: Integer; val2: Integer): Integer; overload;
		{ class } function Min(val1: Int64; val2: Int64): Int64; overload;
		{ class } function Min(val1: Shortint; val2: Shortint): Shortint; overload;
		{ class } function Min(val1: Single; val2: Single): Single; overload;
		{ class } function Min(val1: Word; val2: Word): Word; overload;
		{ class } function Min(val1: longword; val2: longword): longword; overload;
		{ class } function Min(val1: UInt64; val2: UInt64): UInt64; overload;
		{ class } function MinMagnitude(x: Double; y: Double): Double;
		{ class } function Pow(x: Double; y: Double): Double;
		{ class } function Round(d: IDecimal; mode: TMidpointRounding): IDecimal; overload;
		{ class } function Round(value: Double; digits: Integer): Double; overload;
		{ class } function Round(value: Double; mode: TMidpointRounding): Double; overload;
		{ class } function Round(d: IDecimal; decimals: Integer): IDecimal; overload;
		{ class } function Round(d: IDecimal; decimals: Integer; mode: TMidpointRounding): IDecimal; overload;
		{ class } function Round(value: Double; digits: Integer; mode: TMidpointRounding): Double; overload;
		{ class } function Round(a: Double): Double; overload;
		{ class } function Round(d: IDecimal): IDecimal; overload;
		{ class } function ScaleB(x: Double; n: Integer): Double;
		{ class } function Sign(value: IDecimal): Integer; overload;
		{ class } function Sign(value: Double): Integer; overload;
		{ class } function Sign(value: SmallInt): Integer; overload;
		{ class } function Sign(value: Integer): Integer; overload;
		{ class } function Sign(value: Int64): Integer; overload;
		{ class } function Sign(value: Shortint): Integer; overload;
		{ class } function Sign(value: Single): Integer; overload;
		{ class } function Sin(a: Double): Double;
		{ class } function Sinh(value: Double): Double;
		{ class } function Sqrt(d: Double): Double;
		{ class } function Tan(a: Double): Double;
		{ class } function Tanh(value: Double): Double;
		{ class } function Truncate(d: IDecimal): IDecimal; overload;
		{ class } function Truncate(d: Double): Double; overload;
		{ class } property E: Double read _GetFld_E;
		{ class } property PI: Double read _GetFld_PI;
		{ class } property Tau: Double read _GetFld_Tau;
	end;

	[CoreTypeSignature(SYSTEM_MATH)]
	IMath = interface(IObject)
	['{57B7CC24-330A-4769-8232-DA7B9039000B}']
	end;

	IMathFClass = interface(ICoreClrClass)
	['{6BEF7871-804B-48C2-A50B-8F882917847B}']
	{ private }
		{ class } function _GetFld_E: Single;
		{ class } function _GetFld_PI: Single;
		{ class } function _GetFld_Tau: Single;
	{ public }
		{ class } function Abs(x: Single): Single;
		{ class } function Acos(x: Single): Single;
		{ class } function Acosh(x: Single): Single;
		{ class } function Asin(x: Single): Single;
		{ class } function Asinh(x: Single): Single;
		{ class } function Atan(x: Single): Single;
		{ class } function Atan2(y: Single; x: Single): Single;
		{ class } function Atanh(x: Single): Single;
		{ class } function BitDecrement(x: Single): Single;
		{ class } function BitIncrement(x: Single): Single;
		{ class } function Cbrt(x: Single): Single;
		{ class } function Ceiling(x: Single): Single;
		{ class } function CopySign(x: Single; y: Single): Single;
		{ class } function Cos(x: Single): Single;
		{ class } function Cosh(x: Single): Single;
		{ class } function Exp(x: Single): Single;
		{ class } function Floor(x: Single): Single;
		{ class } function FusedMultiplyAdd(x: Single; y: Single; z: Single): Single;
		{ class } function IEEERemainder(x: Single; y: Single): Single;
		{ class } function ILogB(x: Single): Integer;
		{ class } function Log(x: Single): Single; overload;
		{ class } function Log(x: Single; y: Single): Single; overload;
		{ class } function Log10(x: Single): Single;
		{ class } function Log2(x: Single): Single;
		{ class } function Max(x: Single; y: Single): Single;
		{ class } function MaxMagnitude(x: Single; y: Single): Single;
		{ class } function Min(x: Single; y: Single): Single;
		{ class } function MinMagnitude(x: Single; y: Single): Single;
		{ class } function Pow(x: Single; y: Single): Single;
		{ class } function Round(x: Single): Single; overload;
		{ class } function Round(x: Single; digits: Integer): Single; overload;
		{ class } function Round(x: Single; mode: TMidpointRounding): Single; overload;
		{ class } function Round(x: Single; digits: Integer; mode: TMidpointRounding): Single; overload;
		{ class } function ScaleB(x: Single; n: Integer): Single;
		{ class } function Sign(x: Single): Integer;
		{ class } function Sin(x: Single): Single;
		{ class } function Sinh(x: Single): Single;
		{ class } function Sqrt(x: Single): Single;
		{ class } function Tan(x: Single): Single;
		{ class } function Tanh(x: Single): Single;
		{ class } function Truncate(x: Single): Single;
		{ class } property E: Single read _GetFld_E;
		{ class } property PI: Single read _GetFld_PI;
		{ class } property Tau: Single read _GetFld_Tau;
	end;

	[CoreTypeSignature(SYSTEM_MATHF)]
	IMathF = interface(IObject)
	['{E6DA5724-0529-48DC-8FAE-48DE4E48EC6E}']
	end;

	IMatrix3x2Class = interface(ICoreClrClass)
	['{B21E3103-584D-4FE9-8A95-B8386D944601}']
	{ private }
		{ class } function _GetProp_Identity: IMatrix3x2;
	{ public }
		{ class } function Add(value1: IMatrix3x2; value2: IMatrix3x2): IMatrix3x2;
		{ class } function CreateRotation(radians: Single): IMatrix3x2; overload;
		{ class } function CreateRotation(radians: Single; centerPoint: IVector2): IMatrix3x2; overload;
		{ class } function CreateScale(xScale: Single; yScale: Single): IMatrix3x2; overload;
		{ class } function CreateScale(scales: IVector2; centerPoint: IVector2): IMatrix3x2; overload;
		{ class } function CreateScale(scale: Single; centerPoint: IVector2): IMatrix3x2; overload;
		{ class } function CreateScale(xScale: Single; yScale: Single; centerPoint: IVector2): IMatrix3x2; overload;
		{ class } function CreateScale(scales: IVector2): IMatrix3x2; overload;
		{ class } function CreateScale(scale: Single): IMatrix3x2; overload;
		{ class } function CreateSkew(radiansX: Single; radiansY: Single): IMatrix3x2; overload;
		{ class } function CreateSkew(radiansX: Single; radiansY: Single; centerPoint: IVector2): IMatrix3x2; overload;
		{ class } function CreateTranslation(position: IVector2): IMatrix3x2; overload;
		{ class } function CreateTranslation(xPosition: Single; yPosition: Single): IMatrix3x2; overload;
		{ class } function Invert(matrix: IMatrix3x2; var result_: IMatrix3x2): Boolean;
		{ class } function Lerp(matrix1: IMatrix3x2; matrix2: IMatrix3x2; amount: Single): IMatrix3x2;
		{ class } function Multiply(value1: IMatrix3x2; value2: IMatrix3x2): IMatrix3x2; overload;
		{ class } function Multiply(value1: IMatrix3x2; value2: Single): IMatrix3x2; overload;
		{ class } function Negate(value: IMatrix3x2): IMatrix3x2;
		{ class } function Subtract(value1: IMatrix3x2; value2: IMatrix3x2): IMatrix3x2;
		{ class } property Identity: IMatrix3x2 read _GetProp_Identity;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_MATRIX3X2)]
	IMatrix3x2 = interface(IValueType)
	['{331338AA-057C-47C6-B2C5-B4BC2E664DD1}']
	{ private }
		function _GetFld_M11: Single;
		procedure _SetFld_M11(Value: Single);
		function _GetFld_M12: Single;
		procedure _SetFld_M12(Value: Single);
		function _GetFld_M21: Single;
		procedure _SetFld_M21(Value: Single);
		function _GetFld_M22: Single;
		procedure _SetFld_M22(Value: Single);
		function _GetFld_M31: Single;
		procedure _SetFld_M31(Value: Single);
		function _GetFld_M32: Single;
		procedure _SetFld_M32(Value: Single);
		function _GetProp_IsIdentity: Boolean;
		function _GetProp_Translation: IVector2;
		procedure _SetProp_Translation(Value: IVector2);
	{ public }
		function Equals(other: IMatrix3x2): Boolean;
		function GetDeterminant(): Single;
		property M11: Single read _GetFld_M11 write _SetFld_M11;
		property M12: Single read _GetFld_M12 write _SetFld_M12;
		property M21: Single read _GetFld_M21 write _SetFld_M21;
		property M22: Single read _GetFld_M22 write _SetFld_M22;
		property M31: Single read _GetFld_M31 write _SetFld_M31;
		property M32: Single read _GetFld_M32 write _SetFld_M32;
		property IsIdentity: Boolean read _GetProp_IsIdentity;
		property Translation: IVector2 read _GetProp_Translation write _SetProp_Translation;
	end;

	IMatrix4x4Class = interface(ICoreClrClass)
	['{03FD2FE4-C7A1-4D89-A226-145181830F09}']
	{ private }
		{ class } function _GetProp_Identity: IMatrix4x4;
	{ public }
		{ class } function Add(value1: IMatrix4x4; value2: IMatrix4x4): IMatrix4x4;
		{ class } function CreateBillboard(objectPosition: IVector3; cameraPosition: IVector3; cameraUpVector: IVector3; cameraForwardVector: IVector3): IMatrix4x4;
		{ class } function CreateConstrainedBillboard(objectPosition: IVector3; cameraPosition: IVector3; rotateAxis: IVector3; cameraForwardVector: IVector3; objectForwardVector: IVector3): IMatrix4x4;
		{ class } function CreateFromAxisAngle(axis: IVector3; angle: Single): IMatrix4x4;
		{ class } function CreateFromQuaternion(quaternion: IQuaternion): IMatrix4x4;
		{ class } function CreateFromYawPitchRoll(yaw: Single; pitch: Single; roll: Single): IMatrix4x4;
		{ class } function CreateLookAt(cameraPosition: IVector3; cameraTarget: IVector3; cameraUpVector: IVector3): IMatrix4x4;
		{ class } function CreateOrthographic(width: Single; height: Single; zNearPlane: Single; zFarPlane: Single): IMatrix4x4;
		{ class } function CreateOrthographicOffCenter(left: Single; right: Single; bottom: Single; top: Single; zNearPlane: Single; zFarPlane: Single): IMatrix4x4;
		{ class } function CreatePerspective(width: Single; height: Single; nearPlaneDistance: Single; farPlaneDistance: Single): IMatrix4x4;
		{ class } function CreatePerspectiveFieldOfView(fieldOfView: Single; aspectRatio: Single; nearPlaneDistance: Single; farPlaneDistance: Single): IMatrix4x4;
		{ class } function CreatePerspectiveOffCenter(left: Single; right: Single; bottom: Single; top: Single; nearPlaneDistance: Single; farPlaneDistance: Single): IMatrix4x4;
		{ class } function CreateReflection(value: IPlane): IMatrix4x4;
		{ class } function CreateRotationX(radians: Single): IMatrix4x4; overload;
		{ class } function CreateRotationX(radians: Single; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateRotationY(radians: Single): IMatrix4x4; overload;
		{ class } function CreateRotationY(radians: Single; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateRotationZ(radians: Single): IMatrix4x4; overload;
		{ class } function CreateRotationZ(radians: Single; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateScale(xScale: Single; yScale: Single; zScale: Single): IMatrix4x4; overload;
		{ class } function CreateScale(xScale: Single; yScale: Single; zScale: Single; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateScale(scales: IVector3): IMatrix4x4; overload;
		{ class } function CreateScale(scale: Single): IMatrix4x4; overload;
		{ class } function CreateScale(scales: IVector3; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateScale(scale: Single; centerPoint: IVector3): IMatrix4x4; overload;
		{ class } function CreateShadow(lightDirection: IVector3; plane: IPlane): IMatrix4x4;
		{ class } function CreateTranslation(position: IVector3): IMatrix4x4; overload;
		{ class } function CreateTranslation(xPosition: Single; yPosition: Single; zPosition: Single): IMatrix4x4; overload;
		{ class } function CreateWorld(position: IVector3; forward_: IVector3; up: IVector3): IMatrix4x4;
		{ class } function Decompose(matrix: IMatrix4x4; var scale: IVector3; var rotation: IQuaternion; var translation: IVector3): Boolean;
		{ class } function Invert(matrix: IMatrix4x4; var result_: IMatrix4x4): Boolean;
		{ class } function Lerp(matrix1: IMatrix4x4; matrix2: IMatrix4x4; amount: Single): IMatrix4x4;
		{ class } function Multiply(value1: IMatrix4x4; value2: IMatrix4x4): IMatrix4x4; overload;
		{ class } function Multiply(value1: IMatrix4x4; value2: Single): IMatrix4x4; overload;
		{ class } function Negate(value: IMatrix4x4): IMatrix4x4;
		{ class } function Subtract(value1: IMatrix4x4; value2: IMatrix4x4): IMatrix4x4;
		{ class } function Transform(value: IMatrix4x4; rotation: IQuaternion): IMatrix4x4;
		{ class } function Transpose(matrix: IMatrix4x4): IMatrix4x4;
		{ class } property Identity: IMatrix4x4 read _GetProp_Identity;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_MATRIX4X4)]
	IMatrix4x4 = interface(IValueType)
	['{D23828D5-D0DE-48C8-A558-8C19F3B36628}']
	{ private }
		function _GetFld_M11: Single;
		procedure _SetFld_M11(Value: Single);
		function _GetFld_M12: Single;
		procedure _SetFld_M12(Value: Single);
		function _GetFld_M13: Single;
		procedure _SetFld_M13(Value: Single);
		function _GetFld_M14: Single;
		procedure _SetFld_M14(Value: Single);
		function _GetFld_M21: Single;
		procedure _SetFld_M21(Value: Single);
		function _GetFld_M22: Single;
		procedure _SetFld_M22(Value: Single);
		function _GetFld_M23: Single;
		procedure _SetFld_M23(Value: Single);
		function _GetFld_M24: Single;
		procedure _SetFld_M24(Value: Single);
		function _GetFld_M31: Single;
		procedure _SetFld_M31(Value: Single);
		function _GetFld_M32: Single;
		procedure _SetFld_M32(Value: Single);
		function _GetFld_M33: Single;
		procedure _SetFld_M33(Value: Single);
		function _GetFld_M34: Single;
		procedure _SetFld_M34(Value: Single);
		function _GetFld_M41: Single;
		procedure _SetFld_M41(Value: Single);
		function _GetFld_M42: Single;
		procedure _SetFld_M42(Value: Single);
		function _GetFld_M43: Single;
		procedure _SetFld_M43(Value: Single);
		function _GetFld_M44: Single;
		procedure _SetFld_M44(Value: Single);
		function _GetProp_IsIdentity: Boolean;
		function _GetProp_Translation: IVector3;
		procedure _SetProp_Translation(Value: IVector3);
	{ public }
		function Equals(other: IMatrix4x4): Boolean;
		function GetDeterminant(): Single;
		property M11: Single read _GetFld_M11 write _SetFld_M11;
		property M12: Single read _GetFld_M12 write _SetFld_M12;
		property M13: Single read _GetFld_M13 write _SetFld_M13;
		property M14: Single read _GetFld_M14 write _SetFld_M14;
		property M21: Single read _GetFld_M21 write _SetFld_M21;
		property M22: Single read _GetFld_M22 write _SetFld_M22;
		property M23: Single read _GetFld_M23 write _SetFld_M23;
		property M24: Single read _GetFld_M24 write _SetFld_M24;
		property M31: Single read _GetFld_M31 write _SetFld_M31;
		property M32: Single read _GetFld_M32 write _SetFld_M32;
		property M33: Single read _GetFld_M33 write _SetFld_M33;
		property M34: Single read _GetFld_M34 write _SetFld_M34;
		property M41: Single read _GetFld_M41 write _SetFld_M41;
		property M42: Single read _GetFld_M42 write _SetFld_M42;
		property M43: Single read _GetFld_M43 write _SetFld_M43;
		property M44: Single read _GetFld_M44 write _SetFld_M44;
		property IsIdentity: Boolean read _GetProp_IsIdentity;
		property Translation: IVector3 read _GetProp_Translation write _SetProp_Translation;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_MAYBENULLATTRIBUTE)]
	IMaybeNullAttribute = interface(IAttribute)
	['{1F1B65CB-3AD5-4263-978A-B0E04E8EAC9C}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_MAYBENULLWHENATTRIBUTE)]
	IMaybeNullWhenAttribute = interface(IAttribute)
	['{6FBE026C-AC62-4990-B515-3409B0822685}']
	{ private }
		function _GetProp_ReturnValue: Boolean;
	{ public }
		property ReturnValue: Boolean read _GetProp_ReturnValue;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_MEMBERNOTNULLATTRIBUTE)]
	IMemberNotNullAttribute = interface(IAttribute)
	['{A5E7CE7E-B426-4D2C-8A96-D3C02AB4888A}']
	{ private }
		function _GetProp_Members: TArray<String>;
	{ public }
		property Members: TArray<String> read _GetProp_Members;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_MEMBERNOTNULLWHENATTRIBUTE)]
	IMemberNotNullWhenAttribute = interface(IAttribute)
	['{9C4AE20D-AC8D-42BF-87E6-5AD79C596CB0}']
	{ private }
		function _GetProp_Members: TArray<String>;
		function _GetProp_ReturnValue: Boolean;
	{ public }
		property Members: TArray<String> read _GetProp_Members;
		property ReturnValue: Boolean read _GetProp_ReturnValue;
	end;

	IMemoryClass<T> = interface(ICoreClrClass)
	['{4A594735-562D-44BD-8C41-74BB5261514B}']
	{ private }
		{ class } function _GetProp_Empty: IMemory<T>;
	{ public }
		{ class } property Empty: IMemory<T> read _GetProp_Empty;
	end;

	[CoreTypeSignature(SYSTEM_MEMORY_1)]
	IMemory<T> = interface(IValueType)
	['{486704A7-3821-4F8F-B7C3-264301B687E6}']
	{ private }
		function _GetProp_IsEmpty: Boolean;
		function _GetProp_Length: Integer;
		function _GetProp_Span: ISpan<T>;
	{ public }
		procedure CopyTo(destination: IMemory<T>);
		function Equals(other: IMemory<T>): Boolean;
		function Pin(): IMemoryHandle;
		function Slice(start: Integer): IMemory<T>; overload;
		function Slice(start: Integer; length: Integer): IMemory<T>; overload;
		function ToArray(): TArray<T>;
		function TryCopyTo(destination: IMemory<T>): Boolean;
		property IsEmpty: Boolean read _GetProp_IsEmpty;
		property Length: Integer read _GetProp_Length;
		property Span: ISpan<T> read _GetProp_Span;
	end;

	IMemoryExtensionsClass = interface(ICoreClrClass)
	['{0CC76CD5-134F-404E-835A-94AE8548F29A}']
	{ public }
		{ class } function AsMemory(T: PTypeInfo; segment: IArraySegment<Variant{T}>): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(text: String): IReadOnlyMemory<Char>; overload;
		{ class } function AsMemory(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(T: PTypeInfo; segment: IArraySegment<Variant{T}>; start: Integer): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(text: String; start: Integer): IReadOnlyMemory<Char>; overload;
		{ class } function AsMemory(text: String; startIndex: IIndex): IReadOnlyMemory<Char>; overload;
		{ class } function AsMemory(text: String; range: IRange): IReadOnlyMemory<Char>; overload;
		{ class } function AsMemory(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; start: Integer): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: IIndex): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; range: IRange): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(T: PTypeInfo; segment: IArraySegment<Variant{T}>; start: Integer; length: Integer): IMemory<Variant{T}>; overload;
		{ class } function AsMemory(text: String; start: Integer; length: Integer): IReadOnlyMemory<Char>; overload;
		{ class } function AsMemory(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; start: Integer; length: Integer): IMemory<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; start: Integer): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; startIndex: IIndex): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; range: IRange): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(text: String; start: Integer): IReadOnlySpan<Char>; overload;
		{ class } function AsSpan(T: PTypeInfo; segment: IArraySegment<Variant{T}>; start: Integer): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; segment: IArraySegment<Variant{T}>; startIndex: IIndex): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; segment: IArraySegment<Variant{T}>; range: IRange): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(text: String): IReadOnlySpan<Char>; overload;
		{ class } function AsSpan(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; segment: IArraySegment<Variant{T}>): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(text: String; start: Integer; length: Integer): IReadOnlySpan<Char>; overload;
		{ class } function AsSpan(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; start: Integer; length: Integer): ISpan<Variant{T}>; overload;
		{ class } function AsSpan(T: PTypeInfo; segment: IArraySegment<Variant{T}>; start: Integer; length: Integer): ISpan<Variant{T}>; overload;
		{ class } function BinarySearch(T: PTypeInfo; span: ISpan<Variant{T}>; comparable: IIComparable<Variant{T}>): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; TComparable: PTypeInfo; span: ISpan<Variant{T}>; comparable: Variant{TComparable}): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; comparable: IIComparable<Variant{T}>): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; TComparable: PTypeInfo; span: IReadOnlySpan<Variant{T}>; comparable: Variant{TComparable}): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; TComparer: PTypeInfo; span: ISpan<Variant{T}>; value: Variant{T}; comparer: Variant{TComparer}): Integer; overload;
		{ class } function BinarySearch(T: PTypeInfo; TComparer: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: Variant{T}; comparer: Variant{TComparer}): Integer; overload;
		{ class } function CompareTo(span: IReadOnlySpan<Char>; other: IReadOnlySpan<Char>; comparisonType: TStringComparison): Integer;
		{ class } function Contains(span: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Boolean; overload;
		{ class } function Contains(T: PTypeInfo; span: ISpan<Variant{T}>; value: Variant{T}): Boolean; overload;
		{ class } function Contains(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: Variant{T}): Boolean; overload;
		{ class } procedure CopyTo(T: PTypeInfo; source: ICoreClrBridgeArray<Variant{T}>; destination: ISpan<Variant{T}>); overload;
		{ class } procedure CopyTo(T: PTypeInfo; source: ICoreClrBridgeArray<Variant{T}>; destination: IMemory<Variant{T}>); overload;
		{ class } function EndsWith(span: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Boolean; overload;
		{ class } function EndsWith(T: PTypeInfo; span: ISpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function EndsWith(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function EnumerateRunes(span: IReadOnlySpan<Char>): ISpanRuneEnumerator; overload;
		{ class } function EnumerateRunes(span: ISpan<Char>): ISpanRuneEnumerator; overload;
		{ class } function Equals(span: IReadOnlySpan<Char>; other: IReadOnlySpan<Char>; comparisonType: TStringComparison): Boolean;
		{ class } function IndexOf(span: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; span: ISpan<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; span: ISpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function IndexOf(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}; value2: Variant{T}): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}; value2: Variant{T}): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; values: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function IndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; values: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function IsWhiteSpace(span: IReadOnlySpan<Char>): Boolean;
		{ class } function LastIndexOf(span: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; span: ISpan<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; span: ISpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: Variant{T}): Integer; overload;
		{ class } function LastIndexOf(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}; value2: Variant{T}): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value0: Variant{T}; value1: Variant{T}; value2: Variant{T}): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: ISpan<Variant{T}>; values: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function LastIndexOfAny(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; values: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function Overlaps(T: PTypeInfo; span: ISpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function Overlaps(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function Overlaps(T: PTypeInfo; span: ISpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>; var elementOffset: Integer): Boolean; overload;
		{ class } function Overlaps(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>; var elementOffset: Integer): Boolean; overload;
		{ class } procedure Reverse(T: PTypeInfo; span: ISpan<Variant{T}>);
		{ class } function SequenceCompareTo(T: PTypeInfo; span: ISpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function SequenceCompareTo(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Integer; overload;
		{ class } function SequenceEqual(T: PTypeInfo; span: ISpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function SequenceEqual(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; other: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } procedure Sort(T: PTypeInfo; span: ISpan<Variant{T}>); overload;
		{ class } procedure Sort(T: PTypeInfo; TComparer: PTypeInfo; span: ISpan<Variant{T}>; comparer: Variant{TComparer}); overload;
		{ class } procedure Sort(T: PTypeInfo; span: ISpan<Variant{T}>; comparison: TComparison<Variant{T}>); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ISpan<Variant{TKey}>; items: ISpan<Variant{TValue}>); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; TComparer: PTypeInfo; keys: ISpan<Variant{TKey}>; items: ISpan<Variant{TValue}>; comparer: Variant{TComparer}); overload;
		{ class } procedure Sort(TKey: PTypeInfo; TValue: PTypeInfo; keys: ISpan<Variant{TKey}>; items: ISpan<Variant{TValue}>; comparison: TComparison<Variant{TKey}>); overload;
		{ class } function StartsWith(span: IReadOnlySpan<Char>; value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Boolean; overload;
		{ class } function StartsWith(T: PTypeInfo; span: ISpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function StartsWith(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; value: IReadOnlySpan<Variant{T}>): Boolean; overload;
		{ class } function ToLower(source: IReadOnlySpan<Char>; destination: ISpan<Char>; culture: ICultureInfo): Integer;
		{ class } function ToLowerInvariant(source: IReadOnlySpan<Char>; destination: ISpan<Char>): Integer;
		{ class } function ToUpper(source: IReadOnlySpan<Char>; destination: ISpan<Char>; culture: ICultureInfo): Integer;
		{ class } function ToUpperInvariant(source: IReadOnlySpan<Char>; destination: ISpan<Char>): Integer;
		{ class } function Trim(T: PTypeInfo; span: ISpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): ISpan<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlySpan<Variant{T}>; overload;
		{ class } function Trim(span: IReadOnlySpan<Char>; trimChar: Char): IReadOnlySpan<Char>; overload;
		{ class } function Trim(span: IReadOnlySpan<Char>; trimChars: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function Trim(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElement: Variant{T}): IMemory<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElement: Variant{T}): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; span: ISpan<Variant{T}>; trimElement: Variant{T}): ISpan<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElement: Variant{T}): IReadOnlySpan<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IMemory<Variant{T}>; overload;
		{ class } function Trim(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function Trim(memory: IMemory<Char>): IMemory<Char>; overload;
		{ class } function Trim(memory: IReadOnlyMemory<Char>): IReadOnlyMemory<Char>; overload;
		{ class } function Trim(span: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function Trim(span: ISpan<Char>): ISpan<Char>; overload;
		{ class } function TrimEnd(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; span: ISpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): ISpan<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlySpan<Variant{T}>; overload;
		{ class } function TrimEnd(span: IReadOnlySpan<Char>; trimChar: Char): IReadOnlySpan<Char>; overload;
		{ class } function TrimEnd(span: IReadOnlySpan<Char>; trimChars: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function TrimEnd(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElement: Variant{T}): IMemory<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElement: Variant{T}): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; span: ISpan<Variant{T}>; trimElement: Variant{T}): ISpan<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElement: Variant{T}): IReadOnlySpan<Variant{T}>; overload;
		{ class } function TrimEnd(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IMemory<Variant{T}>; overload;
		{ class } function TrimEnd(memory: IMemory<Char>): IMemory<Char>; overload;
		{ class } function TrimEnd(memory: IReadOnlyMemory<Char>): IReadOnlyMemory<Char>; overload;
		{ class } function TrimEnd(span: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function TrimEnd(span: ISpan<Char>): ISpan<Char>; overload;
		{ class } function TrimStart(T: PTypeInfo; span: ISpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): ISpan<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlySpan<Variant{T}>; overload;
		{ class } function TrimStart(span: IReadOnlySpan<Char>; trimChar: Char): IReadOnlySpan<Char>; overload;
		{ class } function TrimStart(span: IReadOnlySpan<Char>; trimChars: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function TrimStart(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElement: Variant{T}): IMemory<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElement: Variant{T}): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; span: ISpan<Variant{T}>; trimElement: Variant{T}): ISpan<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>; trimElement: Variant{T}): IReadOnlySpan<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; memory: IMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IMemory<Variant{T}>; overload;
		{ class } function TrimStart(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; trimElements: IReadOnlySpan<Variant{T}>): IReadOnlyMemory<Variant{T}>; overload;
		{ class } function TrimStart(memory: IMemory<Char>): IMemory<Char>; overload;
		{ class } function TrimStart(memory: IReadOnlyMemory<Char>): IReadOnlyMemory<Char>; overload;
		{ class } function TrimStart(span: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function TrimStart(span: ISpan<Char>): ISpan<Char>; overload;
	end;

	[CoreTypeSignature(SYSTEM_MEMORYEXTENSIONS)]
	IMemoryExtensions = interface(IObject)
	['{F1707B60-0D3D-43F6-81E5-242CA582AB39}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_MEMORYFAILPOINT)]
	IMemoryFailPoint = interface(ICriticalFinalizerObject)
	['{E4A010D0-2E0B-4223-804D-6AE4DC821461}']
	{ public }
		procedure Dispose();
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_MEMORYHANDLE)]
	IMemoryHandle = interface(IValueType)
	['{CE9113ED-B5DB-4FFE-A6E0-C506EF2F7C07}']
	{ private }
		function _GetProp_Pointer: ICoreClrInstance;
	{ public }
		procedure Dispose();
		property Pointer: ICoreClrInstance read _GetProp_Pointer;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_MEMORYMANAGER_1)]
	IMemoryManager<T> = interface(IObject)
	['{CA67B4C9-B391-4FEB-897C-C215B208F4B2}']
	{ private }
		function _GetProp_Memory: IMemory<T>;
	{ public }
		function GetSpan(): ISpan<T>;
		function Pin(elementIndex: Integer): IMemoryHandle;
		procedure Unpin();
		property Memory: IMemory<T> read _GetProp_Memory;
	end;

	IMemoryMarshalClass = interface(ICoreClrClass)
	['{D0BDFAD3-282E-427F-82F4-083D623D0A17}']
	{ public }
		{ class } function AsBytes(T: PTypeInfo; span: ISpan<Variant{T}>): ISpan<Byte>; overload;
		{ class } function AsBytes(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>): IReadOnlySpan<Byte>; overload;
		{ class } function AsMemory(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>): IMemory<Variant{T}>;
		{ class } function AsRef(T: PTypeInfo; span: ISpan<Byte>): Variant{T}; overload;
		{ class } function AsRef(T: PTypeInfo; span: IReadOnlySpan<Byte>): Variant{T}; overload;
		{ class } function Cast(TFrom: PTypeInfo; TTo: PTypeInfo; span: ISpan<Variant{TFrom}>): ISpan<Variant{TTo}>; overload;
		{ class } function Cast(TFrom: PTypeInfo; TTo: PTypeInfo; span: IReadOnlySpan<Variant{TFrom}>): IReadOnlySpan<Variant{TTo}>; overload;
		{ class } function CreateFromPinnedArray(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; start: Integer; length: Integer): IMemory<Variant{T}>;
		{ class } function CreateReadOnlySpan(T: PTypeInfo; var reference: Variant{T}; length: Integer): IReadOnlySpan<Variant{T}>;
		{ class } function CreateSpan(T: PTypeInfo; var reference: Variant{T}; length: Integer): ISpan<Variant{T}>;
		{ class } function GetArrayDataReference(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>): Variant{T};
		{ class } function GetReference(T: PTypeInfo; span: ISpan<Variant{T}>): Variant{T}; overload;
		{ class } function GetReference(T: PTypeInfo; span: IReadOnlySpan<Variant{T}>): Variant{T}; overload;
		{ class } function Read(T: PTypeInfo; source: IReadOnlySpan<Byte>): Variant{T};
		{ class } function ToEnumerable(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>): IIEnumerable<Variant{T}>;
		{ class } function TryGetArray(T: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; var segment: IArraySegment<Variant{T}>): Boolean;
		{ class } function TryGetMemoryManager(T: PTypeInfo; TManager: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; var manager: Variant{TManager}): Boolean; overload;
		{ class } function TryGetMemoryManager(T: PTypeInfo; TManager: PTypeInfo; memory: IReadOnlyMemory<Variant{T}>; var manager: Variant{TManager}; var start: Integer; var length: Integer): Boolean; overload;
		{ class } function TryGetString(memory: IReadOnlyMemory<Char>; var text: String; var start: Integer; var length: Integer): Boolean;
		{ class } function TryRead(T: PTypeInfo; source: IReadOnlySpan<Byte>; var value: Variant{T}): Boolean;
		{ class } function TryWrite(T: PTypeInfo; destination: ISpan<Byte>; var value: Variant{T}): Boolean;
		{ class } procedure Write(T: PTypeInfo; destination: ISpan<Byte>; var value: Variant{T});
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_MEMORYMARSHAL)]
	IMemoryMarshal = interface(IObject)
	['{CB52A1B4-0280-4DB7-9559-A1D8BED95D41}']
	end;

	[CoreTypeSignature(SYSTEM_IO_MEMORYSTREAM)]
	IMemoryStream = interface(IStream)
	['{BDF992DF-2743-47F0-B4CB-1BCCCA88E132}']
	{ private }
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanSeek: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Capacity: Integer;
		procedure _SetProp_Capacity(Value: Integer);
		function _GetProp_Length: Int64;
		function _GetProp_Position: Int64;
		procedure _SetProp_Position(Value: Int64);
	{ public }
		procedure CopyTo(destination: IStream; bufferSize: Integer);
		function CopyToAsync(destination: IStream; bufferSize: Integer; cancellationToken: ICancellationToken): ITask;
		procedure Flush();
		function FlushAsync(cancellationToken: ICancellationToken): ITask;
		function GetBuffer(): TArray<Byte>;
		function Read(buffer: TArray<Byte>; offset: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Byte>): Integer; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Byte>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadByte(): Integer;
		function Seek(offset: Int64; loc: TSeekOrigin): Int64;
		procedure SetLength(value: Int64);
		function ToArray(): TArray<Byte>;
		function TryGetBuffer(var buffer: IArraySegment<Byte>): Boolean;
		procedure Write(buffer: TArray<Byte>; offset: Integer; count: Integer); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Byte>; cancellationToken: ICancellationToken): IValueTask; overload;
		procedure WriteByte(value: Byte);
		procedure WriteTo(stream: IStream);
		property CanRead: Boolean read _GetProp_CanRead;
		property CanSeek: Boolean read _GetProp_CanSeek;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Capacity: Integer read _GetProp_Capacity write _SetProp_Capacity;
		property Length: Int64 read _GetProp_Length;
		property Position: Int64 read _GetProp_Position write _SetProp_Position;
	end;

	[CoreTypeSignature(SYSTEM_METHODACCESSEXCEPTION)]
	IMethodAccessException = interface(IMemberAccessException)
	['{D4AB0AFE-408D-4125-BD2F-7A76AEE71304}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_METHODBODY)]
	IMethodBody = interface(IObject)
	['{CEE3237F-22FD-41D3-A6B9-A850BE496881}']
	{ private }
		function _GetProp_ExceptionHandlingClauses: IIList<IExceptionHandlingClause>;
		function _GetProp_InitLocals: Boolean;
		function _GetProp_LocalSignatureMetadataToken: Integer;
		function _GetProp_LocalVariables: IIList<ILocalVariableInfo>;
		function _GetProp_MaxStackSize: Integer;
	{ public }
		function GetILAsByteArray(): TArray<Byte>;
		property ExceptionHandlingClauses: IIList<IExceptionHandlingClause> read _GetProp_ExceptionHandlingClauses;
		property InitLocals: Boolean read _GetProp_InitLocals;
		property LocalSignatureMetadataToken: Integer read _GetProp_LocalSignatureMetadataToken;
		property LocalVariables: IIList<ILocalVariableInfo> read _GetProp_LocalVariables;
		property MaxStackSize: Integer read _GetProp_MaxStackSize;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_METHODBUILDER)]
	IMethodBuilder = interface(IMethodInfo)
	['{BAA0EB6B-7B89-4AE5-9840-A9098AA41D71}']
	{ private }
		function _GetProp_Attributes: TMethodAttributes_Set;
		function _GetProp_CallingConvention: TCallingConventions_Set;
		function _GetProp_ContainsGenericParameters: Boolean;
		function _GetProp_DeclaringType: IType;
		function _GetProp_InitLocals: Boolean;
		procedure _SetProp_InitLocals(Value: Boolean);
		function _GetProp_IsGenericMethod: Boolean;
		function _GetProp_IsGenericMethodDefinition: Boolean;
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_MethodHandle: IRuntimeMethodHandle;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_ReflectedType: IType;
		function _GetProp_ReturnParameter: IParameterInfo;
		function _GetProp_ReturnType: IType;
		function _GetProp_ReturnTypeCustomAttributes: IICustomAttributeProvider;
		function _GetProp_Signature: String;
	{ public }
		function DefineGenericParameters(names: TArray<String>): TArray<IGenericTypeParameterBuilder>;
		function DefineParameter(position: Integer; attributes: TParameterAttributes_Set; strParamName: String): IParameterBuilder;
		function GetBaseDefinition(): IMethodInfo;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetGenericArguments(): TArray<IType>;
		function GetGenericMethodDefinition(): IMethodInfo;
		function GetILGenerator(): IILGenerator; overload;
		function GetILGenerator(size: Integer): IILGenerator; overload;
		function GetMethodImplementationFlags(): TMethodImplAttributes;
		function GetModule(): IModule;
		function GetParameters(): TArray<IParameterInfo>;
		function GetToken(): IMethodToken;
		function Invoke(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; parameters: TArray<Variant>; culture: ICultureInfo): Variant;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function MakeGenericMethod(typeArguments: ICoreClrBridgeArray<IType>): IMethodInfo;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetImplementationFlags(attributes: TMethodImplAttributes);
		procedure SetParameters(parameterTypes: ICoreClrBridgeArray<IType>);
		procedure SetReturnType(returnType: IType);
		procedure SetSignature(returnType: IType; returnTypeRequiredCustomModifiers: ICoreClrBridgeArray<IType>; returnTypeOptionalCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; parameterTypeRequiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; parameterTypeOptionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>);
		property Attributes: TMethodAttributes_Set read _GetProp_Attributes;
		property CallingConvention: TCallingConventions_Set read _GetProp_CallingConvention;
		property ContainsGenericParameters: Boolean read _GetProp_ContainsGenericParameters;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property InitLocals: Boolean read _GetProp_InitLocals write _SetProp_InitLocals;
		property IsGenericMethod: Boolean read _GetProp_IsGenericMethod;
		property IsGenericMethodDefinition: Boolean read _GetProp_IsGenericMethodDefinition;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property MethodHandle: IRuntimeMethodHandle read _GetProp_MethodHandle;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property ReturnParameter: IParameterInfo read _GetProp_ReturnParameter;
		property ReturnType: IType read _GetProp_ReturnType;
		property ReturnTypeCustomAttributes: IICustomAttributeProvider read _GetProp_ReturnTypeCustomAttributes;
		property Signature: String read _GetProp_Signature;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_METHODIMPLATTRIBUTE)]
	IMethodImplAttribute = interface(IAttribute)
	['{B422323F-6F36-4F09-B65F-140E1AF431DB}']
	{ private }
		function _GetFld_MethodCodeType: TMethodCodeType;
		procedure _SetFld_MethodCodeType(Value: TMethodCodeType);
		function _GetProp_Value: TMethodImplOptions_Set;
	{ public }
		property MethodCodeType: TMethodCodeType read _GetFld_MethodCodeType write _SetFld_MethodCodeType;
		property Value: TMethodImplOptions_Set read _GetProp_Value;
	end;

	IMethodTokenClass = interface(ICoreClrClass)
	['{32C2D789-D277-4ED9-B44D-5999A408D301}']
	{ private }
		{ class } function _GetFld_Empty: IMethodToken;
	{ public }
		{ class } property Empty: IMethodToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_METHODTOKEN)]
	IMethodToken = interface(IValueType)
	['{D9512842-E972-4BAE-9861-E3131B936692}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IMethodToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	IMissingClass = interface(ICoreClrClass)
	['{B50A9F07-A76E-4459-81F6-54E9E6195EC5}']
	{ private }
		{ class } function _GetFld_Value: IMissing;
	{ public }
		{ class } property Value: IMissing read _GetFld_Value;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_MISSING)]
	IMissing = interface(IISerializable)
	['{2920A40B-A2AC-4893-8F78-3CE6F7A460EA}']
	end;

	[CoreTypeSignature(SYSTEM_MISSINGMEMBEREXCEPTION)]
	IMissingMemberException = interface(IMemberAccessException)
	['{C427D9EE-FC89-4DA2-A623-7AD173976343}']
	{ private }
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_MISSINGFIELDEXCEPTION)]
	IMissingFieldException = interface(IMissingMemberException)
	['{88D1FC77-36F8-4372-8EDA-0B124034C127}']
	{ private }
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_MISSINGMANIFESTRESOURCEEXCEPTION)]
	IMissingManifestResourceException = interface(ISystemException)
	['{6C57B305-0EF6-4CB2-B55C-94CFC221EC66}']
	end;

	[CoreTypeSignature(SYSTEM_MISSINGMETHODEXCEPTION)]
	IMissingMethodException = interface(IMissingMemberException)
	['{686FD921-4E1C-494A-888E-7A5DC4FE1897}']
	{ private }
		function _GetProp_Message: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_MISSINGSATELLITEASSEMBLYEXCEPTION)]
	IMissingSatelliteAssemblyException = interface(ISystemException)
	['{C21B993E-33C6-45DF-8952-1EE010DE7AE7}']
	{ private }
		function _GetProp_CultureName: String;
	{ public }
		property CultureName: String read _GetProp_CultureName;
	end;

	IModuleClass = interface(ICoreClrClass)
	['{8C4E1756-D40C-442B-B7C7-BE31DB069F9B}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_MODULE)]
	IModule = interface(IObject)
	['{45D7EBF9-0C32-4420-B5D9-F3D40A2D383B}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_CustomAttributes: IIEnumerable<ICustomAttributeData>;
		function _GetProp_FullyQualifiedName: String;
		function _GetProp_MDStreamVersion: Integer;
		function _GetProp_MetadataToken: Integer;
		function _GetProp_ModuleHandle: IModuleHandle;
		function _GetProp_ModuleVersionId: IGuid;
		function _GetProp_Name: String;
		function _GetProp_ScopeName: String;
	{ public }
		function FindTypes(filter: TTypeFilter; filterCriteria: Variant): TArray<IType>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function GetField(name: String): IFieldInfo; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo; overload;
		function GetFields(): TArray<IFieldInfo>; overload;
		function GetFields(bindingFlags: TBindingFlags_Set): TArray<IFieldInfo>; overload;
		function GetMethod(name: String): IMethodInfo; overload;
		function GetMethod(name: String; types: ICoreClrBridgeArray<IType>): IMethodInfo; overload;
		function GetMethod(name: String; bindingAttr: TBindingFlags_Set; binder: IBinder; callConvention: TCallingConventions_Set; types: ICoreClrBridgeArray<IType>; modifiers: ICoreClrBridgeArray<IParameterModifier>): IMethodInfo; overload;
		function GetMethods(): TArray<IMethodInfo>; overload;
		function GetMethods(bindingFlags: TBindingFlags_Set): TArray<IMethodInfo>; overload;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure GetPEKind(var peKind: TPortableExecutableKinds_Set; var machine: TImageFileMachine);
		function GetType(className: String): IType; overload;
		function GetType(className: String; ignoreCase: Boolean): IType; overload;
		function GetType(className: String; throwOnError: Boolean; ignoreCase: Boolean): IType; overload;
		function GetTypes(): TArray<IType>;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function IsResource(): Boolean;
		function ResolveField(metadataToken: Integer): IFieldInfo; overload;
		function ResolveField(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IFieldInfo; overload;
		function ResolveMember(metadataToken: Integer): IMemberInfo; overload;
		function ResolveMember(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IMemberInfo; overload;
		function ResolveMethod(metadataToken: Integer): IMethodBase; overload;
		function ResolveMethod(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IMethodBase; overload;
		function ResolveSignature(metadataToken: Integer): TArray<Byte>;
		function ResolveString(metadataToken: Integer): String;
		function ResolveType(metadataToken: Integer): IType; overload;
		function ResolveType(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IType; overload;
		property Assembly: IAssembly read _GetProp_Assembly;
		property CustomAttributes: IIEnumerable<ICustomAttributeData> read _GetProp_CustomAttributes;
		property FullyQualifiedName: String read _GetProp_FullyQualifiedName;
		property MDStreamVersion: Integer read _GetProp_MDStreamVersion;
		property MetadataToken: Integer read _GetProp_MetadataToken;
		property ModuleHandle: IModuleHandle read _GetProp_ModuleHandle;
		property ModuleVersionId: IGuid read _GetProp_ModuleVersionId;
		property Name: String read _GetProp_Name;
		property ScopeName: String read _GetProp_ScopeName;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_MODULEBUILDER)]
	IModuleBuilder = interface(IModule)
	['{4946C9AD-0D87-4B27-861E-B00F7A63B33F}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_FullyQualifiedName: String;
		function _GetProp_MDStreamVersion: Integer;
		function _GetProp_MetadataToken: Integer;
		function _GetProp_ModuleVersionId: IGuid;
		function _GetProp_Name: String;
		function _GetProp_ScopeName: String;
	{ public }
		procedure CreateGlobalFunctions();
		function DefineDocument(url: String; language: IGuid; languageVendor: IGuid; documentType: IGuid): IISymbolDocumentWriter;
		function DefineEnum(name: String; visibility: TTypeAttributes_Set; underlyingType: IType): IEnumBuilder;
		function DefineGlobalMethod(name: String; attributes: TMethodAttributes_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodBuilder; overload;
		function DefineGlobalMethod(name: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodBuilder; overload;
		function DefineGlobalMethod(name: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; requiredReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; optionalReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; requiredParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; optionalParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): IMethodBuilder; overload;
		function DefineInitializedData(name: String; data: TArray<Byte>; attributes: TFieldAttributes_Set): IFieldBuilder;
		function DefinePInvokeMethod(name: String; dllName: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>; nativeCallConv: TCallingConvention; nativeCharSet: TCharSet): IMethodBuilder; overload;
		function DefinePInvokeMethod(name: String; dllName: String; entryName: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>; nativeCallConv: TCallingConvention; nativeCharSet: TCharSet): IMethodBuilder; overload;
		function DefineType(name: String): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set; parent: IType): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set; parent: IType; typesize: Integer): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set; parent: IType; interfaces: ICoreClrBridgeArray<IType>): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set; parent: IType; packsize: TPackingSize): ITypeBuilder; overload;
		function DefineType(name: String; attr: TTypeAttributes_Set; parent: IType; packingSize: TPackingSize; typesize: Integer): ITypeBuilder; overload;
		function DefineUninitializedData(name: String; size: Integer; attributes: TFieldAttributes_Set): IFieldBuilder;
		function GetArrayMethod(arrayClass: IType; methodName: String; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodInfo;
		function GetArrayMethodToken(arrayClass: IType; methodName: String; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodToken;
		function GetConstructorToken(con: IConstructorInfo): IMethodToken;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingFlags: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetFieldToken(field: IFieldInfo): IFieldToken;
		function GetMethods(bindingFlags: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetMethodToken(method: IMethodInfo): IMethodToken;
		procedure GetPEKind(var peKind: TPortableExecutableKinds_Set; var machine: TImageFileMachine);
		function GetSignatureToken(sigHelper: ISignatureHelper): ISignatureToken; overload;
		function GetSignatureToken(sigBytes: TArray<Byte>; sigLength: Integer): ISignatureToken; overload;
		function GetStringConstant(str: String): IStringToken;
		function GetType(className: String): IType; overload;
		function GetType(className: String; ignoreCase: Boolean): IType; overload;
		function GetType(className: String; throwOnError: Boolean; ignoreCase: Boolean): IType; overload;
		function GetTypes(): TArray<IType>;
		function GetTypeToken(type_: IType): ITypeToken; overload;
		function GetTypeToken(name: String): ITypeToken; overload;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function IsResource(): Boolean;
		function IsTransient(): Boolean;
		function ResolveField(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IFieldInfo;
		function ResolveMember(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IMemberInfo;
		function ResolveMethod(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IMethodBase;
		function ResolveSignature(metadataToken: Integer): TArray<Byte>;
		function ResolveString(metadataToken: Integer): String;
		function ResolveType(metadataToken: Integer; genericTypeArguments: ICoreClrBridgeArray<IType>; genericMethodArguments: ICoreClrBridgeArray<IType>): IType;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		property Assembly: IAssembly read _GetProp_Assembly;
		property FullyQualifiedName: String read _GetProp_FullyQualifiedName;
		property MDStreamVersion: Integer read _GetProp_MDStreamVersion;
		property MetadataToken: Integer read _GetProp_MetadataToken;
		property ModuleVersionId: IGuid read _GetProp_ModuleVersionId;
		property Name: String read _GetProp_Name;
		property ScopeName: String read _GetProp_ScopeName;
	end;

	IModuleHandleClass = interface(ICoreClrClass)
	['{4A9D41E3-945D-4F1C-ADEF-EF8D4DB53246}']
	{ private }
		{ class } function _GetFld_EmptyHandle: IModuleHandle;
	{ public }
		{ class } property EmptyHandle: IModuleHandle read _GetFld_EmptyHandle;
	end;

	[CoreTypeSignature(SYSTEM_MODULEHANDLE)]
	IModuleHandle = interface(IValueType)
	['{1ABC9611-371C-4750-AE42-2CB6DC9492BD}']
	{ private }
		function _GetProp_MDStreamVersion: Integer;
	{ public }
		function Equals(handle: IModuleHandle): Boolean;
		function GetRuntimeFieldHandleFromMetadataToken(fieldToken: Integer): IRuntimeFieldHandle;
		function GetRuntimeMethodHandleFromMetadataToken(methodToken: Integer): IRuntimeMethodHandle;
		function GetRuntimeTypeHandleFromMetadataToken(typeToken: Integer): IRuntimeTypeHandle;
		function ResolveFieldHandle(fieldToken: Integer): IRuntimeFieldHandle; overload;
		function ResolveFieldHandle(fieldToken: Integer; typeInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>; methodInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>): IRuntimeFieldHandle; overload;
		function ResolveMethodHandle(methodToken: Integer): IRuntimeMethodHandle; overload;
		function ResolveMethodHandle(methodToken: Integer; typeInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>; methodInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>): IRuntimeMethodHandle; overload;
		function ResolveTypeHandle(typeToken: Integer): IRuntimeTypeHandle; overload;
		function ResolveTypeHandle(typeToken: Integer; typeInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>; methodInstantiationContext: ICoreClrBridgeArray<IRuntimeTypeHandle>): IRuntimeTypeHandle; overload;
		property MDStreamVersion: Integer read _GetProp_MDStreamVersion;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_MODULEINITIALIZERATTRIBUTE)]
	IModuleInitializerAttribute = interface(IAttribute)
	['{68A86A95-E254-469A-A7E7-272C259ED474}']
	end;

	IMonitorClass = interface(ICoreClrClass)
	['{9A5B45C8-0C83-49D3-AE97-09659733EF1D}']
	{ private }
		{ class } function _GetProp_LockContentionCount: Int64;
	{ public }
		{ class } procedure Enter(obj: Variant); overload;
		{ class } procedure Enter(obj: Variant; var lockTaken: Boolean); overload;
		{ class } procedure Exit(obj: Variant);
		{ class } function IsEntered(obj: Variant): Boolean;
		{ class } procedure Pulse(obj: Variant);
		{ class } procedure PulseAll(obj: Variant);
		{ class } function TryEnter(obj: Variant): Boolean; overload;
		{ class } procedure TryEnter(obj: Variant; var lockTaken: Boolean); overload;
		{ class } function TryEnter(obj: Variant; millisecondsTimeout: Integer): Boolean; overload;
		{ class } function TryEnter(obj: Variant; timeout: ITimeSpan): Boolean; overload;
		{ class } procedure TryEnter(obj: Variant; millisecondsTimeout: Integer; var lockTaken: Boolean); overload;
		{ class } procedure TryEnter(obj: Variant; timeout: ITimeSpan; var lockTaken: Boolean); overload;
		{ class } function Wait(obj: Variant; millisecondsTimeout: Integer; exitContext: Boolean): Boolean; overload;
		{ class } function Wait(obj: Variant; timeout: ITimeSpan; exitContext: Boolean): Boolean; overload;
		{ class } function Wait(obj: Variant; millisecondsTimeout: Integer): Boolean; overload;
		{ class } function Wait(obj: Variant; timeout: ITimeSpan): Boolean; overload;
		{ class } function Wait(obj: Variant): Boolean; overload;
		{ class } property LockContentionCount: Int64 read _GetProp_LockContentionCount;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_MONITOR)]
	IMonitor = interface(IObject)
	['{88CA46A0-3E34-495C-8F02-7575B4790920}']
	end;

	[CoreTypeSignature(SYSTEM_MTATHREADATTRIBUTE)]
	IMTAThreadAttribute = interface(IAttribute)
	['{5277596A-7D5E-40AE-9FF9-F2528E94D7A3}']
	end;

	[CoreTypeSignature(SYSTEM_MULTICASTDELEGATE)]
	IMulticastDelegate = interface(IDelegate)
	['{8E854C89-4190-4C49-9805-894C29CCBF40}']
	{ public }
		function GetInvocationList(): TArray<IDelegate>;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	[CoreTypeSignature(SYSTEM_MULTICASTNOTSUPPORTEDEXCEPTION)]
	IMulticastNotSupportedException = interface(ISystemException)
	['{CF414390-7E2A-416D-B9B4-E6F77E66E1F5}']
	end;

	IMutexClass = interface(ICoreClrClass)
	['{475B0FFB-B713-45AA-9F76-1713C85F9DE0}']
	{ public }
		{ class } function OpenExisting(name: String): IMutex;
		{ class } function TryOpenExisting(name: String; var result_: IMutex): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_MUTEX)]
	IMutex = interface(IWaitHandle)
	['{BEADDCB0-9803-4F81-83D3-C90B96AC546F}']
	{ public }
		procedure ReleaseMutex();
	end;

	INativeLibraryClass = interface(ICoreClrClass)
	['{7EF06768-3A2D-45C5-8982-061006F80903}']
	{ public }
		{ class } procedure Free(handle: IIntPtr);
		{ class } function GetExport(handle: IIntPtr; name: String): IIntPtr;
		{ class } function Load(libraryPath: String): IIntPtr; overload;
		{ class } function Load(libraryName: String; assembly: IAssembly; searchPath: Nullable<TDllImportSearchPath_Set>): IIntPtr; overload;
		{ class } procedure SetDllImportResolver(assembly: IAssembly; resolver: TDllImportResolver);
		{ class } function TryGetExport(handle: IIntPtr; name: String; var address: IIntPtr): Boolean;
		{ class } function TryLoad(libraryPath: String; var handle: IIntPtr): Boolean; overload;
		{ class } function TryLoad(libraryName: String; assembly: IAssembly; searchPath: Nullable<TDllImportSearchPath_Set>; var handle: IIntPtr): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_NATIVELIBRARY)]
	INativeLibrary = interface(IObject)
	['{AF43CE73-8297-46CD-A761-D436F203798D}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_NATIVEOVERLAPPED)]
	INativeOverlapped = interface(IValueType)
	['{EFE4248D-2608-486E-94A0-2CE42E58309C}']
	{ private }
		function _GetFld_EventHandle: IIntPtr;
		procedure _SetFld_EventHandle(Value: IIntPtr);
		function _GetFld_InternalHigh: IIntPtr;
		procedure _SetFld_InternalHigh(Value: IIntPtr);
		function _GetFld_InternalLow: IIntPtr;
		procedure _SetFld_InternalLow(Value: IIntPtr);
		function _GetFld_OffsetHigh: Integer;
		procedure _SetFld_OffsetHigh(Value: Integer);
		function _GetFld_OffsetLow: Integer;
		procedure _SetFld_OffsetLow(Value: Integer);
	{ public }
		property EventHandle: IIntPtr read _GetFld_EventHandle write _SetFld_EventHandle;
		property InternalHigh: IIntPtr read _GetFld_InternalHigh write _SetFld_InternalHigh;
		property InternalLow: IIntPtr read _GetFld_InternalLow write _SetFld_InternalLow;
		property OffsetHigh: Integer read _GetFld_OffsetHigh write _SetFld_OffsetHigh;
		property OffsetLow: Integer read _GetFld_OffsetLow write _SetFld_OffsetLow;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_NEUTRALRESOURCESLANGUAGEATTRIBUTE)]
	INeutralResourcesLanguageAttribute = interface(IAttribute)
	['{AA8C12CD-F6D6-4F59-BCCC-8AAEA96EDB02}']
	{ private }
		function _GetProp_CultureName: String;
		function _GetProp_Location: TUltimateResourceFallbackLocation;
	{ public }
		property CultureName: String read _GetProp_CultureName;
		property Location: TUltimateResourceFallbackLocation read _GetProp_Location;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_NLSENUMCALENDARSDATA)]
	INlsEnumCalendarsData = interface(IValueType)
	['{E48C0309-0E8E-4708-BBB3-F6DBBC49A9F0}']
	{ private }
		function _GetFld_calendars: IList<Integer>;
		procedure _SetFld_calendars(Value: IList<Integer>);
		function _GetFld_userOverride: Integer;
		procedure _SetFld_userOverride(Value: Integer);
	{ public }
		property calendars: IList<Integer> read _GetFld_calendars write _SetFld_calendars;
		property userOverride: Integer read _GetFld_userOverride write _SetFld_userOverride;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_NONEVENTATTRIBUTE)]
	INonEventAttribute = interface(IAttribute)
	['{CA5D88EF-65A0-4137-B38B-987847D9569A}']
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_NONRANDOMIZEDSTRINGEQUALITYCOMPARER)]
	INonRandomizedStringEqualityComparer = interface(IObject)
	['{B3481C2E-437D-479F-A555-9FF49F02E014}']
	{ public }
		function Equals(x: String; y: String): Boolean;
		function GetHashCode(obj: String): Integer;
		function GetUnderlyingEqualityComparer(): IIEqualityComparer<String>;
	end;

	[CoreTypeSignature(SYSTEM_NONSERIALIZEDATTRIBUTE)]
	INonSerializedAttribute = interface(IAttribute)
	['{8A99442F-D39B-48CA-9FE2-E8093968C8E7}']
	end;

	[CoreTypeSignature(SYSTEM_NOTFINITENUMBEREXCEPTION)]
	INotFiniteNumberException = interface(IArithmeticException)
	['{444013CC-504C-4D8B-A8B5-DCA4313BACAA}']
	{ private }
		function _GetProp_OffendingNumber: Double;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property OffendingNumber: Double read _GetProp_OffendingNumber;
	end;

	[CoreTypeSignature(SYSTEM_NOTIMPLEMENTEDEXCEPTION)]
	INotImplementedException = interface(ISystemException)
	['{B53C4EB8-0118-4657-9F0D-755AE114DCBB}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_NOTNULLATTRIBUTE)]
	INotNullAttribute = interface(IAttribute)
	['{FE91F4E6-243E-4A8F-B167-EB8883C139DA}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_NOTNULLIFNOTNULLATTRIBUTE)]
	INotNullIfNotNullAttribute = interface(IAttribute)
	['{7801FCF3-4D9F-45E0-9E14-6F204F4D25A3}']
	{ private }
		function _GetProp_ParameterName: String;
	{ public }
		property ParameterName: String read _GetProp_ParameterName;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_NOTNULLWHENATTRIBUTE)]
	INotNullWhenAttribute = interface(IAttribute)
	['{B77839DE-C861-477D-A3F1-9669E0555A25}']
	{ private }
		function _GetProp_ReturnValue: Boolean;
	{ public }
		property ReturnValue: Boolean read _GetProp_ReturnValue;
	end;

	[CoreTypeSignature(SYSTEM_NOTSUPPORTEDEXCEPTION)]
	INotSupportedException = interface(ISystemException)
	['{ED6A4D4D-968D-45F6-BFCE-52689EDF0ECC}']
	end;

	INullableClass = interface(ICoreClrClass)
	['{A2BE8471-F10D-41B0-B2D8-8A4F80F05E2A}']
	{ public }
		{ class } function Compare(T: PTypeInfo; n1: INullable<Variant{T}>; n2: INullable<Variant{T}>): Integer;
		{ class } function Equals(T: PTypeInfo; n1: INullable<Variant{T}>; n2: INullable<Variant{T}>): Boolean;
		{ class } function GetUnderlyingType(nullableType: IType): IType;
	end;

	[CoreTypeSignature(SYSTEM_NULLABLE)]
	INullable = interface(IObject)
	['{222E50A5-A873-4372-AB96-EA1A4D1EFC0D}']
	end;

	[CoreTypeSignature(SYSTEM_NULLABLE_1)]
	INullable<T> = interface(IValueType)
	['{FAFA9ABD-999A-452A-B41F-5E737920AA52}']
	{ private }
		function _GetProp_HasValue: Boolean;
		function _GetProp_Value: T;
	{ public }
		function GetValueOrDefault(): T; overload;
		function GetValueOrDefault(defaultValue: T): T; overload;
		property HasValue: Boolean read _GetProp_HasValue;
		property Value: T read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_NULLABLECOMPARER_1)]
	INullableComparer<T> = interface(IComparer<INullable<T>>)
	['{42114D13-4AEF-4E7B-AD6D-0AED80661C29}']
	{ public }
		function Compare(x: INullable<T>; y: INullable<T>): Integer;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_NULLABLEEQUALITYCOMPARER_1)]
	INullableEqualityComparer<T> = interface(IEqualityComparer<INullable<T>>)
	['{FA398B28-2800-4AFF-B6B1-0B7059BFAD41}']
	{ public }
		function Equals(x: INullable<T>; y: INullable<T>): Boolean;
		function GetHashCode(obj: INullable<T>): Integer;
	end;

	[CoreTypeSignature(SYSTEM_NULLREFERENCEEXCEPTION)]
	INullReferenceException = interface(ISystemException)
	['{DB66E166-3569-43FE-92D7-5B65FAB9C0A0}']
	end;

	INumberFormatInfoClass = interface(ICoreClrClass)
	['{E0CE715A-2CAB-4992-8CB5-97FF89A5241E}']
	{ private }
		{ class } function _GetProp_CurrentInfo: INumberFormatInfo;
		{ class } function _GetProp_InvariantInfo: INumberFormatInfo;
	{ public }
		{ class } function GetInstance(formatProvider: IIFormatProvider): INumberFormatInfo;
		{ class } function &ReadOnly(nfi: INumberFormatInfo): INumberFormatInfo;
		{ class } property CurrentInfo: INumberFormatInfo read _GetProp_CurrentInfo;
		{ class } property InvariantInfo: INumberFormatInfo read _GetProp_InvariantInfo;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_NUMBERFORMATINFO)]
	INumberFormatInfo = interface(IObject)
	['{196D1438-6B5A-4D11-B50D-379301C1B7F3}']
	{ private }
		function _GetProp_CurrencyDecimalDigits: Integer;
		procedure _SetProp_CurrencyDecimalDigits(Value: Integer);
		function _GetProp_CurrencyDecimalSeparator: String;
		procedure _SetProp_CurrencyDecimalSeparator(Value: String);
		function _GetProp_CurrencyGroupSeparator: String;
		procedure _SetProp_CurrencyGroupSeparator(Value: String);
		function _GetProp_CurrencyGroupSizes: TArray<Integer>;
		procedure _SetProp_CurrencyGroupSizes(Value: TArray<Integer>);
		function _GetProp_CurrencyNegativePattern: Integer;
		procedure _SetProp_CurrencyNegativePattern(Value: Integer);
		function _GetProp_CurrencyPositivePattern: Integer;
		procedure _SetProp_CurrencyPositivePattern(Value: Integer);
		function _GetProp_CurrencySymbol: String;
		procedure _SetProp_CurrencySymbol(Value: String);
		function _GetProp_DigitSubstitution: TDigitShapes;
		procedure _SetProp_DigitSubstitution(Value: TDigitShapes);
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_NaNSymbol: String;
		procedure _SetProp_NaNSymbol(Value: String);
		function _GetProp_NativeDigits: TArray<String>;
		procedure _SetProp_NativeDigits(Value: TArray<String>);
		function _GetProp_NegativeInfinitySymbol: String;
		procedure _SetProp_NegativeInfinitySymbol(Value: String);
		function _GetProp_NegativeSign: String;
		procedure _SetProp_NegativeSign(Value: String);
		function _GetProp_NumberDecimalDigits: Integer;
		procedure _SetProp_NumberDecimalDigits(Value: Integer);
		function _GetProp_NumberDecimalSeparator: String;
		procedure _SetProp_NumberDecimalSeparator(Value: String);
		function _GetProp_NumberGroupSeparator: String;
		procedure _SetProp_NumberGroupSeparator(Value: String);
		function _GetProp_NumberGroupSizes: TArray<Integer>;
		procedure _SetProp_NumberGroupSizes(Value: TArray<Integer>);
		function _GetProp_NumberNegativePattern: Integer;
		procedure _SetProp_NumberNegativePattern(Value: Integer);
		function _GetProp_PercentDecimalDigits: Integer;
		procedure _SetProp_PercentDecimalDigits(Value: Integer);
		function _GetProp_PercentDecimalSeparator: String;
		procedure _SetProp_PercentDecimalSeparator(Value: String);
		function _GetProp_PercentGroupSeparator: String;
		procedure _SetProp_PercentGroupSeparator(Value: String);
		function _GetProp_PercentGroupSizes: TArray<Integer>;
		procedure _SetProp_PercentGroupSizes(Value: TArray<Integer>);
		function _GetProp_PercentNegativePattern: Integer;
		procedure _SetProp_PercentNegativePattern(Value: Integer);
		function _GetProp_PercentPositivePattern: Integer;
		procedure _SetProp_PercentPositivePattern(Value: Integer);
		function _GetProp_PercentSymbol: String;
		procedure _SetProp_PercentSymbol(Value: String);
		function _GetProp_PerMilleSymbol: String;
		procedure _SetProp_PerMilleSymbol(Value: String);
		function _GetProp_PositiveInfinitySymbol: String;
		procedure _SetProp_PositiveInfinitySymbol(Value: String);
		function _GetProp_PositiveSign: String;
		procedure _SetProp_PositiveSign(Value: String);
	{ public }
		function Clone(): Variant;
		function GetFormat(formatType: IType): Variant;
		property CurrencyDecimalDigits: Integer read _GetProp_CurrencyDecimalDigits write _SetProp_CurrencyDecimalDigits;
		property CurrencyDecimalSeparator: String read _GetProp_CurrencyDecimalSeparator write _SetProp_CurrencyDecimalSeparator;
		property CurrencyGroupSeparator: String read _GetProp_CurrencyGroupSeparator write _SetProp_CurrencyGroupSeparator;
		property CurrencyGroupSizes: TArray<Integer> read _GetProp_CurrencyGroupSizes write _SetProp_CurrencyGroupSizes;
		property CurrencyNegativePattern: Integer read _GetProp_CurrencyNegativePattern write _SetProp_CurrencyNegativePattern;
		property CurrencyPositivePattern: Integer read _GetProp_CurrencyPositivePattern write _SetProp_CurrencyPositivePattern;
		property CurrencySymbol: String read _GetProp_CurrencySymbol write _SetProp_CurrencySymbol;
		property DigitSubstitution: TDigitShapes read _GetProp_DigitSubstitution write _SetProp_DigitSubstitution;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property NaNSymbol: String read _GetProp_NaNSymbol write _SetProp_NaNSymbol;
		property NativeDigits: TArray<String> read _GetProp_NativeDigits write _SetProp_NativeDigits;
		property NegativeInfinitySymbol: String read _GetProp_NegativeInfinitySymbol write _SetProp_NegativeInfinitySymbol;
		property NegativeSign: String read _GetProp_NegativeSign write _SetProp_NegativeSign;
		property NumberDecimalDigits: Integer read _GetProp_NumberDecimalDigits write _SetProp_NumberDecimalDigits;
		property NumberDecimalSeparator: String read _GetProp_NumberDecimalSeparator write _SetProp_NumberDecimalSeparator;
		property NumberGroupSeparator: String read _GetProp_NumberGroupSeparator write _SetProp_NumberGroupSeparator;
		property NumberGroupSizes: TArray<Integer> read _GetProp_NumberGroupSizes write _SetProp_NumberGroupSizes;
		property NumberNegativePattern: Integer read _GetProp_NumberNegativePattern write _SetProp_NumberNegativePattern;
		property PercentDecimalDigits: Integer read _GetProp_PercentDecimalDigits write _SetProp_PercentDecimalDigits;
		property PercentDecimalSeparator: String read _GetProp_PercentDecimalSeparator write _SetProp_PercentDecimalSeparator;
		property PercentGroupSeparator: String read _GetProp_PercentGroupSeparator write _SetProp_PercentGroupSeparator;
		property PercentGroupSizes: TArray<Integer> read _GetProp_PercentGroupSizes write _SetProp_PercentGroupSizes;
		property PercentNegativePattern: Integer read _GetProp_PercentNegativePattern write _SetProp_PercentNegativePattern;
		property PercentPositivePattern: Integer read _GetProp_PercentPositivePattern write _SetProp_PercentPositivePattern;
		property PercentSymbol: String read _GetProp_PercentSymbol write _SetProp_PercentSymbol;
		property PerMilleSymbol: String read _GetProp_PerMilleSymbol write _SetProp_PerMilleSymbol;
		property PositiveInfinitySymbol: String read _GetProp_PositiveInfinitySymbol write _SetProp_PositiveInfinitySymbol;
		property PositiveSign: String read _GetProp_PositiveSign write _SetProp_PositiveSign;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_OBFUSCATEASSEMBLYATTRIBUTE)]
	IObfuscateAssemblyAttribute = interface(IAttribute)
	['{AAC072B5-1E6F-41CF-A484-59A2F0537F50}']
	{ private }
		function _GetProp_AssemblyIsPrivate: Boolean;
		function _GetProp_StripAfterObfuscation: Boolean;
		procedure _SetProp_StripAfterObfuscation(Value: Boolean);
	{ public }
		property AssemblyIsPrivate: Boolean read _GetProp_AssemblyIsPrivate;
		property StripAfterObfuscation: Boolean read _GetProp_StripAfterObfuscation write _SetProp_StripAfterObfuscation;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_OBFUSCATIONATTRIBUTE)]
	IObfuscationAttribute = interface(IAttribute)
	['{983E603D-2E0C-4DE2-84A0-0EA40CE9C548}']
	{ private }
		function _GetProp_ApplyToMembers: Boolean;
		procedure _SetProp_ApplyToMembers(Value: Boolean);
		function _GetProp_Exclude: Boolean;
		procedure _SetProp_Exclude(Value: Boolean);
		function _GetProp_Feature: String;
		procedure _SetProp_Feature(Value: String);
		function _GetProp_StripAfterObfuscation: Boolean;
		procedure _SetProp_StripAfterObfuscation(Value: Boolean);
	{ public }
		property ApplyToMembers: Boolean read _GetProp_ApplyToMembers write _SetProp_ApplyToMembers;
		property Exclude: Boolean read _GetProp_Exclude write _SetProp_Exclude;
		property Feature: String read _GetProp_Feature write _SetProp_Feature;
		property StripAfterObfuscation: Boolean read _GetProp_StripAfterObfuscation write _SetProp_StripAfterObfuscation;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_OBJECTCOMPARER_1)]
	IObjectComparer<T> = interface(IComparer<T>)
	['{AAD8CED7-1994-496B-BE06-AFB4AF36F77C}']
	{ public }
		function Compare(x: T; y: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_OBJECTDISPOSEDEXCEPTION)]
	IObjectDisposedException = interface(IInvalidOperationException)
	['{1E9B5FFF-8385-4F4E-B26F-B478B26A65D3}']
	{ private }
		function _GetProp_Message: String;
		function _GetProp_ObjectName: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
		property ObjectName: String read _GetProp_ObjectName;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_OBJECTEQUALITYCOMPARER_1)]
	IObjectEqualityComparer<T> = interface(IEqualityComparer<T>)
	['{7F452FC5-A290-4CC8-AAC5-D4685E1ADBE2}']
	{ public }
		function Equals(x: T; y: T): Boolean;
		function GetHashCode(obj: T): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_REMOTING_OBJECTHANDLE)]
	IObjectHandle = interface(IMarshalByRefObject)
	['{735CB6C1-C371-43DA-8D97-A9E96FC48C94}']
	{ public }
		function Unwrap(): Variant;
	end;

	[CoreTypeSignature(SYSTEM_OBSOLETEATTRIBUTE)]
	IObsoleteAttribute = interface(IAttribute)
	['{26A5E9E0-02AD-4F3D-8D4D-DB6A7F917E4C}']
	{ private }
		function _GetProp_DiagnosticId: String;
		procedure _SetProp_DiagnosticId(Value: String);
		function _GetProp_IsError: Boolean;
		function _GetProp_Message: String;
		function _GetProp_UrlFormat: String;
		procedure _SetProp_UrlFormat(Value: String);
	{ public }
		property DiagnosticId: String read _GetProp_DiagnosticId write _SetProp_DiagnosticId;
		property IsError: Boolean read _GetProp_IsError;
		property Message: String read _GetProp_Message;
		property UrlFormat: String read _GetProp_UrlFormat write _SetProp_UrlFormat;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ONDESERIALIZEDATTRIBUTE)]
	IOnDeserializedAttribute = interface(IAttribute)
	['{E5875A25-0DCC-49F9-97F4-8EB5E061AAC0}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ONDESERIALIZINGATTRIBUTE)]
	IOnDeserializingAttribute = interface(IAttribute)
	['{C354F68F-B678-4052-8F57-84FE5D6E7105}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ONSERIALIZEDATTRIBUTE)]
	IOnSerializedAttribute = interface(IAttribute)
	['{9C1BD9D2-9B95-4C28-8738-AD9EF6EB47DD}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_ONSERIALIZINGATTRIBUTE)]
	IOnSerializingAttribute = interface(IAttribute)
	['{769F9217-7A9B-4279-8F11-85C4A7AD0241}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_OPCODE)]
	IOpCode = interface(IValueType)
	['{E120C917-3627-4832-A639-67D16CB18FF9}']
	{ private }
		function _GetProp_FlowControl: TFlowControl;
		function _GetProp_Name: String;
		function _GetProp_OpCodeType: TOpCodeType;
		function _GetProp_OperandType: TOperandType;
		function _GetProp_Size: Integer;
		function _GetProp_StackBehaviourPop: TStackBehaviour;
		function _GetProp_StackBehaviourPush: TStackBehaviour;
		function _GetProp_Value: SmallInt;
	{ public }
		function Equals(obj: IOpCode): Boolean;
		property FlowControl: TFlowControl read _GetProp_FlowControl;
		property Name: String read _GetProp_Name;
		property OpCodeType: TOpCodeType read _GetProp_OpCodeType;
		property OperandType: TOperandType read _GetProp_OperandType;
		property Size: Integer read _GetProp_Size;
		property StackBehaviourPop: TStackBehaviour read _GetProp_StackBehaviourPop;
		property StackBehaviourPush: TStackBehaviour read _GetProp_StackBehaviourPush;
		property Value: SmallInt read _GetProp_Value;
	end;

	IOpCodesClass = interface(ICoreClrClass)
	['{D87479AD-86D0-436F-82F3-896AC9FE48F0}']
	{ private }
		{ class } function _GetFld_Add: IOpCode;
		{ class } function _GetFld_Add_Ovf: IOpCode;
		{ class } function _GetFld_Add_Ovf_Un: IOpCode;
		{ class } function _GetFld_And: IOpCode;
		{ class } function _GetFld_Arglist: IOpCode;
		{ class } function _GetFld_Beq: IOpCode;
		{ class } function _GetFld_Beq_S: IOpCode;
		{ class } function _GetFld_Bge: IOpCode;
		{ class } function _GetFld_Bge_S: IOpCode;
		{ class } function _GetFld_Bge_Un: IOpCode;
		{ class } function _GetFld_Bge_Un_S: IOpCode;
		{ class } function _GetFld_Bgt: IOpCode;
		{ class } function _GetFld_Bgt_S: IOpCode;
		{ class } function _GetFld_Bgt_Un: IOpCode;
		{ class } function _GetFld_Bgt_Un_S: IOpCode;
		{ class } function _GetFld_Ble: IOpCode;
		{ class } function _GetFld_Ble_S: IOpCode;
		{ class } function _GetFld_Ble_Un: IOpCode;
		{ class } function _GetFld_Ble_Un_S: IOpCode;
		{ class } function _GetFld_Blt: IOpCode;
		{ class } function _GetFld_Blt_S: IOpCode;
		{ class } function _GetFld_Blt_Un: IOpCode;
		{ class } function _GetFld_Blt_Un_S: IOpCode;
		{ class } function _GetFld_Bne_Un: IOpCode;
		{ class } function _GetFld_Bne_Un_S: IOpCode;
		{ class } function _GetFld_Box: IOpCode;
		{ class } function _GetFld_Br: IOpCode;
		{ class } function _GetFld_Br_S: IOpCode;
		{ class } function _GetFld_Break: IOpCode;
		{ class } function _GetFld_Brfalse: IOpCode;
		{ class } function _GetFld_Brfalse_S: IOpCode;
		{ class } function _GetFld_Brtrue: IOpCode;
		{ class } function _GetFld_Brtrue_S: IOpCode;
		{ class } function _GetFld_Call: IOpCode;
		{ class } function _GetFld_Calli: IOpCode;
		{ class } function _GetFld_Callvirt: IOpCode;
		{ class } function _GetFld_Castclass: IOpCode;
		{ class } function _GetFld_Ceq: IOpCode;
		{ class } function _GetFld_Cgt: IOpCode;
		{ class } function _GetFld_Cgt_Un: IOpCode;
		{ class } function _GetFld_Ckfinite: IOpCode;
		{ class } function _GetFld_Clt: IOpCode;
		{ class } function _GetFld_Clt_Un: IOpCode;
		{ class } function _GetFld_Constrained: IOpCode;
		{ class } function _GetFld_Conv_I: IOpCode;
		{ class } function _GetFld_Conv_I1: IOpCode;
		{ class } function _GetFld_Conv_I2: IOpCode;
		{ class } function _GetFld_Conv_I4: IOpCode;
		{ class } function _GetFld_Conv_I8: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I1: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I1_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I2: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I2_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I4: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I4_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I8: IOpCode;
		{ class } function _GetFld_Conv_Ovf_I8_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U1: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U1_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U2: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U2_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U4: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U4_Un: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U8: IOpCode;
		{ class } function _GetFld_Conv_Ovf_U8_Un: IOpCode;
		{ class } function _GetFld_Conv_R_Un: IOpCode;
		{ class } function _GetFld_Conv_R4: IOpCode;
		{ class } function _GetFld_Conv_R8: IOpCode;
		{ class } function _GetFld_Conv_U: IOpCode;
		{ class } function _GetFld_Conv_U1: IOpCode;
		{ class } function _GetFld_Conv_U2: IOpCode;
		{ class } function _GetFld_Conv_U4: IOpCode;
		{ class } function _GetFld_Conv_U8: IOpCode;
		{ class } function _GetFld_Cpblk: IOpCode;
		{ class } function _GetFld_Cpobj: IOpCode;
		{ class } function _GetFld_Div: IOpCode;
		{ class } function _GetFld_Div_Un: IOpCode;
		{ class } function _GetFld_Dup: IOpCode;
		{ class } function _GetFld_Endfilter: IOpCode;
		{ class } function _GetFld_Endfinally: IOpCode;
		{ class } function _GetFld_Initblk: IOpCode;
		{ class } function _GetFld_Initobj: IOpCode;
		{ class } function _GetFld_Isinst: IOpCode;
		{ class } function _GetFld_Jmp: IOpCode;
		{ class } function _GetFld_Ldarg: IOpCode;
		{ class } function _GetFld_Ldarg_0: IOpCode;
		{ class } function _GetFld_Ldarg_1: IOpCode;
		{ class } function _GetFld_Ldarg_2: IOpCode;
		{ class } function _GetFld_Ldarg_3: IOpCode;
		{ class } function _GetFld_Ldarg_S: IOpCode;
		{ class } function _GetFld_Ldarga: IOpCode;
		{ class } function _GetFld_Ldarga_S: IOpCode;
		{ class } function _GetFld_Ldc_I4: IOpCode;
		{ class } function _GetFld_Ldc_I4_0: IOpCode;
		{ class } function _GetFld_Ldc_I4_1: IOpCode;
		{ class } function _GetFld_Ldc_I4_2: IOpCode;
		{ class } function _GetFld_Ldc_I4_3: IOpCode;
		{ class } function _GetFld_Ldc_I4_4: IOpCode;
		{ class } function _GetFld_Ldc_I4_5: IOpCode;
		{ class } function _GetFld_Ldc_I4_6: IOpCode;
		{ class } function _GetFld_Ldc_I4_7: IOpCode;
		{ class } function _GetFld_Ldc_I4_8: IOpCode;
		{ class } function _GetFld_Ldc_I4_M1: IOpCode;
		{ class } function _GetFld_Ldc_I4_S: IOpCode;
		{ class } function _GetFld_Ldc_I8: IOpCode;
		{ class } function _GetFld_Ldc_R4: IOpCode;
		{ class } function _GetFld_Ldc_R8: IOpCode;
		{ class } function _GetFld_Ldelem: IOpCode;
		{ class } function _GetFld_Ldelem_I: IOpCode;
		{ class } function _GetFld_Ldelem_I1: IOpCode;
		{ class } function _GetFld_Ldelem_I2: IOpCode;
		{ class } function _GetFld_Ldelem_I4: IOpCode;
		{ class } function _GetFld_Ldelem_I8: IOpCode;
		{ class } function _GetFld_Ldelem_R4: IOpCode;
		{ class } function _GetFld_Ldelem_R8: IOpCode;
		{ class } function _GetFld_Ldelem_Ref: IOpCode;
		{ class } function _GetFld_Ldelem_U1: IOpCode;
		{ class } function _GetFld_Ldelem_U2: IOpCode;
		{ class } function _GetFld_Ldelem_U4: IOpCode;
		{ class } function _GetFld_Ldelema: IOpCode;
		{ class } function _GetFld_Ldfld: IOpCode;
		{ class } function _GetFld_Ldflda: IOpCode;
		{ class } function _GetFld_Ldftn: IOpCode;
		{ class } function _GetFld_Ldind_I: IOpCode;
		{ class } function _GetFld_Ldind_I1: IOpCode;
		{ class } function _GetFld_Ldind_I2: IOpCode;
		{ class } function _GetFld_Ldind_I4: IOpCode;
		{ class } function _GetFld_Ldind_I8: IOpCode;
		{ class } function _GetFld_Ldind_R4: IOpCode;
		{ class } function _GetFld_Ldind_R8: IOpCode;
		{ class } function _GetFld_Ldind_Ref: IOpCode;
		{ class } function _GetFld_Ldind_U1: IOpCode;
		{ class } function _GetFld_Ldind_U2: IOpCode;
		{ class } function _GetFld_Ldind_U4: IOpCode;
		{ class } function _GetFld_Ldlen: IOpCode;
		{ class } function _GetFld_Ldloc: IOpCode;
		{ class } function _GetFld_Ldloc_0: IOpCode;
		{ class } function _GetFld_Ldloc_1: IOpCode;
		{ class } function _GetFld_Ldloc_2: IOpCode;
		{ class } function _GetFld_Ldloc_3: IOpCode;
		{ class } function _GetFld_Ldloc_S: IOpCode;
		{ class } function _GetFld_Ldloca: IOpCode;
		{ class } function _GetFld_Ldloca_S: IOpCode;
		{ class } function _GetFld_Ldnull: IOpCode;
		{ class } function _GetFld_Ldobj: IOpCode;
		{ class } function _GetFld_Ldsfld: IOpCode;
		{ class } function _GetFld_Ldsflda: IOpCode;
		{ class } function _GetFld_Ldstr: IOpCode;
		{ class } function _GetFld_Ldtoken: IOpCode;
		{ class } function _GetFld_Ldvirtftn: IOpCode;
		{ class } function _GetFld_Leave: IOpCode;
		{ class } function _GetFld_Leave_S: IOpCode;
		{ class } function _GetFld_Localloc: IOpCode;
		{ class } function _GetFld_Mkrefany: IOpCode;
		{ class } function _GetFld_Mul: IOpCode;
		{ class } function _GetFld_Mul_Ovf: IOpCode;
		{ class } function _GetFld_Mul_Ovf_Un: IOpCode;
		{ class } function _GetFld_Neg: IOpCode;
		{ class } function _GetFld_Newarr: IOpCode;
		{ class } function _GetFld_Newobj: IOpCode;
		{ class } function _GetFld_Nop: IOpCode;
		{ class } function _GetFld_Not: IOpCode;
		{ class } function _GetFld_Or: IOpCode;
		{ class } function _GetFld_Pop: IOpCode;
		{ class } function _GetFld_Prefix1: IOpCode;
		{ class } function _GetFld_Prefix2: IOpCode;
		{ class } function _GetFld_Prefix3: IOpCode;
		{ class } function _GetFld_Prefix4: IOpCode;
		{ class } function _GetFld_Prefix5: IOpCode;
		{ class } function _GetFld_Prefix6: IOpCode;
		{ class } function _GetFld_Prefix7: IOpCode;
		{ class } function _GetFld_Prefixref: IOpCode;
		{ class } function _GetFld_Readonly: IOpCode;
		{ class } function _GetFld_Refanytype: IOpCode;
		{ class } function _GetFld_Refanyval: IOpCode;
		{ class } function _GetFld_Rem: IOpCode;
		{ class } function _GetFld_Rem_Un: IOpCode;
		{ class } function _GetFld_Ret: IOpCode;
		{ class } function _GetFld_Rethrow: IOpCode;
		{ class } function _GetFld_Shl: IOpCode;
		{ class } function _GetFld_Shr: IOpCode;
		{ class } function _GetFld_Shr_Un: IOpCode;
		{ class } function _GetFld_Sizeof: IOpCode;
		{ class } function _GetFld_Starg: IOpCode;
		{ class } function _GetFld_Starg_S: IOpCode;
		{ class } function _GetFld_Stelem: IOpCode;
		{ class } function _GetFld_Stelem_I: IOpCode;
		{ class } function _GetFld_Stelem_I1: IOpCode;
		{ class } function _GetFld_Stelem_I2: IOpCode;
		{ class } function _GetFld_Stelem_I4: IOpCode;
		{ class } function _GetFld_Stelem_I8: IOpCode;
		{ class } function _GetFld_Stelem_R4: IOpCode;
		{ class } function _GetFld_Stelem_R8: IOpCode;
		{ class } function _GetFld_Stelem_Ref: IOpCode;
		{ class } function _GetFld_Stfld: IOpCode;
		{ class } function _GetFld_Stind_I: IOpCode;
		{ class } function _GetFld_Stind_I1: IOpCode;
		{ class } function _GetFld_Stind_I2: IOpCode;
		{ class } function _GetFld_Stind_I4: IOpCode;
		{ class } function _GetFld_Stind_I8: IOpCode;
		{ class } function _GetFld_Stind_R4: IOpCode;
		{ class } function _GetFld_Stind_R8: IOpCode;
		{ class } function _GetFld_Stind_Ref: IOpCode;
		{ class } function _GetFld_Stloc: IOpCode;
		{ class } function _GetFld_Stloc_0: IOpCode;
		{ class } function _GetFld_Stloc_1: IOpCode;
		{ class } function _GetFld_Stloc_2: IOpCode;
		{ class } function _GetFld_Stloc_3: IOpCode;
		{ class } function _GetFld_Stloc_S: IOpCode;
		{ class } function _GetFld_Stobj: IOpCode;
		{ class } function _GetFld_Stsfld: IOpCode;
		{ class } function _GetFld_Sub: IOpCode;
		{ class } function _GetFld_Sub_Ovf: IOpCode;
		{ class } function _GetFld_Sub_Ovf_Un: IOpCode;
		{ class } function _GetFld_Switch: IOpCode;
		{ class } function _GetFld_Tailcall: IOpCode;
		{ class } function _GetFld_Throw: IOpCode;
		{ class } function _GetFld_Unaligned: IOpCode;
		{ class } function _GetFld_Unbox: IOpCode;
		{ class } function _GetFld_Unbox_Any: IOpCode;
		{ class } function _GetFld_Volatile: IOpCode;
		{ class } function _GetFld_Xor: IOpCode;
	{ public }
		{ class } function TakesSingleByteArgument(inst: IOpCode): Boolean;
		{ class } property Add: IOpCode read _GetFld_Add;
		{ class } property Add_Ovf: IOpCode read _GetFld_Add_Ovf;
		{ class } property Add_Ovf_Un: IOpCode read _GetFld_Add_Ovf_Un;
		{ class } property &And: IOpCode read _GetFld_And;
		{ class } property Arglist: IOpCode read _GetFld_Arglist;
		{ class } property Beq: IOpCode read _GetFld_Beq;
		{ class } property Beq_S: IOpCode read _GetFld_Beq_S;
		{ class } property Bge: IOpCode read _GetFld_Bge;
		{ class } property Bge_S: IOpCode read _GetFld_Bge_S;
		{ class } property Bge_Un: IOpCode read _GetFld_Bge_Un;
		{ class } property Bge_Un_S: IOpCode read _GetFld_Bge_Un_S;
		{ class } property Bgt: IOpCode read _GetFld_Bgt;
		{ class } property Bgt_S: IOpCode read _GetFld_Bgt_S;
		{ class } property Bgt_Un: IOpCode read _GetFld_Bgt_Un;
		{ class } property Bgt_Un_S: IOpCode read _GetFld_Bgt_Un_S;
		{ class } property Ble: IOpCode read _GetFld_Ble;
		{ class } property Ble_S: IOpCode read _GetFld_Ble_S;
		{ class } property Ble_Un: IOpCode read _GetFld_Ble_Un;
		{ class } property Ble_Un_S: IOpCode read _GetFld_Ble_Un_S;
		{ class } property Blt: IOpCode read _GetFld_Blt;
		{ class } property Blt_S: IOpCode read _GetFld_Blt_S;
		{ class } property Blt_Un: IOpCode read _GetFld_Blt_Un;
		{ class } property Blt_Un_S: IOpCode read _GetFld_Blt_Un_S;
		{ class } property Bne_Un: IOpCode read _GetFld_Bne_Un;
		{ class } property Bne_Un_S: IOpCode read _GetFld_Bne_Un_S;
		{ class } property Box: IOpCode read _GetFld_Box;
		{ class } property Br: IOpCode read _GetFld_Br;
		{ class } property Br_S: IOpCode read _GetFld_Br_S;
		{ class } property &Break: IOpCode read _GetFld_Break;
		{ class } property Brfalse: IOpCode read _GetFld_Brfalse;
		{ class } property Brfalse_S: IOpCode read _GetFld_Brfalse_S;
		{ class } property Brtrue: IOpCode read _GetFld_Brtrue;
		{ class } property Brtrue_S: IOpCode read _GetFld_Brtrue_S;
		{ class } property Call: IOpCode read _GetFld_Call;
		{ class } property Calli: IOpCode read _GetFld_Calli;
		{ class } property Callvirt: IOpCode read _GetFld_Callvirt;
		{ class } property Castclass: IOpCode read _GetFld_Castclass;
		{ class } property Ceq: IOpCode read _GetFld_Ceq;
		{ class } property Cgt: IOpCode read _GetFld_Cgt;
		{ class } property Cgt_Un: IOpCode read _GetFld_Cgt_Un;
		{ class } property Ckfinite: IOpCode read _GetFld_Ckfinite;
		{ class } property Clt: IOpCode read _GetFld_Clt;
		{ class } property Clt_Un: IOpCode read _GetFld_Clt_Un;
		{ class } property Constrained: IOpCode read _GetFld_Constrained;
		{ class } property Conv_I: IOpCode read _GetFld_Conv_I;
		{ class } property Conv_I1: IOpCode read _GetFld_Conv_I1;
		{ class } property Conv_I2: IOpCode read _GetFld_Conv_I2;
		{ class } property Conv_I4: IOpCode read _GetFld_Conv_I4;
		{ class } property Conv_I8: IOpCode read _GetFld_Conv_I8;
		{ class } property Conv_Ovf_I: IOpCode read _GetFld_Conv_Ovf_I;
		{ class } property Conv_Ovf_I_Un: IOpCode read _GetFld_Conv_Ovf_I_Un;
		{ class } property Conv_Ovf_I1: IOpCode read _GetFld_Conv_Ovf_I1;
		{ class } property Conv_Ovf_I1_Un: IOpCode read _GetFld_Conv_Ovf_I1_Un;
		{ class } property Conv_Ovf_I2: IOpCode read _GetFld_Conv_Ovf_I2;
		{ class } property Conv_Ovf_I2_Un: IOpCode read _GetFld_Conv_Ovf_I2_Un;
		{ class } property Conv_Ovf_I4: IOpCode read _GetFld_Conv_Ovf_I4;
		{ class } property Conv_Ovf_I4_Un: IOpCode read _GetFld_Conv_Ovf_I4_Un;
		{ class } property Conv_Ovf_I8: IOpCode read _GetFld_Conv_Ovf_I8;
		{ class } property Conv_Ovf_I8_Un: IOpCode read _GetFld_Conv_Ovf_I8_Un;
		{ class } property Conv_Ovf_U: IOpCode read _GetFld_Conv_Ovf_U;
		{ class } property Conv_Ovf_U_Un: IOpCode read _GetFld_Conv_Ovf_U_Un;
		{ class } property Conv_Ovf_U1: IOpCode read _GetFld_Conv_Ovf_U1;
		{ class } property Conv_Ovf_U1_Un: IOpCode read _GetFld_Conv_Ovf_U1_Un;
		{ class } property Conv_Ovf_U2: IOpCode read _GetFld_Conv_Ovf_U2;
		{ class } property Conv_Ovf_U2_Un: IOpCode read _GetFld_Conv_Ovf_U2_Un;
		{ class } property Conv_Ovf_U4: IOpCode read _GetFld_Conv_Ovf_U4;
		{ class } property Conv_Ovf_U4_Un: IOpCode read _GetFld_Conv_Ovf_U4_Un;
		{ class } property Conv_Ovf_U8: IOpCode read _GetFld_Conv_Ovf_U8;
		{ class } property Conv_Ovf_U8_Un: IOpCode read _GetFld_Conv_Ovf_U8_Un;
		{ class } property Conv_R_Un: IOpCode read _GetFld_Conv_R_Un;
		{ class } property Conv_R4: IOpCode read _GetFld_Conv_R4;
		{ class } property Conv_R8: IOpCode read _GetFld_Conv_R8;
		{ class } property Conv_U: IOpCode read _GetFld_Conv_U;
		{ class } property Conv_U1: IOpCode read _GetFld_Conv_U1;
		{ class } property Conv_U2: IOpCode read _GetFld_Conv_U2;
		{ class } property Conv_U4: IOpCode read _GetFld_Conv_U4;
		{ class } property Conv_U8: IOpCode read _GetFld_Conv_U8;
		{ class } property Cpblk: IOpCode read _GetFld_Cpblk;
		{ class } property Cpobj: IOpCode read _GetFld_Cpobj;
		{ class } property &Div: IOpCode read _GetFld_Div;
		{ class } property Div_Un: IOpCode read _GetFld_Div_Un;
		{ class } property Dup: IOpCode read _GetFld_Dup;
		{ class } property Endfilter: IOpCode read _GetFld_Endfilter;
		{ class } property Endfinally: IOpCode read _GetFld_Endfinally;
		{ class } property Initblk: IOpCode read _GetFld_Initblk;
		{ class } property Initobj: IOpCode read _GetFld_Initobj;
		{ class } property Isinst: IOpCode read _GetFld_Isinst;
		{ class } property Jmp: IOpCode read _GetFld_Jmp;
		{ class } property Ldarg: IOpCode read _GetFld_Ldarg;
		{ class } property Ldarg_0: IOpCode read _GetFld_Ldarg_0;
		{ class } property Ldarg_1: IOpCode read _GetFld_Ldarg_1;
		{ class } property Ldarg_2: IOpCode read _GetFld_Ldarg_2;
		{ class } property Ldarg_3: IOpCode read _GetFld_Ldarg_3;
		{ class } property Ldarg_S: IOpCode read _GetFld_Ldarg_S;
		{ class } property Ldarga: IOpCode read _GetFld_Ldarga;
		{ class } property Ldarga_S: IOpCode read _GetFld_Ldarga_S;
		{ class } property Ldc_I4: IOpCode read _GetFld_Ldc_I4;
		{ class } property Ldc_I4_0: IOpCode read _GetFld_Ldc_I4_0;
		{ class } property Ldc_I4_1: IOpCode read _GetFld_Ldc_I4_1;
		{ class } property Ldc_I4_2: IOpCode read _GetFld_Ldc_I4_2;
		{ class } property Ldc_I4_3: IOpCode read _GetFld_Ldc_I4_3;
		{ class } property Ldc_I4_4: IOpCode read _GetFld_Ldc_I4_4;
		{ class } property Ldc_I4_5: IOpCode read _GetFld_Ldc_I4_5;
		{ class } property Ldc_I4_6: IOpCode read _GetFld_Ldc_I4_6;
		{ class } property Ldc_I4_7: IOpCode read _GetFld_Ldc_I4_7;
		{ class } property Ldc_I4_8: IOpCode read _GetFld_Ldc_I4_8;
		{ class } property Ldc_I4_M1: IOpCode read _GetFld_Ldc_I4_M1;
		{ class } property Ldc_I4_S: IOpCode read _GetFld_Ldc_I4_S;
		{ class } property Ldc_I8: IOpCode read _GetFld_Ldc_I8;
		{ class } property Ldc_R4: IOpCode read _GetFld_Ldc_R4;
		{ class } property Ldc_R8: IOpCode read _GetFld_Ldc_R8;
		{ class } property Ldelem: IOpCode read _GetFld_Ldelem;
		{ class } property Ldelem_I: IOpCode read _GetFld_Ldelem_I;
		{ class } property Ldelem_I1: IOpCode read _GetFld_Ldelem_I1;
		{ class } property Ldelem_I2: IOpCode read _GetFld_Ldelem_I2;
		{ class } property Ldelem_I4: IOpCode read _GetFld_Ldelem_I4;
		{ class } property Ldelem_I8: IOpCode read _GetFld_Ldelem_I8;
		{ class } property Ldelem_R4: IOpCode read _GetFld_Ldelem_R4;
		{ class } property Ldelem_R8: IOpCode read _GetFld_Ldelem_R8;
		{ class } property Ldelem_Ref: IOpCode read _GetFld_Ldelem_Ref;
		{ class } property Ldelem_U1: IOpCode read _GetFld_Ldelem_U1;
		{ class } property Ldelem_U2: IOpCode read _GetFld_Ldelem_U2;
		{ class } property Ldelem_U4: IOpCode read _GetFld_Ldelem_U4;
		{ class } property Ldelema: IOpCode read _GetFld_Ldelema;
		{ class } property Ldfld: IOpCode read _GetFld_Ldfld;
		{ class } property Ldflda: IOpCode read _GetFld_Ldflda;
		{ class } property Ldftn: IOpCode read _GetFld_Ldftn;
		{ class } property Ldind_I: IOpCode read _GetFld_Ldind_I;
		{ class } property Ldind_I1: IOpCode read _GetFld_Ldind_I1;
		{ class } property Ldind_I2: IOpCode read _GetFld_Ldind_I2;
		{ class } property Ldind_I4: IOpCode read _GetFld_Ldind_I4;
		{ class } property Ldind_I8: IOpCode read _GetFld_Ldind_I8;
		{ class } property Ldind_R4: IOpCode read _GetFld_Ldind_R4;
		{ class } property Ldind_R8: IOpCode read _GetFld_Ldind_R8;
		{ class } property Ldind_Ref: IOpCode read _GetFld_Ldind_Ref;
		{ class } property Ldind_U1: IOpCode read _GetFld_Ldind_U1;
		{ class } property Ldind_U2: IOpCode read _GetFld_Ldind_U2;
		{ class } property Ldind_U4: IOpCode read _GetFld_Ldind_U4;
		{ class } property Ldlen: IOpCode read _GetFld_Ldlen;
		{ class } property Ldloc: IOpCode read _GetFld_Ldloc;
		{ class } property Ldloc_0: IOpCode read _GetFld_Ldloc_0;
		{ class } property Ldloc_1: IOpCode read _GetFld_Ldloc_1;
		{ class } property Ldloc_2: IOpCode read _GetFld_Ldloc_2;
		{ class } property Ldloc_3: IOpCode read _GetFld_Ldloc_3;
		{ class } property Ldloc_S: IOpCode read _GetFld_Ldloc_S;
		{ class } property Ldloca: IOpCode read _GetFld_Ldloca;
		{ class } property Ldloca_S: IOpCode read _GetFld_Ldloca_S;
		{ class } property Ldnull: IOpCode read _GetFld_Ldnull;
		{ class } property Ldobj: IOpCode read _GetFld_Ldobj;
		{ class } property Ldsfld: IOpCode read _GetFld_Ldsfld;
		{ class } property Ldsflda: IOpCode read _GetFld_Ldsflda;
		{ class } property Ldstr: IOpCode read _GetFld_Ldstr;
		{ class } property Ldtoken: IOpCode read _GetFld_Ldtoken;
		{ class } property Ldvirtftn: IOpCode read _GetFld_Ldvirtftn;
		{ class } property Leave: IOpCode read _GetFld_Leave;
		{ class } property Leave_S: IOpCode read _GetFld_Leave_S;
		{ class } property Localloc: IOpCode read _GetFld_Localloc;
		{ class } property Mkrefany: IOpCode read _GetFld_Mkrefany;
		{ class } property Mul: IOpCode read _GetFld_Mul;
		{ class } property Mul_Ovf: IOpCode read _GetFld_Mul_Ovf;
		{ class } property Mul_Ovf_Un: IOpCode read _GetFld_Mul_Ovf_Un;
		{ class } property Neg: IOpCode read _GetFld_Neg;
		{ class } property Newarr: IOpCode read _GetFld_Newarr;
		{ class } property Newobj: IOpCode read _GetFld_Newobj;
		{ class } property Nop: IOpCode read _GetFld_Nop;
		{ class } property &Not: IOpCode read _GetFld_Not;
		{ class } property &Or: IOpCode read _GetFld_Or;
		{ class } property Pop: IOpCode read _GetFld_Pop;
		{ class } property Prefix1: IOpCode read _GetFld_Prefix1;
		{ class } property Prefix2: IOpCode read _GetFld_Prefix2;
		{ class } property Prefix3: IOpCode read _GetFld_Prefix3;
		{ class } property Prefix4: IOpCode read _GetFld_Prefix4;
		{ class } property Prefix5: IOpCode read _GetFld_Prefix5;
		{ class } property Prefix6: IOpCode read _GetFld_Prefix6;
		{ class } property Prefix7: IOpCode read _GetFld_Prefix7;
		{ class } property Prefixref: IOpCode read _GetFld_Prefixref;
		{ class } property &Readonly: IOpCode read _GetFld_Readonly;
		{ class } property Refanytype: IOpCode read _GetFld_Refanytype;
		{ class } property Refanyval: IOpCode read _GetFld_Refanyval;
		{ class } property Rem: IOpCode read _GetFld_Rem;
		{ class } property Rem_Un: IOpCode read _GetFld_Rem_Un;
		{ class } property Ret: IOpCode read _GetFld_Ret;
		{ class } property Rethrow: IOpCode read _GetFld_Rethrow;
		{ class } property &Shl: IOpCode read _GetFld_Shl;
		{ class } property &Shr: IOpCode read _GetFld_Shr;
		{ class } property Shr_Un: IOpCode read _GetFld_Shr_Un;
		{ class } property Sizeof: IOpCode read _GetFld_Sizeof;
		{ class } property Starg: IOpCode read _GetFld_Starg;
		{ class } property Starg_S: IOpCode read _GetFld_Starg_S;
		{ class } property Stelem: IOpCode read _GetFld_Stelem;
		{ class } property Stelem_I: IOpCode read _GetFld_Stelem_I;
		{ class } property Stelem_I1: IOpCode read _GetFld_Stelem_I1;
		{ class } property Stelem_I2: IOpCode read _GetFld_Stelem_I2;
		{ class } property Stelem_I4: IOpCode read _GetFld_Stelem_I4;
		{ class } property Stelem_I8: IOpCode read _GetFld_Stelem_I8;
		{ class } property Stelem_R4: IOpCode read _GetFld_Stelem_R4;
		{ class } property Stelem_R8: IOpCode read _GetFld_Stelem_R8;
		{ class } property Stelem_Ref: IOpCode read _GetFld_Stelem_Ref;
		{ class } property Stfld: IOpCode read _GetFld_Stfld;
		{ class } property Stind_I: IOpCode read _GetFld_Stind_I;
		{ class } property Stind_I1: IOpCode read _GetFld_Stind_I1;
		{ class } property Stind_I2: IOpCode read _GetFld_Stind_I2;
		{ class } property Stind_I4: IOpCode read _GetFld_Stind_I4;
		{ class } property Stind_I8: IOpCode read _GetFld_Stind_I8;
		{ class } property Stind_R4: IOpCode read _GetFld_Stind_R4;
		{ class } property Stind_R8: IOpCode read _GetFld_Stind_R8;
		{ class } property Stind_Ref: IOpCode read _GetFld_Stind_Ref;
		{ class } property Stloc: IOpCode read _GetFld_Stloc;
		{ class } property Stloc_0: IOpCode read _GetFld_Stloc_0;
		{ class } property Stloc_1: IOpCode read _GetFld_Stloc_1;
		{ class } property Stloc_2: IOpCode read _GetFld_Stloc_2;
		{ class } property Stloc_3: IOpCode read _GetFld_Stloc_3;
		{ class } property Stloc_S: IOpCode read _GetFld_Stloc_S;
		{ class } property Stobj: IOpCode read _GetFld_Stobj;
		{ class } property Stsfld: IOpCode read _GetFld_Stsfld;
		{ class } property Sub: IOpCode read _GetFld_Sub;
		{ class } property Sub_Ovf: IOpCode read _GetFld_Sub_Ovf;
		{ class } property Sub_Ovf_Un: IOpCode read _GetFld_Sub_Ovf_Un;
		{ class } property Switch: IOpCode read _GetFld_Switch;
		{ class } property Tailcall: IOpCode read _GetFld_Tailcall;
		{ class } property Throw: IOpCode read _GetFld_Throw;
		{ class } property Unaligned: IOpCode read _GetFld_Unaligned;
		{ class } property Unbox: IOpCode read _GetFld_Unbox;
		{ class } property Unbox_Any: IOpCode read _GetFld_Unbox_Any;
		{ class } property Volatile: IOpCode read _GetFld_Volatile;
		{ class } property &Xor: IOpCode read _GetFld_Xor;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_OPCODES)]
	IOpCodes = interface(IObject)
	['{4AA91F76-155C-4B8C-8EAD-0231E7EAB18C}']
	end;

	IOperatingSystemClass = interface(ICoreClrClass)
	['{09AD1B62-43B2-4DBA-B155-B26AD0E016B0}']
	{ public }
		{ class } function IsAndroid(): Boolean;
		{ class } function IsAndroidVersionAtLeast(major: Integer; minor: Integer; build: Integer; revision: Integer): Boolean;
		{ class } function IsBrowser(): Boolean;
		{ class } function IsFreeBSD(): Boolean;
		{ class } function IsFreeBSDVersionAtLeast(major: Integer; minor: Integer; build: Integer; revision: Integer): Boolean;
		{ class } function IsIOS(): Boolean;
		{ class } function IsIOSVersionAtLeast(major: Integer; minor: Integer; build: Integer): Boolean;
		{ class } function IsLinux(): Boolean;
		{ class } function IsMacOS(): Boolean;
		{ class } function IsMacOSVersionAtLeast(major: Integer; minor: Integer; build: Integer): Boolean;
		{ class } function IsOSPlatform(platform_: String): Boolean;
		{ class } function IsOSPlatformVersionAtLeast(platform_: String; major: Integer; minor: Integer; build: Integer; revision: Integer): Boolean;
		{ class } function IsTvOS(): Boolean;
		{ class } function IsTvOSVersionAtLeast(major: Integer; minor: Integer; build: Integer): Boolean;
		{ class } function IsWatchOS(): Boolean;
		{ class } function IsWatchOSVersionAtLeast(major: Integer; minor: Integer; build: Integer): Boolean;
		{ class } function IsWindows(): Boolean;
		{ class } function IsWindowsVersionAtLeast(major: Integer; minor: Integer; build: Integer; revision: Integer): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_OPERATINGSYSTEM)]
	IOperatingSystem = interface(IObject)
	['{AC3FDD28-33DC-497A-B69B-3FB1FD441AD3}']
	{ private }
		function _GetProp_Platform: TPlatformID;
		function _GetProp_ServicePack: String;
		function _GetProp_Version: IVersion;
		function _GetProp_VersionString: String;
	{ public }
		function Clone(): Variant;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property &Platform: TPlatformID read _GetProp_Platform;
		property ServicePack: String read _GetProp_ServicePack;
		property Version: IVersion read _GetProp_Version;
		property VersionString: String read _GetProp_VersionString;
	end;

	[CoreTypeSignature(SYSTEM_OPERATIONCANCELEDEXCEPTION)]
	IOperationCanceledException = interface(ISystemException)
	['{15668795-582D-4388-BF17-A1F9D72868FF}']
	{ private }
		function _GetProp_CancellationToken: ICancellationToken;
	{ public }
		property CancellationToken: ICancellationToken read _GetProp_CancellationToken;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_OPTIONALATTRIBUTE)]
	IOptionalAttribute = interface(IAttribute)
	['{06329F9A-8332-4B8B-A84D-84B4ADF774E5}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_OPTIONALFIELDATTRIBUTE)]
	IOptionalFieldAttribute = interface(IAttribute)
	['{0A5655C8-2546-4A89-80D1-84BDADFB011F}']
	{ private }
		function _GetProp_VersionAdded: Integer;
		procedure _SetProp_VersionAdded(Value: Integer);
	{ public }
		property VersionAdded: Integer read _GetProp_VersionAdded write _SetProp_VersionAdded;
	end;

	[CoreTypeSignature(SYSTEM_ORDINALCOMPARER)]
	IOrdinalComparer = interface(IStringComparer)
	['{2E8EEB95-D8E8-43FA-9BCB-F5355F8F6934}']
	{ public }
		function Compare(x: String; y: String): Integer;
		function Equals(x: String; y: String): Boolean;
		function GetHashCode(obj: String): Integer;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_OSPLATFORMATTRIBUTE)]
	IOSPlatformAttribute = interface(IAttribute)
	['{DCC64176-9611-4B3C-9299-500DB3876AA6}']
	{ private }
		function _GetProp_PlatformName: String;
	{ public }
		property PlatformName: String read _GetProp_PlatformName;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_OUTATTRIBUTE)]
	IOutAttribute = interface(IAttribute)
	['{22170C33-BC3D-4A7B-B8F2-BFF70ED8CDAC}']
	end;

	[CoreTypeSignature(SYSTEM_OVERFLOWEXCEPTION)]
	IOverflowException = interface(IArithmeticException)
	['{B8E1C9F4-84AF-4A77-B94C-CE6F0C5DF290}']
	end;

	IOverlappedClass = interface(ICoreClrClass)
	['{06CA807E-BD78-495F-8CC0-8ABF77EEF65D}']
	{ public }
		{ class } procedure Free(nativeOverlappedPtr: ICoreClrInstance);
		{ class } function Unpack(nativeOverlappedPtr: ICoreClrInstance): IOverlapped;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_OVERLAPPED)]
	IOverlapped = interface(IObject)
	['{DADEEA4A-181E-42C3-ACA0-B3D4888A1533}']
	{ private }
		function _GetProp_AsyncResult: IIAsyncResult;
		procedure _SetProp_AsyncResult(Value: IIAsyncResult);
		function _GetProp_EventHandle: Integer;
		procedure _SetProp_EventHandle(Value: Integer);
		function _GetProp_EventHandleIntPtr: IIntPtr;
		procedure _SetProp_EventHandleIntPtr(Value: IIntPtr);
		function _GetProp_OffsetHigh: Integer;
		procedure _SetProp_OffsetHigh(Value: Integer);
		function _GetProp_OffsetLow: Integer;
		procedure _SetProp_OffsetLow(Value: Integer);
	{ public }
		function Pack(iocb: TIOCompletionCallback): ICoreClrInstance; overload;
		function Pack(iocb: TIOCompletionCallback; userData: Variant): ICoreClrInstance; overload;
		function UnsafePack(iocb: TIOCompletionCallback): ICoreClrInstance; overload;
		function UnsafePack(iocb: TIOCompletionCallback; userData: Variant): ICoreClrInstance; overload;
		property AsyncResult: IIAsyncResult read _GetProp_AsyncResult write _SetProp_AsyncResult;
		property EventHandle: Integer read _GetProp_EventHandle write _SetProp_EventHandle;
		property EventHandleIntPtr: IIntPtr read _GetProp_EventHandleIntPtr write _SetProp_EventHandleIntPtr;
		property OffsetHigh: Integer read _GetProp_OffsetHigh write _SetProp_OffsetHigh;
		property OffsetLow: Integer read _GetProp_OffsetLow write _SetProp_OffsetLow;
	end;

	[CoreTypeSignature(SYSTEM_PARAMARRAYATTRIBUTE)]
	IParamArrayAttribute = interface(IAttribute)
	['{7D129DC5-43CE-4BDF-A73C-0519852046DB}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_PARAMDESC)]
	IPARAMDESC = interface(IValueType)
	['{B006C1F4-A6C6-4D8F-8480-D49F010B609D}']
	{ private }
		function _GetFld_lpVarValue: IIntPtr;
		procedure _SetFld_lpVarValue(Value: IIntPtr);
		function _GetFld_wParamFlags: TPARAMFLAG_Set;
		procedure _SetFld_wParamFlags(Value: TPARAMFLAG_Set);
	{ public }
		property lpVarValue: IIntPtr read _GetFld_lpVarValue write _SetFld_lpVarValue;
		property wParamFlags: TPARAMFLAG_Set read _GetFld_wParamFlags write _SetFld_wParamFlags;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_PARAMETERBUILDER)]
	IParameterBuilder = interface(IObject)
	['{8C191BD9-9FB1-4894-8140-64C00713D058}']
	{ private }
		function _GetProp_Attributes: Integer;
		function _GetProp_IsIn: Boolean;
		function _GetProp_IsOptional: Boolean;
		function _GetProp_IsOut: Boolean;
		function _GetProp_Name: String;
		function _GetProp_Position: Integer;
	{ public }
		function GetToken(): IParameterToken;
		procedure SetConstant(defaultValue: Variant);
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		property Attributes: Integer read _GetProp_Attributes;
		property IsIn: Boolean read _GetProp_IsIn;
		property IsOptional: Boolean read _GetProp_IsOptional;
		property IsOut: Boolean read _GetProp_IsOut;
		property Name: String read _GetProp_Name;
		property Position: Integer read _GetProp_Position;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_PARAMETERINFO)]
	IParameterInfo = interface(IObject)
	['{1938BC1B-8AAA-4AFC-B14F-1150878F77CF}']
	{ private }
		function _GetProp_Attributes: TParameterAttributes_Set;
		function _GetProp_CustomAttributes: IIEnumerable<ICustomAttributeData>;
		function _GetProp_DefaultValue: Variant;
		function _GetProp_HasDefaultValue: Boolean;
		function _GetProp_IsIn: Boolean;
		function _GetProp_IsLcid: Boolean;
		function _GetProp_IsOptional: Boolean;
		function _GetProp_IsOut: Boolean;
		function _GetProp_IsRetval: Boolean;
		function _GetProp_Member: IMemberInfo;
		function _GetProp_MetadataToken: Integer;
		function _GetProp_Name: String;
		function _GetProp_ParameterType: IType;
		function _GetProp_Position: Integer;
		function _GetProp_RawDefaultValue: Variant;
	{ public }
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributesData(): IIList<ICustomAttributeData>;
		function GetOptionalCustomModifiers(): TArray<IType>;
		function GetRealObject(context: IStreamingContext): Variant;
		function GetRequiredCustomModifiers(): TArray<IType>;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		property Attributes: TParameterAttributes_Set read _GetProp_Attributes;
		property CustomAttributes: IIEnumerable<ICustomAttributeData> read _GetProp_CustomAttributes;
		property DefaultValue: Variant read _GetProp_DefaultValue;
		property HasDefaultValue: Boolean read _GetProp_HasDefaultValue;
		property IsIn: Boolean read _GetProp_IsIn;
		property IsLcid: Boolean read _GetProp_IsLcid;
		property IsOptional: Boolean read _GetProp_IsOptional;
		property IsOut: Boolean read _GetProp_IsOut;
		property IsRetval: Boolean read _GetProp_IsRetval;
		property Member: IMemberInfo read _GetProp_Member;
		property MetadataToken: Integer read _GetProp_MetadataToken;
		property Name: String read _GetProp_Name;
		property ParameterType: IType read _GetProp_ParameterType;
		property Position: Integer read _GetProp_Position;
		property RawDefaultValue: Variant read _GetProp_RawDefaultValue;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_PARAMETERMODIFIER)]
	IParameterModifier = interface(IValueType)
	['{42BE8606-00A1-40B8-BC7F-F1D584F74A7E}']
	{ private }
		function _GetProp_Item(index: Integer): Boolean;
		procedure _SetProp_Item(index: Integer; Value: Boolean);
	{ public }
		property Item[index: Integer]: Boolean read _GetProp_Item write _SetProp_Item; default;
	end;

	IParameterTokenClass = interface(ICoreClrClass)
	['{49E95924-D7F6-4EBF-9294-F97FCEE938DB}']
	{ private }
		{ class } function _GetFld_Empty: IParameterToken;
	{ public }
		{ class } property Empty: IParameterToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_PARAMETERTOKEN)]
	IParameterToken = interface(IValueType)
	['{F6B10572-BE5C-45AC-99E8-DF51D3DEE86C}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IParameterToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	IPathClass = interface(ICoreClrClass)
	['{6741D9FB-391F-4541-B31F-BE7C1C22AFD9}']
	{ private }
		{ class } function _GetFld_AltDirectorySeparatorChar: Char;
		{ class } function _GetFld_DirectorySeparatorChar: Char;
		{ class } function _GetFld_InvalidPathChars: TArray<Char>;
		{ class } function _GetFld_PathSeparator: Char;
		{ class } function _GetFld_VolumeSeparatorChar: Char;
	{ public }
		{ class } function ChangeExtension(path: String; extension: String): String;
		{ class } function Combine(path1: String; path2: String): String; overload;
		{ class } function Combine(path1: String; path2: String; path3: String): String; overload;
		{ class } function Combine(path1: String; path2: String; path3: String; path4: String): String; overload;
		{ class } function Combine(paths: TArray<String>): String; overload;
		{ class } function EndsInDirectorySeparator(path: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function EndsInDirectorySeparator(path: String): Boolean; overload;
		{ class } function GetDirectoryName(path: String): String; overload;
		{ class } function GetDirectoryName(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function GetExtension(path: String): String; overload;
		{ class } function GetExtension(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function GetFileName(path: String): String; overload;
		{ class } function GetFileName(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function GetFileNameWithoutExtension(path: String): String; overload;
		{ class } function GetFileNameWithoutExtension(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function GetFullPath(path: String): String; overload;
		{ class } function GetFullPath(path: String; basePath: String): String; overload;
		{ class } function GetInvalidFileNameChars(): TArray<Char>;
		{ class } function GetInvalidPathChars(): TArray<Char>;
		{ class } function GetPathRoot(path: String): String; overload;
		{ class } function GetPathRoot(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function GetRandomFileName(): String;
		{ class } function GetRelativePath(relativeTo: String; path: String): String;
		{ class } function GetTempFileName(): String;
		{ class } function GetTempPath(): String;
		{ class } function HasExtension(path: String): Boolean; overload;
		{ class } function HasExtension(path: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function IsPathFullyQualified(path: String): Boolean; overload;
		{ class } function IsPathFullyQualified(path: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function IsPathRooted(path: String): Boolean; overload;
		{ class } function IsPathRooted(path: IReadOnlySpan<Char>): Boolean; overload;
		{ class } function Join(path1: IReadOnlySpan<Char>; path2: IReadOnlySpan<Char>): String; overload;
		{ class } function Join(path1: String; path2: String): String; overload;
		{ class } function Join(path1: IReadOnlySpan<Char>; path2: IReadOnlySpan<Char>; path3: IReadOnlySpan<Char>): String; overload;
		{ class } function Join(path1: String; path2: String; path3: String): String; overload;
		{ class } function Join(path1: IReadOnlySpan<Char>; path2: IReadOnlySpan<Char>; path3: IReadOnlySpan<Char>; path4: IReadOnlySpan<Char>): String; overload;
		{ class } function Join(path1: String; path2: String; path3: String; path4: String): String; overload;
		{ class } function Join(paths: TArray<String>): String; overload;
		{ class } function TrimEndingDirectorySeparator(path: String): String; overload;
		{ class } function TrimEndingDirectorySeparator(path: IReadOnlySpan<Char>): IReadOnlySpan<Char>; overload;
		{ class } function TryJoin(path1: IReadOnlySpan<Char>; path2: IReadOnlySpan<Char>; destination: ISpan<Char>; var charsWritten: Integer): Boolean; overload;
		{ class } function TryJoin(path1: IReadOnlySpan<Char>; path2: IReadOnlySpan<Char>; path3: IReadOnlySpan<Char>; destination: ISpan<Char>; var charsWritten: Integer): Boolean; overload;
		{ class } property AltDirectorySeparatorChar: Char read _GetFld_AltDirectorySeparatorChar;
		{ class } property DirectorySeparatorChar: Char read _GetFld_DirectorySeparatorChar;
		{ class } property InvalidPathChars: TArray<Char> read _GetFld_InvalidPathChars;
		{ class } property PathSeparator: Char read _GetFld_PathSeparator;
		{ class } property VolumeSeparatorChar: Char read _GetFld_VolumeSeparatorChar;
	end;

	[CoreTypeSignature(SYSTEM_IO_PATH)]
	IPath = interface(IObject)
	['{BEF426A9-D49C-4F0F-ACEB-00302B610E20}']
	end;

	[CoreTypeSignature(SYSTEM_IO_PATHTOOLONGEXCEPTION)]
	IPathTooLongException = interface(IIOException)
	['{055CA2D4-4693-44F9-A609-70438D1FC4DD}']
	end;

	IPclmulqdqClass = interface(ICoreClrClass)
	['{FFFB2E1A-DFA3-43ED-901E-7068C1C7733C}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function CarrylessMultiply(left: IVector128<Int64>; right: IVector128<Int64>; control: Byte): IVector128<Int64>; overload;
		{ class } function CarrylessMultiply(left: IVector128<UInt64>; right: IVector128<UInt64>; control: Byte): IVector128<UInt64>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_PCLMULQDQ)]
	IPclmulqdq = interface(ISse2)
	['{E87187AF-DDFA-43D6-945E-396103CB3F23}']
	end;

	IX64_7Class = interface(ICoreClrClass)
	['{232E5EA8-A2A6-4D02-86B3-E2A6204C7083}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_8)]
	IX64_7 = interface(IX64_10)
	['{87032E2C-0B8A-4AE1-914B-4933D3B01BF9}']
	end;

	IPermissionSetClass = interface(ICoreClrClass)
	['{934F2068-1D95-4B3F-BF11-33FA0E563766}']
	{ public }
		{ class } function ConvertPermissionSet(inFormat: String; inData: TArray<Byte>; outFormat: String): TArray<Byte>;
		{ class } procedure RevertAssert();
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PERMISSIONSET)]
	IPermissionSet = interface(IObject)
	['{E97F546D-E519-4E3A-B45E-D42D7E88BCE1}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsSynchronized: Boolean;
		function _GetProp_SyncRoot: Variant;
	{ public }
		function AddPermission(perm: IIPermission): IIPermission;
		procedure Assert();
		function ContainsNonCodeAccessPermissions(): Boolean;
		function Copy(): IPermissionSet;
		procedure CopyTo(array_: IArray; index: Integer);
		procedure Demand();
		procedure Deny();
		procedure FromXml(et: ISecurityElement);
		function GetEnumerator(): IIEnumerator;
		function GetPermission(permClass: IType): IIPermission;
		function Intersect(other: IPermissionSet): IPermissionSet;
		function IsEmpty(): Boolean;
		function IsSubsetOf(target: IPermissionSet): Boolean;
		function IsUnrestricted(): Boolean;
		procedure PermitOnly();
		function RemovePermission(permClass: IType): IIPermission;
		function SetPermission(perm: IIPermission): IIPermission;
		function ToXml(): ISecurityElement;
		function Union(other: IPermissionSet): IPermissionSet;
		property Count: Integer read _GetProp_Count;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsSynchronized: Boolean read _GetProp_IsSynchronized;
		property SyncRoot: Variant read _GetProp_SyncRoot;
	end;

	IPersianCalendarClass = interface(ICoreClrClass)
	['{844716C1-F05E-4DA1-8DB1-EE207E1E9B18}']
	{ private }
		{ class } function _GetFld_PersianEra: Integer;
	{ public }
		{ class } property PersianEra: Integer read _GetFld_PersianEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_PERSIANCALENDAR)]
	IPersianCalendar = interface(ICalendar)
	['{CF880A0A-5731-493A-AD00-EAAAA9E8DC81}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IPlaneClass = interface(ICoreClrClass)
	['{642573A5-1FBB-45E2-81EA-473939D4F77A}']
	{ public }
		{ class } function CreateFromVertices(point1: IVector3; point2: IVector3; point3: IVector3): IPlane;
		{ class } function Dot(plane: IPlane; value: IVector4): Single;
		{ class } function DotCoordinate(plane: IPlane; value: IVector3): Single;
		{ class } function DotNormal(plane: IPlane; value: IVector3): Single;
		{ class } function Normalize(value: IPlane): IPlane;
		{ class } function Transform(plane: IPlane; matrix: IMatrix4x4): IPlane; overload;
		{ class } function Transform(plane: IPlane; rotation: IQuaternion): IPlane; overload;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_PLANE)]
	IPlane = interface(IValueType)
	['{67A35618-AFF0-4080-9B8F-7955423EFEAF}']
	{ private }
		function _GetFld_D: Single;
		procedure _SetFld_D(Value: Single);
		function _GetFld_Normal: IVector3;
		procedure _SetFld_Normal(Value: IVector3);
	{ public }
		function Equals(other: IPlane): Boolean;
		property D: Single read _GetFld_D write _SetFld_D;
		property Normal: IVector3 read _GetFld_Normal write _SetFld_Normal;
	end;

	[CoreTypeSignature(SYSTEM_PLATFORMNOTSUPPORTEDEXCEPTION)]
	IPlatformNotSupportedException = interface(INotSupportedException)
	['{A0E832FB-C716-46C5-8AE5-2B1B94DF361F}']
	end;

	IPointerClass = interface(ICoreClrClass)
	['{FAD8DBE1-F446-43B0-90C8-3062285F51B1}']
	{ public }
		{ class } function Box(ptr: ICoreClrInstance; type_: IType): Variant;
		{ class } function Unbox(ptr: Variant): ICoreClrInstance;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_POINTER)]
	IPointer = interface(IISerializable)
	['{DE18539E-8A09-4E26-9003-AFEA6480D0F4}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_POLLINGCOUNTER)]
	IPollingCounter = interface(IDiagnosticCounter)
	['{A092B2B6-F7C6-4B77-B3E8-178C95861D05}']
	end;

	IPopcntClass = interface(ICoreClrClass)
	['{03F5A1AE-0B17-4C67-9D0F-9B757A0ACFEB}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function PopCount(value: longword): longword;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_POPCNT)]
	IPopcnt = interface(ISse42)
	['{B7C6573C-2E65-4936-90B3-C7801444622F}']
	end;

	IX64_8Class = interface(ICoreClrClass)
	['{370AA8BB-7C97-49DA-85CC-9E714125C22B}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function PopCount(value: UInt64): UInt64;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_X86_X64_9)]
	IX64_8 = interface(IX64_13)
	['{5D3FC24F-3964-4412-AED8-BF2E5FA4B6D6}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_PREALLOCATEDOVERLAPPED)]
	IPreAllocatedOverlapped = interface(IObject)
	['{1A074C07-495E-41E1-8A6C-998AED957722}']
	{ public }
		procedure Dispose();
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_CONSTRAINEDEXECUTION_PREPREPAREMETHODATTRIBUTE)]
	IPrePrepareMethodAttribute = interface(IAttribute)
	['{96F1B00F-1F4C-4BC7-A32F-871715C208A1}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_PRESERVEBASEOVERRIDESATTRIBUTE)]
	IPreserveBaseOverridesAttribute = interface(IAttribute)
	['{93576FD6-722A-423C-B5B9-B856BBEE5E88}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_PRESERVESIGATTRIBUTE)]
	IPreserveSigAttribute = interface(IAttribute)
	['{8EB0272C-4097-486B-871C-07FEC2D6CCA5}']
	end;

	IProfileOptimizationClass = interface(ICoreClrClass)
	['{EFDEE467-40CA-4B20-ADAA-A28F4B31223A}']
	{ public }
		{ class } procedure SetProfileRoot(directoryPath: String);
		{ class } procedure StartProfile(profile: String);
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_PROFILEOPTIMIZATION)]
	IProfileOptimization = interface(IObject)
	['{550693CC-0DBB-4996-AE71-D719D4E1749B}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_PROGIDATTRIBUTE)]
	IProgIdAttribute = interface(IAttribute)
	['{273C65C7-5829-4C50-8A9E-8439168CC239}']
	{ private }
		function _GetProp_Value: String;
	{ public }
		property Value: String read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_PROGRESS_1)]
	IProgress<T> = interface(IIProgress<T>)
	['{1BCD93A1-0608-4917-B555-26F6DD4ED132}']
	{ private }
		function _GetEvt_ProgressChanged: TEventHandler<T>;
		procedure _SetEvt_ProgressChanged(Value: TEventHandler<T>);
	{ public }
		property ProgressChanged: TEventHandler<T> read _GetEvt_ProgressChanged write _SetEvt_ProgressChanged;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_PROPERTYINFO)]
	IPropertyInfo = interface(IMemberInfo)
	['{305F1E54-5747-4BCE-9FDB-57F2C8233164}']
	{ private }
		function _GetProp_Attributes: TPropertyAttributes_Set;
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_GetMethod: IMethodInfo;
		function _GetProp_IsSpecialName: Boolean;
		function _GetProp_MemberType: TMemberTypes_Set;
		function _GetProp_PropertyType: IType;
		function _GetProp_SetMethod: IMethodInfo;
	{ public }
		function GetAccessors(): TArray<IMethodInfo>; overload;
		function GetAccessors(nonPublic: Boolean): TArray<IMethodInfo>; overload;
		function GetConstantValue(): Variant;
		function GetGetMethod(): IMethodInfo; overload;
		function GetGetMethod(nonPublic: Boolean): IMethodInfo; overload;
		function GetIndexParameters(): TArray<IParameterInfo>;
		function GetOptionalCustomModifiers(): TArray<IType>;
		function GetRawConstantValue(): Variant;
		function GetRequiredCustomModifiers(): TArray<IType>;
		function GetSetMethod(): IMethodInfo; overload;
		function GetSetMethod(nonPublic: Boolean): IMethodInfo; overload;
		function GetValue(obj: Variant): Variant; overload;
		function GetValue(obj: Variant; index: TArray<Variant>): Variant; overload;
		function GetValue(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; index: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		procedure SetValue(obj: Variant; value: Variant); overload;
		procedure SetValue(obj: Variant; value: Variant; index: TArray<Variant>); overload;
		procedure SetValue(obj: Variant; value: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; index: TArray<Variant>; culture: ICultureInfo); overload;
		property Attributes: TPropertyAttributes_Set read _GetProp_Attributes;
		property CanRead: Boolean read _GetProp_CanRead;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property GetMethod: IMethodInfo read _GetProp_GetMethod;
		property IsSpecialName: Boolean read _GetProp_IsSpecialName;
		property MemberType: TMemberTypes_Set read _GetProp_MemberType;
		property PropertyType: IType read _GetProp_PropertyType;
		property SetMethod: IMethodInfo read _GetProp_SetMethod;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_PROPERTYBUILDER)]
	IPropertyBuilder = interface(IPropertyInfo)
	['{A9B5EFF0-AF83-4A25-B4BE-E0B7A95AF16D}']
	{ private }
		function _GetProp_Attributes: TPropertyAttributes_Set;
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_DeclaringType: IType;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_PropertyToken: IPropertyToken;
		function _GetProp_PropertyType: IType;
		function _GetProp_ReflectedType: IType;
	{ public }
		procedure AddOtherMethod(mdBuilder: IMethodBuilder);
		function GetAccessors(nonPublic: Boolean): TArray<IMethodInfo>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetGetMethod(nonPublic: Boolean): IMethodInfo;
		function GetIndexParameters(): TArray<IParameterInfo>;
		function GetSetMethod(nonPublic: Boolean): IMethodInfo;
		function GetValue(obj: Variant; index: TArray<Variant>): Variant; overload;
		function GetValue(obj: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; index: TArray<Variant>; culture: ICultureInfo): Variant; overload;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		procedure SetConstant(defaultValue: Variant);
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetGetMethod(mdBuilder: IMethodBuilder);
		procedure SetSetMethod(mdBuilder: IMethodBuilder);
		procedure SetValue(obj: Variant; value: Variant; index: TArray<Variant>); overload;
		procedure SetValue(obj: Variant; value: Variant; invokeAttr: TBindingFlags_Set; binder: IBinder; index: TArray<Variant>; culture: ICultureInfo); overload;
		property Attributes: TPropertyAttributes_Set read _GetProp_Attributes;
		property CanRead: Boolean read _GetProp_CanRead;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property PropertyToken: IPropertyToken read _GetProp_PropertyToken;
		property PropertyType: IType read _GetProp_PropertyType;
		property ReflectedType: IType read _GetProp_ReflectedType;
	end;

	IPropertyTokenClass = interface(ICoreClrClass)
	['{4CF4A89E-32EF-4E7A-8E3B-C53535572E4B}']
	{ private }
		{ class } function _GetFld_Empty: IPropertyToken;
	{ public }
		{ class } property Empty: IPropertyToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_PROPERTYTOKEN)]
	IPropertyToken = interface(IValueType)
	['{01FF531E-92E4-45CB-A26C-675130CFC3CD}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IPropertyToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CONTRACTS_PUREATTRIBUTE)]
	IPureAttribute = interface(IAttribute)
	['{4B770267-B427-4936-99AC-30FFE0AE4C8F}']
	end;

	IQuaternionClass = interface(ICoreClrClass)
	['{94B8E16B-EFD7-4D3B-83EF-55A53DDF79B7}']
	{ private }
		{ class } function _GetProp_Identity: IQuaternion;
	{ public }
		{ class } function Add(value1: IQuaternion; value2: IQuaternion): IQuaternion;
		{ class } function Concatenate(value1: IQuaternion; value2: IQuaternion): IQuaternion;
		{ class } function Conjugate(value: IQuaternion): IQuaternion;
		{ class } function CreateFromAxisAngle(axis: IVector3; angle: Single): IQuaternion;
		{ class } function CreateFromRotationMatrix(matrix: IMatrix4x4): IQuaternion;
		{ class } function CreateFromYawPitchRoll(yaw: Single; pitch: Single; roll: Single): IQuaternion;
		{ class } function Divide(value1: IQuaternion; value2: IQuaternion): IQuaternion;
		{ class } function Dot(quaternion1: IQuaternion; quaternion2: IQuaternion): Single;
		{ class } function Inverse(value: IQuaternion): IQuaternion;
		{ class } function Lerp(quaternion1: IQuaternion; quaternion2: IQuaternion; amount: Single): IQuaternion;
		{ class } function Multiply(value1: IQuaternion; value2: IQuaternion): IQuaternion; overload;
		{ class } function Multiply(value1: IQuaternion; value2: Single): IQuaternion; overload;
		{ class } function Negate(value: IQuaternion): IQuaternion;
		{ class } function Normalize(value: IQuaternion): IQuaternion;
		{ class } function Slerp(quaternion1: IQuaternion; quaternion2: IQuaternion; amount: Single): IQuaternion;
		{ class } function Subtract(value1: IQuaternion; value2: IQuaternion): IQuaternion;
		{ class } property Identity: IQuaternion read _GetProp_Identity;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_QUATERNION)]
	IQuaternion = interface(IValueType)
	['{83B9F578-19D7-4AE7-8F5A-228E9DCDE390}']
	{ private }
		function _GetFld_W: Single;
		procedure _SetFld_W(Value: Single);
		function _GetFld_X: Single;
		procedure _SetFld_X(Value: Single);
		function _GetFld_Y: Single;
		procedure _SetFld_Y(Value: Single);
		function _GetFld_Z: Single;
		procedure _SetFld_Z(Value: Single);
		function _GetProp_IsIdentity: Boolean;
	{ public }
		function Equals(other: IQuaternion): Boolean;
		function Length(): Single;
		function LengthSquared(): Single;
		property W: Single read _GetFld_W write _SetFld_W;
		property X: Single read _GetFld_X write _SetFld_X;
		property Y: Single read _GetFld_Y write _SetFld_Y;
		property Z: Single read _GetFld_Z write _SetFld_Z;
		property IsIdentity: Boolean read _GetProp_IsIdentity;
	end;

	[CoreTypeSignature(SYSTEM_RANDOM)]
	IRandom = interface(IObject)
	['{AF40D46B-75F5-4C30-8865-F8A2D3521775}']
	{ public }
		function Next(): Integer; overload;
		function Next(minValue: Integer; maxValue: Integer): Integer; overload;
		function Next(maxValue: Integer): Integer; overload;
		procedure NextBytes(buffer: TArray<Byte>); overload;
		procedure NextBytes(buffer: ISpan<Byte>); overload;
		function NextDouble(): Double;
	end;

	IRangeClass = interface(ICoreClrClass)
	['{0F1A53CC-F213-4970-AC54-3040D555196B}']
	{ private }
		{ class } function _GetProp_All: IRange;
	{ public }
		{ class } function EndAt(end_: IIndex): IRange;
		{ class } function StartAt(start: IIndex): IRange;
		{ class } property All: IRange read _GetProp_All;
	end;

	[CoreTypeSignature(SYSTEM_RANGE)]
	IRange = interface(IValueType)
	['{809EC3EC-BBAE-49F4-AE1E-0DFF7136FE0E}']
	{ private }
		function _GetProp_End: IIndex;
		function _GetProp_Start: IIndex;
	{ public }
		function Equals(other: IRange): Boolean;
		function GetOffsetAndLength(length: Integer): IValueTuple<Integer, Integer>;
		property &End: IIndex read _GetProp_End;
		property Start: IIndex read _GetProp_Start;
	end;

	[CoreTypeSignature(SYSTEM_RANKEXCEPTION)]
	IRankException = interface(ISystemException)
	['{07740C77-D9DF-423A-B1FA-6FDFD6742CC2}']
	end;

	IRdmClass = interface(ICoreClrClass)
	['{2ED605B6-334D-4536-A883-4E7AC7C813A6}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function MultiplyRoundedDoublingAndAddSaturateHigh(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndAddSaturateHigh(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingAndAddSaturateHigh(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndAddSaturateHigh(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHigh(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHigh(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHigh(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingAndSubtractSaturateHigh(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(addend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<SmallInt>; left: IVector64<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector64<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector64<Integer>; left: IVector64<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector64<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector64<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector128<SmallInt>; left: IVector128<SmallInt>; right: IVector128<SmallInt>; rightIndex: Byte): IVector128<SmallInt>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector64<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } function MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(minuend: IVector128<Integer>; left: IVector128<Integer>; right: IVector128<Integer>; rightIndex: Byte): IVector128<Integer>; overload;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_RDM)]
	IRdm = interface(IAdvSimd)
	['{2D9DB391-B69A-4324-9D44-ED74D830267C}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_READERWRITERLOCKSLIM)]
	IReaderWriterLockSlim = interface(IIDisposable)
	['{22B10B6A-ABC5-49B3-8645-5951F8ED354A}']
	{ private }
		function _GetProp_CurrentReadCount: Integer;
		function _GetProp_IsReadLockHeld: Boolean;
		function _GetProp_IsUpgradeableReadLockHeld: Boolean;
		function _GetProp_IsWriteLockHeld: Boolean;
		function _GetProp_RecursionPolicy: TLockRecursionPolicy;
		function _GetProp_RecursiveReadCount: Integer;
		function _GetProp_RecursiveUpgradeCount: Integer;
		function _GetProp_RecursiveWriteCount: Integer;
		function _GetProp_WaitingReadCount: Integer;
		function _GetProp_WaitingUpgradeCount: Integer;
		function _GetProp_WaitingWriteCount: Integer;
	{ public }
		procedure Dispose();
		procedure EnterReadLock();
		procedure EnterUpgradeableReadLock();
		procedure EnterWriteLock();
		procedure ExitReadLock();
		procedure ExitUpgradeableReadLock();
		procedure ExitWriteLock();
		function TryEnterReadLock(timeout: ITimeSpan): Boolean; overload;
		function TryEnterReadLock(millisecondsTimeout: Integer): Boolean; overload;
		function TryEnterUpgradeableReadLock(timeout: ITimeSpan): Boolean; overload;
		function TryEnterUpgradeableReadLock(millisecondsTimeout: Integer): Boolean; overload;
		function TryEnterWriteLock(timeout: ITimeSpan): Boolean; overload;
		function TryEnterWriteLock(millisecondsTimeout: Integer): Boolean; overload;
		property CurrentReadCount: Integer read _GetProp_CurrentReadCount;
		property IsReadLockHeld: Boolean read _GetProp_IsReadLockHeld;
		property IsUpgradeableReadLockHeld: Boolean read _GetProp_IsUpgradeableReadLockHeld;
		property IsWriteLockHeld: Boolean read _GetProp_IsWriteLockHeld;
		property RecursionPolicy: TLockRecursionPolicy read _GetProp_RecursionPolicy;
		property RecursiveReadCount: Integer read _GetProp_RecursiveReadCount;
		property RecursiveUpgradeCount: Integer read _GetProp_RecursiveUpgradeCount;
		property RecursiveWriteCount: Integer read _GetProp_RecursiveWriteCount;
		property WaitingReadCount: Integer read _GetProp_WaitingReadCount;
		property WaitingUpgradeCount: Integer read _GetProp_WaitingUpgradeCount;
		property WaitingWriteCount: Integer read _GetProp_WaitingWriteCount;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1)]
	IReadOnlyCollection<T> = interface(IObject)
	['{E9ECA77C-02B4-4A98-903F-1EF1AD6984A7}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_Item(index: Integer): T;
	{ public }
		function Contains(value: T): Boolean;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; index: Integer);
		function GetEnumerator(): IIEnumerator<T>;
		function IndexOf(value: T): Integer;
		property Count: Integer read _GetProp_Count;
		property Item[index: Integer]: T read _GetProp_Item; default;
	end;

	IReadOnlyMemoryClass<T> = interface(ICoreClrClass)
	['{9D213907-B400-49D6-9CBD-FDF7EE0C8ADC}']
	{ private }
		{ class } function _GetProp_Empty: IReadOnlyMemory<T>;
	{ public }
		{ class } property Empty: IReadOnlyMemory<T> read _GetProp_Empty;
	end;

	[CoreTypeSignature(SYSTEM_READONLYMEMORY_1)]
	IReadOnlyMemory<T> = interface(IValueType)
	['{55AA47AB-E443-4FB7-8B82-74CBAA2F2A90}']
	{ private }
		function _GetProp_IsEmpty: Boolean;
		function _GetProp_Length: Integer;
		function _GetProp_Span: IReadOnlySpan<T>;
	{ public }
		procedure CopyTo(destination: IMemory<T>);
		function Equals(other: IReadOnlyMemory<T>): Boolean;
		function Pin(): IMemoryHandle;
		function Slice(start: Integer): IReadOnlyMemory<T>; overload;
		function Slice(start: Integer; length: Integer): IReadOnlyMemory<T>; overload;
		function ToArray(): TArray<T>;
		function TryCopyTo(destination: IMemory<T>): Boolean;
		property IsEmpty: Boolean read _GetProp_IsEmpty;
		property Length: Integer read _GetProp_Length;
		property Span: IReadOnlySpan<T> read _GetProp_Span;
	end;

	IReadOnlySpanClass<T> = interface(ICoreClrClass)
	['{B47A120B-238E-456D-89BE-48D9D0D4893C}']
	{ private }
		{ class } function _GetProp_Empty: IReadOnlySpan<T>;
	{ public }
		{ class } property Empty: IReadOnlySpan<T> read _GetProp_Empty;
	end;

	[CoreTypeSignature(SYSTEM_READONLYSPAN_1)]
	IReadOnlySpan<T> = interface(IValueType)
	['{B6427BE4-F724-4C99-9577-7F739EB6FB24}']
	{ private }
		function _GetProp_IsEmpty: Boolean;
		function _GetProp_Item(index: Integer): T;
		function _GetProp_Length: Integer;
	{ public }
		procedure CopyTo(destination: ISpan<T>);
		function GetEnumerator(): IReadOnlySpan_Enumerator<T>;
		function GetPinnableReference(): T;
		function Slice(start: Integer): IReadOnlySpan<T>; overload;
		function Slice(start: Integer; length: Integer): IReadOnlySpan<T>; overload;
		function ToArray(): TArray<T>;
		function TryCopyTo(destination: ISpan<T>): Boolean;
		property IsEmpty: Boolean read _GetProp_IsEmpty;
		property Item[index: Integer]: T read _GetProp_Item; default;
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_REFERENCEASSEMBLYATTRIBUTE)]
	IReferenceAssemblyAttribute = interface(IAttribute)
	['{0D0EDC72-FB38-4491-8F47-108A52A7E46A}']
	{ private }
		function _GetProp_Description: String;
	{ public }
		property Description: String read _GetProp_Description;
	end;

	IReferenceEqualityComparerClass = interface(ICoreClrClass)
	['{0F4A06DA-F03B-4EDA-9FC6-C95D19836255}']
	{ private }
		{ class } function _GetProp_Instance: IReferenceEqualityComparer;
	{ public }
		{ class } property Instance: IReferenceEqualityComparer read _GetProp_Instance;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_REFERENCEEQUALITYCOMPARER)]
	IReferenceEqualityComparer = interface(IObject)
	['{3D90EB50-0B06-45FB-8D53-B5951FA81D89}']
	{ public }
		function Equals(x: Variant; y: Variant): Boolean;
		function GetHashCode(obj: Variant): Integer;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_REFLECTIONCONTEXT)]
	IReflectionContext = interface(IObject)
	['{4B1A9F9C-CCC8-447B-801C-FD9A404A1D42}']
	{ public }
		function GetTypeForObject(value: Variant): ITypeInfo;
		function MapAssembly(assembly: IAssembly): IAssembly;
		function MapType(type_: ITypeInfo): ITypeInfo;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_REFLECTIONTYPELOADEXCEPTION)]
	IReflectionTypeLoadException = interface(ISystemException)
	['{07556A27-B350-4646-ACEB-74A025E8322E}']
	{ private }
		function _GetProp_LoaderExceptions: ICoreClrBridgeArray<IException>;
		function _GetProp_Message: String;
		function _GetProp_Types: ICoreClrBridgeArray<IType>;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property LoaderExceptions: ICoreClrBridgeArray<IException> read _GetProp_LoaderExceptions;
		property Message: String read _GetProp_Message;
		property Types: ICoreClrBridgeArray<IType> read _GetProp_Types;
	end;

	IRegionInfoClass = interface(ICoreClrClass)
	['{38CED2A9-85B8-4353-ACF8-49B14B6C3D48}']
	{ private }
		{ class } function _GetProp_CurrentRegion: IRegionInfo;
	{ public }
		{ class } property CurrentRegion: IRegionInfo read _GetProp_CurrentRegion;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_REGIONINFO)]
	IRegionInfo = interface(IObject)
	['{8BEE35B1-2E19-4E66-9B8F-23549E660DD8}']
	{ private }
		function _GetProp_CurrencyEnglishName: String;
		function _GetProp_CurrencyNativeName: String;
		function _GetProp_CurrencySymbol: String;
		function _GetProp_DisplayName: String;
		function _GetProp_EnglishName: String;
		function _GetProp_GeoId: Integer;
		function _GetProp_IsMetric: Boolean;
		function _GetProp_ISOCurrencySymbol: String;
		function _GetProp_Name: String;
		function _GetProp_NativeName: String;
		function _GetProp_ThreeLetterISORegionName: String;
		function _GetProp_ThreeLetterWindowsRegionName: String;
		function _GetProp_TwoLetterISORegionName: String;
	{ public }
		property CurrencyEnglishName: String read _GetProp_CurrencyEnglishName;
		property CurrencyNativeName: String read _GetProp_CurrencyNativeName;
		property CurrencySymbol: String read _GetProp_CurrencySymbol;
		property DisplayName: String read _GetProp_DisplayName;
		property EnglishName: String read _GetProp_EnglishName;
		property GeoId: Integer read _GetProp_GeoId;
		property IsMetric: Boolean read _GetProp_IsMetric;
		property ISOCurrencySymbol: String read _GetProp_ISOCurrencySymbol;
		property Name: String read _GetProp_Name;
		property NativeName: String read _GetProp_NativeName;
		property ThreeLetterISORegionName: String read _GetProp_ThreeLetterISORegionName;
		property ThreeLetterWindowsRegionName: String read _GetProp_ThreeLetterWindowsRegionName;
		property TwoLetterISORegionName: String read _GetProp_TwoLetterISORegionName;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_REGISTEREDWAITHANDLE)]
	IRegisteredWaitHandle = interface(IMarshalByRefObject)
	['{7C13E7CD-1FA0-4A39-8132-15944A922712}']
	{ public }
		function Unregister(waitObject: IWaitHandle): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_CONSTRAINEDEXECUTION_RELIABILITYCONTRACTATTRIBUTE)]
	IReliabilityContractAttribute = interface(IAttribute)
	['{6EB81047-93B6-40C5-98A3-6970931D8497}']
	{ private }
		function _GetProp_Cer: TCer;
		function _GetProp_ConsistencyGuarantee: TConsistency;
	{ public }
		property Cer: TCer read _GetProp_Cer;
		property ConsistencyGuarantee: TConsistency read _GetProp_ConsistencyGuarantee;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_REQUIRESUNREFERENCEDCODEATTRIBUTE)]
	IRequiresUnreferencedCodeAttribute = interface(IAttribute)
	['{1650623B-5421-4482-A9DD-FF2C62ACAC5D}']
	{ private }
		function _GetProp_Message: String;
		function _GetProp_Url: String;
		procedure _SetProp_Url(Value: String);
	{ public }
		property Message: String read _GetProp_Message;
		property Url: String read _GetProp_Url write _SetProp_Url;
	end;

	[CoreTypeSignature(SYSTEM_RESOLVEEVENTARGS)]
	IResolveEventArgs = interface(IEventArgs)
	['{B5BBB447-891F-41E5-B205-72B939CBEF88}']
	{ private }
		function _GetProp_Name: String;
		function _GetProp_RequestingAssembly: IAssembly;
	{ public }
		property Name: String read _GetProp_Name;
		property RequestingAssembly: IAssembly read _GetProp_RequestingAssembly;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_RESOURCECONSUMPTIONATTRIBUTE)]
	IResourceConsumptionAttribute = interface(IAttribute)
	['{904DC4EF-8B00-4875-AE9E-71BA52FC1978}']
	{ private }
		function _GetProp_ConsumptionScope: TResourceScope_Set;
		function _GetProp_ResourceScope: TResourceScope_Set;
	{ public }
		property ConsumptionScope: TResourceScope_Set read _GetProp_ConsumptionScope;
		property ResourceScope: TResourceScope_Set read _GetProp_ResourceScope;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_RESOURCEEXPOSUREATTRIBUTE)]
	IResourceExposureAttribute = interface(IAttribute)
	['{D02BCFF0-DD09-4311-B9A2-7D0032C407ED}']
	{ private }
		function _GetProp_ResourceExposureLevel: TResourceScope_Set;
	{ public }
		property ResourceExposureLevel: TResourceScope_Set read _GetProp_ResourceExposureLevel;
	end;

	IResourceManagerClass = interface(ICoreClrClass)
	['{8FB07D16-96FC-4280-AEAA-8D62B2BA3B54}']
	{ private }
		{ class } function _GetFld_HeaderVersionNumber: Integer;
		{ class } function _GetFld_MagicNumber: Integer;
	{ public }
		{ class } function CreateFileBasedResourceManager(baseName: String; resourceDir: String; usingResourceSet: IType): IResourceManager;
		{ class } property HeaderVersionNumber: Integer read _GetFld_HeaderVersionNumber;
		{ class } property MagicNumber: Integer read _GetFld_MagicNumber;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_RESOURCEMANAGER)]
	IResourceManager = interface(IObject)
	['{FABC84E7-8F7F-45E9-AFF4-087F055DCFF4}']
	{ private }
		function _GetProp_BaseName: String;
		function _GetProp_IgnoreCase: Boolean;
		procedure _SetProp_IgnoreCase(Value: Boolean);
		function _GetProp_ResourceSetType: IType;
	{ public }
		function GetObject(name: String): Variant; overload;
		function GetObject(name: String; culture: ICultureInfo): Variant; overload;
		function GetResourceSet(culture: ICultureInfo; createIfNotExists: Boolean; tryParents: Boolean): IResourceSet;
		function GetStream(name: String): IUnmanagedMemoryStream; overload;
		function GetStream(name: String; culture: ICultureInfo): IUnmanagedMemoryStream; overload;
		function GetString(name: String): String; overload;
		function GetString(name: String; culture: ICultureInfo): String; overload;
		procedure ReleaseAllResources();
		property BaseName: String read _GetProp_BaseName;
		property IgnoreCase: Boolean read _GetProp_IgnoreCase write _SetProp_IgnoreCase;
		property ResourceSetType: IType read _GetProp_ResourceSetType;
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_RESOURCEREADER)]
	IResourceReader = interface(IObject)
	['{43DD137F-DE5E-46E3-95D1-D2B985040663}']
	{ public }
		procedure Close();
		procedure Dispose();
		function GetEnumerator(): IIDictionaryEnumerator;
		procedure GetResourceData(resourceName: String; var resourceType: String; var resourceData: TArray<Byte>);
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_RESOURCESET)]
	IResourceSet = interface(IObject)
	['{E73F8B6B-9141-4DA8-82DF-BBC7C9ED2C0C}']
	{ public }
		procedure Close();
		procedure Dispose();
		function GetDefaultReader(): IType;
		function GetDefaultWriter(): IType;
		function GetEnumerator(): IIDictionaryEnumerator;
		function GetObject(name: String): Variant; overload;
		function GetObject(name: String; ignoreCase: Boolean): Variant; overload;
		function GetString(name: String): String; overload;
		function GetString(name: String; ignoreCase: Boolean): String; overload;
	end;

	IRuneClass = interface(ICoreClrClass)
	['{A63C1880-ED71-44A8-8768-1F427AB73A2A}']
	{ private }
		{ class } function _GetProp_ReplacementChar: IRune;
	{ public }
		{ class } function DecodeFromUtf16(source: IReadOnlySpan<Char>; var result_: IRune; var charsConsumed: Integer): TOperationStatus;
		{ class } function DecodeFromUtf8(source: IReadOnlySpan<Byte>; var result_: IRune; var bytesConsumed: Integer): TOperationStatus;
		{ class } function DecodeLastFromUtf16(source: IReadOnlySpan<Char>; var result_: IRune; var charsConsumed: Integer): TOperationStatus;
		{ class } function DecodeLastFromUtf8(source: IReadOnlySpan<Byte>; var value: IRune; var bytesConsumed: Integer): TOperationStatus;
		{ class } function GetNumericValue(value: IRune): Double;
		{ class } function GetRuneAt(input: String; index: Integer): IRune;
		{ class } function GetUnicodeCategory(value: IRune): TUnicodeCategory;
		{ class } function IsControl(value: IRune): Boolean;
		{ class } function IsDigit(value: IRune): Boolean;
		{ class } function IsLetter(value: IRune): Boolean;
		{ class } function IsLetterOrDigit(value: IRune): Boolean;
		{ class } function IsLower(value: IRune): Boolean;
		{ class } function IsNumber(value: IRune): Boolean;
		{ class } function IsPunctuation(value: IRune): Boolean;
		{ class } function IsSeparator(value: IRune): Boolean;
		{ class } function IsSymbol(value: IRune): Boolean;
		{ class } function IsUpper(value: IRune): Boolean;
		{ class } function IsValid(value: Integer): Boolean; overload;
		{ class } function IsValid(value: longword): Boolean; overload;
		{ class } function IsWhiteSpace(value: IRune): Boolean;
		{ class } function ToLower(value: IRune; culture: ICultureInfo): IRune;
		{ class } function ToLowerInvariant(value: IRune): IRune;
		{ class } function ToUpper(value: IRune; culture: ICultureInfo): IRune;
		{ class } function ToUpperInvariant(value: IRune): IRune;
		{ class } function TryCreate(ch: Char; var result_: IRune): Boolean; overload;
		{ class } function TryCreate(value: Integer; var result_: IRune): Boolean; overload;
		{ class } function TryCreate(value: longword; var result_: IRune): Boolean; overload;
		{ class } function TryCreate(highSurrogate: Char; lowSurrogate: Char; var result_: IRune): Boolean; overload;
		{ class } function TryGetRuneAt(input: String; index: Integer; var value: IRune): Boolean;
		{ class } property ReplacementChar: IRune read _GetProp_ReplacementChar;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_RUNE)]
	IRune = interface(IValueType)
	['{D2171DB4-772F-498B-A8EF-7131B950A777}']
	{ private }
		function _GetProp_IsAscii: Boolean;
		function _GetProp_IsBmp: Boolean;
		function _GetProp_Plane: Integer;
		function _GetProp_Utf16SequenceLength: Integer;
		function _GetProp_Utf8SequenceLength: Integer;
		function _GetProp_Value: Integer;
	{ public }
		function CompareTo(other: IRune): Integer;
		function EncodeToUtf16(destination: ISpan<Char>): Integer;
		function EncodeToUtf8(destination: ISpan<Byte>): Integer;
		function Equals(other: IRune): Boolean;
		function TryEncodeToUtf16(destination: ISpan<Char>; var charsWritten: Integer): Boolean;
		function TryEncodeToUtf8(destination: ISpan<Byte>; var bytesWritten: Integer): Boolean;
		property IsAscii: Boolean read _GetProp_IsAscii;
		property IsBmp: Boolean read _GetProp_IsBmp;
		property Plane: Integer read _GetProp_Plane;
		property Utf16SequenceLength: Integer read _GetProp_Utf16SequenceLength;
		property Utf8SequenceLength: Integer read _GetProp_Utf8SequenceLength;
		property Value: Integer read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIMEARGUMENTHANDLE)]
	IRuntimeArgumentHandle = interface(IValueType)
	['{2AE88883-7563-4EE2-89CA-BBBC7FF9676B}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_RUNTIMECOMPATIBILITYATTRIBUTE)]
	IRuntimeCompatibilityAttribute = interface(IAttribute)
	['{33C846BD-6EDD-43EC-9D34-47B9CDDDE393}']
	{ private }
		function _GetProp_WrapNonExceptionThrows: Boolean;
		procedure _SetProp_WrapNonExceptionThrows(Value: Boolean);
	{ public }
		property WrapNonExceptionThrows: Boolean read _GetProp_WrapNonExceptionThrows write _SetProp_WrapNonExceptionThrows;
	end;

	IRuntimeFeatureClass = interface(ICoreClrClass)
	['{12D9AC7F-1688-4213-B0ED-F79F845AD0E0}']
	{ private }
		{ class } function _GetFld_CovariantReturnsOfClasses: String;
		{ class } function _GetFld_DefaultImplementationsOfInterfaces: String;
		{ class } function _GetFld_PortablePdb: String;
		{ class } function _GetFld_UnmanagedSignatureCallingConvention: String;
		{ class } function _GetProp_IsDynamicCodeCompiled: Boolean;
		{ class } function _GetProp_IsDynamicCodeSupported: Boolean;
	{ public }
		{ class } function IsSupported(feature: String): Boolean;
		{ class } property CovariantReturnsOfClasses: String read _GetFld_CovariantReturnsOfClasses;
		{ class } property DefaultImplementationsOfInterfaces: String read _GetFld_DefaultImplementationsOfInterfaces;
		{ class } property PortablePdb: String read _GetFld_PortablePdb;
		{ class } property UnmanagedSignatureCallingConvention: String read _GetFld_UnmanagedSignatureCallingConvention;
		{ class } property IsDynamicCodeCompiled: Boolean read _GetProp_IsDynamicCodeCompiled;
		{ class } property IsDynamicCodeSupported: Boolean read _GetProp_IsDynamicCodeSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_RUNTIMEFEATURE)]
	IRuntimeFeature = interface(IObject)
	['{76E81375-C55B-415D-AD32-AB76996AC094}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIMEFIELDHANDLE)]
	IRuntimeFieldHandle = interface(IValueType)
	['{E52AFB23-C47B-4D41-96C1-70910F27FE90}']
	{ private }
		function _GetProp_Value: IIntPtr;
	{ public }
		function Equals(handle: IRuntimeFieldHandle): Boolean;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Value: IIntPtr read _GetProp_Value;
	end;

	IRuntimeHelpersClass = interface(ICoreClrClass)
	['{15E4DD37-1A07-480A-A911-0F2BD4121A22}']
	{ private }
		{ class } function _GetProp_OffsetToStringData: Integer;
	{ public }
		{ class } function AllocateTypeAssociatedMemory(type_: IType; size: Integer): IIntPtr;
		{ class } procedure EnsureSufficientExecutionStack();
		{ class } function Equals(o1: Variant; o2: Variant): Boolean;
		{ class } procedure ExecuteCodeWithGuaranteedCleanup(code: TTryCode; backoutCode: TCleanupCode; userData: Variant);
		{ class } function GetHashCode(o: Variant): Integer;
		{ class } function GetObjectValue(obj: Variant): Variant;
		{ class } function GetSubArray(T: PTypeInfo; array_: ICoreClrBridgeArray<Variant{T}>; range: IRange): ICoreClrBridgeArray<Variant{T}>;
		{ class } function GetUninitializedObject(type_: IType): Variant;
		{ class } procedure InitializeArray(array_: IArray; fldHandle: IRuntimeFieldHandle);
		{ class } function IsReferenceOrContainsReferences(T: PTypeInfo): Boolean;

		{ class } procedure PrepareConstrainedRegions();
		{ class } procedure PrepareConstrainedRegionsNoOP();
		{ class } procedure PrepareContractedDelegate(d: IDelegate);
		{ class } procedure PrepareDelegate(d: IDelegate);
		{ class } procedure PrepareMethod(method: IRuntimeMethodHandle); overload;
		{ class } procedure PrepareMethod(method: IRuntimeMethodHandle; instantiation: ICoreClrBridgeArray<IRuntimeTypeHandle>); overload;
		{ class } procedure ProbeForSufficientStack();
		{ class } procedure RunClassConstructor(type_: IRuntimeTypeHandle);
		{ class } procedure RunModuleConstructor(module: IModuleHandle);
		{ class } function TryEnsureSufficientExecutionStack(): Boolean;
		{ class } property OffsetToStringData: Integer read _GetProp_OffsetToStringData;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_RUNTIMEHELPERS)]
	IRuntimeHelpers = interface(IObject)
	['{CBD22895-BAE3-4619-B916-D24EFFE68667}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIMEMETHODHANDLE)]
	IRuntimeMethodHandle = interface(IValueType)
	['{423C5707-870B-4CB4-B55B-453C74157837}']
	{ private }
		function _GetProp_Value: IIntPtr;
	{ public }
		function Equals(handle: IRuntimeMethodHandle): Boolean;
		function GetFunctionPointer(): IIntPtr;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Value: IIntPtr read _GetProp_Value;
	end;

	IRuntimeReflectionExtensionsClass = interface(ICoreClrClass)
	['{5F6FB3E6-CC91-435B-8DBE-8A47085F4ADB}']
	{ public }
		{ class } function &GetMethodInfo(del: IDelegate): IMethodInfo;
		{ class } function GetRuntimeBaseDefinition(method: IMethodInfo): IMethodInfo;
		{ class } function GetRuntimeEvent(type_: IType; name: String): IEventInfo;
		{ class } function GetRuntimeEvents(type_: IType): IIEnumerable<IEventInfo>;
		{ class } function GetRuntimeField(type_: IType; name: String): IFieldInfo;
		{ class } function GetRuntimeFields(type_: IType): IIEnumerable<IFieldInfo>;
		{ class } function GetRuntimeInterfaceMap(typeInfo: ITypeInfo; interfaceType: IType): IInterfaceMapping;
		{ class } function GetRuntimeMethod(type_: IType; name: String; parameters: ICoreClrBridgeArray<IType>): IMethodInfo;
		{ class } function GetRuntimeMethods(type_: IType): IIEnumerable<IMethodInfo>;
		{ class } function GetRuntimeProperties(type_: IType): IIEnumerable<IPropertyInfo>;
		{ class } function GetRuntimeProperty(type_: IType; name: String): IPropertyInfo;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_RUNTIMEREFLECTIONEXTENSIONS)]
	IRuntimeReflectionExtensions = interface(IObject)
	['{A91015FB-9F13-4904-909F-62DEBC6F7AB1}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIMETYPEHANDLE)]
	IRuntimeTypeHandle = interface(IValueType)
	['{D3A6929A-512D-4310-B17C-8F6B7A97046F}']
	{ private }
		function _GetProp_Value: IIntPtr;
	{ public }
		function Equals(handle: IRuntimeTypeHandle): Boolean;
		function GetModuleHandle(): IModuleHandle;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Value: IIntPtr read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_RUNTIMEWRAPPEDEXCEPTION)]
	IRuntimeWrappedException = interface(IException)
	['{ECA6E36B-ECDF-46FF-9F2B-593C6F9C72B1}']
	{ private }
		function _GetProp_WrappedException: Variant;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property WrappedException: Variant read _GetProp_WrappedException;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SAFEARRAYRANKMISMATCHEXCEPTION)]
	ISafeArrayRankMismatchException = interface(ISystemException)
	['{F8300E8F-F0ED-44D9-BC03-74128FEC0115}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SAFEARRAYTYPEMISMATCHEXCEPTION)]
	ISafeArrayTypeMismatchException = interface(ISystemException)
	['{5AC075DF-50DF-40F7-8DE7-8611BEB75D65}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SAFEHANDLE)]
	ISafeHandle = interface(ICriticalFinalizerObject)
	['{065B9B7A-30C9-4C26-B778-E6177C4B4384}']
	{ private }
		function _GetProp_IsClosed: Boolean;
		function _GetProp_IsInvalid: Boolean;
	{ public }
		procedure Close();
		procedure DangerousAddRef(var success: Boolean);
		function DangerousGetHandle(): IIntPtr;
		procedure DangerousRelease();
		procedure Dispose();
		procedure SetHandleAsInvalid();
		property IsClosed: Boolean read _GetProp_IsClosed;
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_SAFEHANDLEZEROORMINUSONEISINVALID)]
	ISafeHandleZeroOrMinusOneIsInvalid = interface(ISafeHandle)
	['{E013373C-ACDD-4359-9328-6D3C5416B017}']
	{ private }
		function _GetProp_IsInvalid: Boolean;
	{ public }
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SAFEBUFFER)]
	ISafeBuffer = interface(ISafeHandleZeroOrMinusOneIsInvalid)
	['{204BD054-3983-4B90-8506-057EFFDB3B74}']
	{ private }
		function _GetProp_ByteLength: UInt64;
	{ public }
		procedure AcquirePointer(var pointer: ICoreClrInstance);
		procedure Initialize(numBytes: UInt64); overload;
		procedure Initialize(T: PTypeInfo; numElements: longword); overload;
		procedure Initialize(numElements: longword; sizeOfEachElement: longword); overload;
		function Read(T: PTypeInfo; byteOffset: UInt64): Variant{T};
		procedure ReadArray(T: PTypeInfo; byteOffset: UInt64; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; count: Integer);
		procedure ReleasePointer();
		procedure Write(T: PTypeInfo; byteOffset: UInt64; value: Variant{T});
		procedure WriteArray(T: PTypeInfo; byteOffset: UInt64; array_: ICoreClrBridgeArray<Variant{T}>; index: Integer; count: Integer);
		property ByteLength: UInt64 read _GetProp_ByteLength;
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_SAFEFILEHANDLE)]
	ISafeFileHandle = interface(ISafeHandleZeroOrMinusOneIsInvalid)
	['{F75C1247-C80A-492D-BE3A-93614B82153B}']
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_SAFEHANDLEMINUSONEISINVALID)]
	ISafeHandleMinusOneIsInvalid = interface(ISafeHandle)
	['{560610CA-26C1-4A07-8767-0820431E47DB}']
	{ private }
		function _GetProp_IsInvalid: Boolean;
	{ public }
		property IsInvalid: Boolean read _GetProp_IsInvalid;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_SAFESERIALIZATIONEVENTARGS)]
	ISafeSerializationEventArgs = interface(IEventArgs)
	['{463D7464-7A0E-4D22-9DEE-8880EB670E01}']
	{ private }
		function _GetProp_StreamingContext: IStreamingContext;
	{ public }
		procedure AddSerializedState(serializedState: IISafeSerializationData);
		property StreamingContext: IStreamingContext read _GetProp_StreamingContext;
	end;

	[CoreTypeSignature(MICROSOFT_WIN32_SAFEHANDLES_SAFEWAITHANDLE)]
	ISafeWaitHandle = interface(ISafeHandleZeroOrMinusOneIsInvalid)
	['{CC0D4E28-AC83-4434-BB19-365768670365}']
	end;

	[CoreTypeSignature(SYSTEM_RESOURCES_SATELLITECONTRACTVERSIONATTRIBUTE)]
	ISatelliteContractVersionAttribute = interface(IAttribute)
	['{193749AA-D5CE-438B-9503-233B0BAB0D96}']
	{ private }
		function _GetProp_Version: String;
	{ public }
		property Version: String read _GetProp_Version;
	end;

	ISByteClass = interface(ICoreClrClass)
	['{355D10BC-6DE6-4C15-A0FD-84A6C472420F}']
	{ private }
		{ class } function _GetFld_MaxValue: Shortint;
		{ class } function _GetFld_MinValue: Shortint;
	{ public }
		{ class } function Parse(s: String): Shortint; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Shortint; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Shortint; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Shortint; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Shortint; overload;
		{ class } function TryParse(s: String; var result_: Shortint): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Shortint): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Shortint): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Shortint): Boolean; overload;
		{ class } property MaxValue: Shortint read _GetFld_MaxValue;
		{ class } property MinValue: Shortint read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_SBYTE)]
	ISByte = interface(IValueType)
	['{785F39EB-846F-423C-A7ED-472E12DCFDBE}']
	{ public }
		function CompareTo(obj: Variant): Integer; overload;
		function CompareTo(value: Shortint): Integer; overload;
		function Equals(obj: Shortint): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_SCALAR)]
	IScalar = interface(IValueType)
	['{8336D24D-9708-4602-BC47-1D6BAC793471}']
	{ private }
		function _GetFld_AsBoolean: Boolean;
		procedure _SetFld_AsBoolean(Value: Boolean);
		function _GetFld_AsByte: Byte;
		procedure _SetFld_AsByte(Value: Byte);
		function _GetFld_AsChar: Char;
		procedure _SetFld_AsChar(Value: Char);
		function _GetFld_AsDateTime: TDateTime;
		procedure _SetFld_AsDateTime(Value: TDateTime);
		function _GetFld_AsDateTimeOffset: IDateTimeOffset;
		procedure _SetFld_AsDateTimeOffset(Value: IDateTimeOffset);
		function _GetFld_AsDecimal: IDecimal;
		procedure _SetFld_AsDecimal(Value: IDecimal);
		function _GetFld_AsDouble: Double;
		procedure _SetFld_AsDouble(Value: Double);
		function _GetFld_AsGuid: IGuid;
		procedure _SetFld_AsGuid(Value: IGuid);
		function _GetFld_AsInt16: SmallInt;
		procedure _SetFld_AsInt16(Value: SmallInt);
		function _GetFld_AsInt32: Integer;
		procedure _SetFld_AsInt32(Value: Integer);
		function _GetFld_AsInt64: Int64;
		procedure _SetFld_AsInt64(Value: Int64);
		function _GetFld_AsIntPtr: IIntPtr;
		procedure _SetFld_AsIntPtr(Value: IIntPtr);
		function _GetFld_AsSByte: Shortint;
		procedure _SetFld_AsSByte(Value: Shortint);
		function _GetFld_AsSingle: Single;
		procedure _SetFld_AsSingle(Value: Single);
		function _GetFld_AsTimeSpan: ITimeSpan;
		procedure _SetFld_AsTimeSpan(Value: ITimeSpan);
		function _GetFld_AsUInt16: Word;
		procedure _SetFld_AsUInt16(Value: Word);
		function _GetFld_AsUInt32: longword;
		procedure _SetFld_AsUInt32(Value: longword);
		function _GetFld_AsUInt64: UInt64;
		procedure _SetFld_AsUInt64(Value: UInt64);
		function _GetFld_AsUIntPtr: IUIntPtr;
		procedure _SetFld_AsUIntPtr(Value: IUIntPtr);
	{ public }
		property AsBoolean: Boolean read _GetFld_AsBoolean write _SetFld_AsBoolean;
		property AsByte: Byte read _GetFld_AsByte write _SetFld_AsByte;
		property AsChar: Char read _GetFld_AsChar write _SetFld_AsChar;
		property AsDateTime: TDateTime read _GetFld_AsDateTime write _SetFld_AsDateTime;
		property AsDateTimeOffset: IDateTimeOffset read _GetFld_AsDateTimeOffset write _SetFld_AsDateTimeOffset;
		property AsDecimal: IDecimal read _GetFld_AsDecimal write _SetFld_AsDecimal;
		property AsDouble: Double read _GetFld_AsDouble write _SetFld_AsDouble;
		property AsGuid: IGuid read _GetFld_AsGuid write _SetFld_AsGuid;
		property AsInt16: SmallInt read _GetFld_AsInt16 write _SetFld_AsInt16;
		property AsInt32: Integer read _GetFld_AsInt32 write _SetFld_AsInt32;
		property AsInt64: Int64 read _GetFld_AsInt64 write _SetFld_AsInt64;
		property AsIntPtr: IIntPtr read _GetFld_AsIntPtr write _SetFld_AsIntPtr;
		property AsSByte: Shortint read _GetFld_AsSByte write _SetFld_AsSByte;
		property AsSingle: Single read _GetFld_AsSingle write _SetFld_AsSingle;
		property AsTimeSpan: ITimeSpan read _GetFld_AsTimeSpan write _SetFld_AsTimeSpan;
		property AsUInt16: Word read _GetFld_AsUInt16 write _SetFld_AsUInt16;
		property AsUInt32: longword read _GetFld_AsUInt32 write _SetFld_AsUInt32;
		property AsUInt64: UInt64 read _GetFld_AsUInt64 write _SetFld_AsUInt64;
		property AsUIntPtr: IUIntPtr read _GetFld_AsUIntPtr write _SetFld_AsUIntPtr;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURESTRING)]
	ISecureString = interface(IIDisposable)
	['{1AC4D54E-373E-49AB-BAAD-A4A9491963FA}']
	{ private }
		function _GetProp_Length: Integer;
	{ public }
		procedure AppendChar(c: Char);
		procedure Clear();
		function Copy(): ISecureString;
		procedure Dispose();
		procedure InsertAt(index: Integer; c: Char);
		function IsReadOnly(): Boolean;
		procedure MakeReadOnly();
		procedure RemoveAt(index: Integer);
		procedure SetAt(index: Integer; c: Char);
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYCRITICALATTRIBUTE)]
	ISecurityCriticalAttribute = interface(IAttribute)
	['{104435A6-7C95-4ABA-A0BB-97BF59F8BC5E}']
	{ private }
		function _GetProp_Scope: TSecurityCriticalScope;
	{ public }
		property Scope: TSecurityCriticalScope read _GetProp_Scope;
	end;

	ISecurityElementClass = interface(ICoreClrClass)
	['{0523B7F9-740F-4D5F-B192-36BF29CC1CD0}']
	{ public }
		{ class } function Escape(str: String): String;
		{ class } function FromString(xml: String): ISecurityElement;
		{ class } function IsValidAttributeName(name: String): Boolean;
		{ class } function IsValidAttributeValue(value: String): Boolean;
		{ class } function IsValidTag(tag: String): Boolean;
		{ class } function IsValidText(text: String): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYELEMENT)]
	ISecurityElement = interface(IObject)
	['{1CD94C5B-9212-459C-BD82-7DECEAB8F065}']
	{ private }
		function _GetProp_Attributes: IHashtable;
		procedure _SetProp_Attributes(Value: IHashtable);
		function _GetProp_Children: IArrayList;
		procedure _SetProp_Children(Value: IArrayList);
		function _GetProp_Tag: String;
		procedure _SetProp_Tag(Value: String);
		function _GetProp_Text: String;
		procedure _SetProp_Text(Value: String);
	{ public }
		procedure AddAttribute(name: String; value: String);
		procedure AddChild(child: ISecurityElement);
		function Attribute(name: String): String;
		function Copy(): ISecurityElement;
		function Equal(other: ISecurityElement): Boolean;
		function SearchForChildByTag(tag: String): ISecurityElement;
		function SearchForTextOfTag(tag: String): String;
		property Attributes: IHashtable read _GetProp_Attributes write _SetProp_Attributes;
		property Children: IArrayList read _GetProp_Children write _SetProp_Children;
		property Tag: String read _GetProp_Tag write _SetProp_Tag;
		property Text: String read _GetProp_Text write _SetProp_Text;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYEXCEPTION)]
	ISecurityException = interface(ISystemException)
	['{DEB3D9B8-E5CF-48A4-BDBC-2C2C39CF3490}']
	{ private }
		function _GetProp_Demanded: Variant;
		procedure _SetProp_Demanded(Value: Variant);
		function _GetProp_DenySetInstance: Variant;
		procedure _SetProp_DenySetInstance(Value: Variant);
		function _GetProp_FailedAssemblyInfo: IAssemblyName;
		procedure _SetProp_FailedAssemblyInfo(Value: IAssemblyName);
		function _GetProp_GrantedSet: String;
		procedure _SetProp_GrantedSet(Value: String);
		function _GetProp_Method: IMethodInfo;
		procedure _SetProp_Method(Value: IMethodInfo);
		function _GetProp_PermissionState: String;
		procedure _SetProp_PermissionState(Value: String);
		function _GetProp_PermissionType: IType;
		procedure _SetProp_PermissionType(Value: IType);
		function _GetProp_PermitOnlySetInstance: Variant;
		procedure _SetProp_PermitOnlySetInstance(Value: Variant);
		function _GetProp_RefusedSet: String;
		procedure _SetProp_RefusedSet(Value: String);
		function _GetProp_Url: String;
		procedure _SetProp_Url(Value: String);
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Demanded: Variant read _GetProp_Demanded write _SetProp_Demanded;
		property DenySetInstance: Variant read _GetProp_DenySetInstance write _SetProp_DenySetInstance;
		property FailedAssemblyInfo: IAssemblyName read _GetProp_FailedAssemblyInfo write _SetProp_FailedAssemblyInfo;
		property GrantedSet: String read _GetProp_GrantedSet write _SetProp_GrantedSet;
		property Method: IMethodInfo read _GetProp_Method write _SetProp_Method;
		property PermissionState: String read _GetProp_PermissionState write _SetProp_PermissionState;
		property PermissionType: IType read _GetProp_PermissionType write _SetProp_PermissionType;
		property PermitOnlySetInstance: Variant read _GetProp_PermitOnlySetInstance write _SetProp_PermitOnlySetInstance;
		property RefusedSet: String read _GetProp_RefusedSet write _SetProp_RefusedSet;
		property Url: String read _GetProp_Url write _SetProp_Url;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_PERMISSIONS_SECURITYPERMISSIONATTRIBUTE)]
	ISecurityPermissionAttribute = interface(ICodeAccessSecurityAttribute)
	['{8E491622-D7A4-4C24-B521-5F4BD9D57C9F}']
	{ private }
		function _GetProp_Assertion: Boolean;
		procedure _SetProp_Assertion(Value: Boolean);
		function _GetProp_BindingRedirects: Boolean;
		procedure _SetProp_BindingRedirects(Value: Boolean);
		function _GetProp_ControlAppDomain: Boolean;
		procedure _SetProp_ControlAppDomain(Value: Boolean);
		function _GetProp_ControlDomainPolicy: Boolean;
		procedure _SetProp_ControlDomainPolicy(Value: Boolean);
		function _GetProp_ControlEvidence: Boolean;
		procedure _SetProp_ControlEvidence(Value: Boolean);
		function _GetProp_ControlPolicy: Boolean;
		procedure _SetProp_ControlPolicy(Value: Boolean);
		function _GetProp_ControlPrincipal: Boolean;
		procedure _SetProp_ControlPrincipal(Value: Boolean);
		function _GetProp_ControlThread: Boolean;
		procedure _SetProp_ControlThread(Value: Boolean);
		function _GetProp_Execution: Boolean;
		procedure _SetProp_Execution(Value: Boolean);
		function _GetProp_Flags: TSecurityPermissionFlag_Set;
		procedure _SetProp_Flags(Value: TSecurityPermissionFlag_Set);
		function _GetProp_Infrastructure: Boolean;
		procedure _SetProp_Infrastructure(Value: Boolean);
		function _GetProp_RemotingConfiguration: Boolean;
		procedure _SetProp_RemotingConfiguration(Value: Boolean);
		function _GetProp_SerializationFormatter: Boolean;
		procedure _SetProp_SerializationFormatter(Value: Boolean);
		function _GetProp_SkipVerification: Boolean;
		procedure _SetProp_SkipVerification(Value: Boolean);
		function _GetProp_UnmanagedCode: Boolean;
		procedure _SetProp_UnmanagedCode(Value: Boolean);
	{ public }
		function CreatePermission(): IIPermission;
		property Assertion: Boolean read _GetProp_Assertion write _SetProp_Assertion;
		property BindingRedirects: Boolean read _GetProp_BindingRedirects write _SetProp_BindingRedirects;
		property ControlAppDomain: Boolean read _GetProp_ControlAppDomain write _SetProp_ControlAppDomain;
		property ControlDomainPolicy: Boolean read _GetProp_ControlDomainPolicy write _SetProp_ControlDomainPolicy;
		property ControlEvidence: Boolean read _GetProp_ControlEvidence write _SetProp_ControlEvidence;
		property ControlPolicy: Boolean read _GetProp_ControlPolicy write _SetProp_ControlPolicy;
		property ControlPrincipal: Boolean read _GetProp_ControlPrincipal write _SetProp_ControlPrincipal;
		property ControlThread: Boolean read _GetProp_ControlThread write _SetProp_ControlThread;
		property Execution: Boolean read _GetProp_Execution write _SetProp_Execution;
		property Flags: TSecurityPermissionFlag_Set read _GetProp_Flags write _SetProp_Flags;
		property Infrastructure: Boolean read _GetProp_Infrastructure write _SetProp_Infrastructure;
		property RemotingConfiguration: Boolean read _GetProp_RemotingConfiguration write _SetProp_RemotingConfiguration;
		property SerializationFormatter: Boolean read _GetProp_SerializationFormatter write _SetProp_SerializationFormatter;
		property SkipVerification: Boolean read _GetProp_SkipVerification write _SetProp_SkipVerification;
		property UnmanagedCode: Boolean read _GetProp_UnmanagedCode write _SetProp_UnmanagedCode;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYRULESATTRIBUTE)]
	ISecurityRulesAttribute = interface(IAttribute)
	['{4B93A37A-9918-454D-BB06-4396646FFB99}']
	{ private }
		function _GetProp_RuleSet: TSecurityRuleSet;
		function _GetProp_SkipVerificationInFullTrust: Boolean;
		procedure _SetProp_SkipVerificationInFullTrust(Value: Boolean);
	{ public }
		property RuleSet: TSecurityRuleSet read _GetProp_RuleSet;
		property SkipVerificationInFullTrust: Boolean read _GetProp_SkipVerificationInFullTrust write _SetProp_SkipVerificationInFullTrust;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYSAFECRITICALATTRIBUTE)]
	ISecuritySafeCriticalAttribute = interface(IAttribute)
	['{40F16595-3CF3-4376-899E-2CFD0F12A058}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYTRANSPARENTATTRIBUTE)]
	ISecurityTransparentAttribute = interface(IAttribute)
	['{DAC99C4F-FCF4-4390-934E-47BB1E858F61}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SECURITYTREATASSAFEATTRIBUTE)]
	ISecurityTreatAsSafeAttribute = interface(IAttribute)
	['{7E972D9F-CC53-46B2-B778-E4C5CDEB7A24}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SEHEXCEPTION)]
	ISEHException = interface(IExternalException)
	['{6F2A6C5C-0FB5-4897-B613-0E14226A1972}']
	{ public }
		function CanResume(): Boolean;
	end;

	ISemaphoreClass = interface(ICoreClrClass)
	['{9C9377EC-CC33-40E7-9F66-78915B39EA12}']
	{ public }
		{ class } function OpenExisting(name: String): ISemaphore;
		{ class } function TryOpenExisting(name: String; var result_: ISemaphore): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SEMAPHORE)]
	ISemaphore = interface(IWaitHandle)
	['{3367E414-63BA-44FA-B09D-A31195182B28}']
	{ public }
		function Release(): Integer; overload;
		function Release(releaseCount: Integer): Integer; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SEMAPHOREFULLEXCEPTION)]
	ISemaphoreFullException = interface(ISystemException)
	['{56161F1D-1B83-486A-9865-51572C7D3B3D}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SEMAPHORESLIM)]
	ISemaphoreSlim = interface(IIDisposable)
	['{EB302871-46F2-4FD7-BA65-DE3EB27920D7}']
	{ private }
		function _GetProp_AvailableWaitHandle: IWaitHandle;
		function _GetProp_CurrentCount: Integer;
	{ public }
		procedure Dispose();
		function Release(): Integer; overload;
		function Release(releaseCount: Integer): Integer; overload;
		procedure Wait(); overload;
		procedure Wait(cancellationToken: ICancellationToken); overload;
		function Wait(timeout: ITimeSpan): Boolean; overload;
		function Wait(millisecondsTimeout: Integer): Boolean; overload;
		function Wait(timeout: ITimeSpan; cancellationToken: ICancellationToken): Boolean; overload;
		function Wait(millisecondsTimeout: Integer; cancellationToken: ICancellationToken): Boolean; overload;
		function WaitAsync(): ITask; overload;
		function WaitAsync(cancellationToken: ICancellationToken): ITask; overload;
		function WaitAsync(millisecondsTimeout: Integer): ITask<Boolean>; overload;
		function WaitAsync(timeout: ITimeSpan): ITask<Boolean>; overload;
		function WaitAsync(timeout: ITimeSpan; cancellationToken: ICancellationToken): ITask<Boolean>; overload;
		function WaitAsync(millisecondsTimeout: Integer; cancellationToken: ICancellationToken): ITask<Boolean>; overload;
		property AvailableWaitHandle: IWaitHandle read _GetProp_AvailableWaitHandle;
		property CurrentCount: Integer read _GetProp_CurrentCount;
	end;

	[CoreTypeSignature(SYSTEM_SERIALIZABLEATTRIBUTE)]
	ISerializableAttribute = interface(IAttribute)
	['{FD961C32-5CBE-4E7C-82AA-37EF852D086A}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_SERIALIZATIONENTRY)]
	ISerializationEntry = interface(IValueType)
	['{ECE86F9E-2FB1-4933-9293-41ADA4EE805E}']
	{ private }
		function _GetProp_Name: String;
		function _GetProp_ObjectType: IType;
		function _GetProp_Value: Variant;
	{ public }
		property Name: String read _GetProp_Name;
		property ObjectType: IType read _GetProp_ObjectType;
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_SERIALIZATIONEXCEPTION)]
	ISerializationException = interface(ISystemException)
	['{46336864-9E0D-4A05-81D2-D974E4038194}']
	end;

	ISerializationInfoClass = interface(ICoreClrClass)
	['{827C40BC-3DDD-4B4C-9305-DBF394F6BDC6}']
	{ private }
		{ class } function _GetProp_DeserializationInProgress: Boolean;
	{ public }
		{ class } function StartDeserialization(): IDeserializationToken;
		{ class } procedure ThrowIfDeserializationInProgress(); overload;
		{ class } procedure ThrowIfDeserializationInProgress(switchSuffix: String; var cachedValue: Integer); overload;
		{ class } property DeserializationInProgress: Boolean read _GetProp_DeserializationInProgress;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_SERIALIZATIONINFO)]
	ISerializationInfo = interface(IObject)
	['{57EF9B58-0409-4029-913B-DFD8232400F4}']
	{ private }
		function _GetProp_AssemblyName: String;
		procedure _SetProp_AssemblyName(Value: String);
		function _GetProp_FullTypeName: String;
		procedure _SetProp_FullTypeName(Value: String);
		function _GetProp_IsAssemblyNameSetExplicit: Boolean;
		function _GetProp_IsFullTypeNameSetExplicit: Boolean;
		function _GetProp_MemberCount: Integer;
		function _GetProp_ObjectType: IType;
	{ public }
		procedure AddValue(name: String; value: Variant; type_: IType); overload;
		procedure AddValue(name: String; value: Variant); overload;
		procedure AddValue(name: String; value: Boolean); overload;
		procedure AddValue(name: String; value: Char); overload;
		procedure AddValue(name: String; value: Shortint); overload;
		procedure AddValue(name: String; value: Byte); overload;
		procedure AddValue(name: String; value: SmallInt); overload;
		procedure AddValue(name: String; value: Word); overload;
		procedure AddValue(name: String; value: Integer); overload;
		procedure AddValue(name: String; value: longword); overload;
		procedure AddValue(name: String; value: Int64); overload;
		procedure AddValue(name: String; value: UInt64); overload;
		procedure AddValue(name: String; value: Single); overload;
		procedure AddValue(name: String; value: Double); overload;
		procedure AddValue(name: String; value: IDecimal); overload;
		procedure AddValue(name: String; value: TDateTime); overload;
		function GetBoolean(name: String): Boolean;
		function GetByte(name: String): Byte;
		function GetChar(name: String): Char;
		function GetDateTime(name: String): TDateTime;
		function GetDecimal(name: String): IDecimal;
		function GetDouble(name: String): Double;
		function GetEnumerator(): ISerializationInfoEnumerator;
		function GetInt16(name: String): SmallInt;
		function GetInt32(name: String): Integer;
		function GetInt64(name: String): Int64;
		function GetSByte(name: String): Shortint;
		function GetSingle(name: String): Single;
		function GetString(name: String): String;
		function GetUInt16(name: String): Word;
		function GetUInt32(name: String): longword;
		function GetUInt64(name: String): UInt64;
		function GetValue(name: String; type_: IType): Variant;
		procedure SetType(type_: IType);
		procedure UpdateValue(name: String; value: Variant; type_: IType);
		property AssemblyName: String read _GetProp_AssemblyName write _SetProp_AssemblyName;
		property FullTypeName: String read _GetProp_FullTypeName write _SetProp_FullTypeName;
		property IsAssemblyNameSetExplicit: Boolean read _GetProp_IsAssemblyNameSetExplicit;
		property IsFullTypeNameSetExplicit: Boolean read _GetProp_IsFullTypeNameSetExplicit;
		property MemberCount: Integer read _GetProp_MemberCount;
		property ObjectType: IType read _GetProp_ObjectType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_SERIALIZATIONINFOENUMERATOR)]
	ISerializationInfoEnumerator = interface(IIEnumerator)
	['{F32D4FE3-70FB-4842-A753-9D6957D98026}']
	{ private }
		function _GetProp_Current: ISerializationEntry;
		function _GetProp_Name: String;
		function _GetProp_ObjectType: IType;
		function _GetProp_Value: Variant;
	{ public }
		function MoveNext(): Boolean;
		procedure Reset();
		property Current: ISerializationEntry read _GetProp_Current;
		property Name: String read _GetProp_Name;
		property ObjectType: IType read _GetProp_ObjectType;
		property Value: Variant read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_SESSIONINFO)]
	ISessionInfo = interface(IValueType)
	['{31D9DC91-D5A7-412C-B445-9E44CB7C3A12}']
	end;

	ISha1Class = interface(ICoreClrClass)
	['{781554FB-4A32-43CE-A117-A97BF1237D4B}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function FixedRotate(hash_e: IVector64<longword>): IVector64<longword>;
		{ class } function HashUpdateChoose(hash_abcd: IVector128<longword>; hash_e: IVector64<longword>; wk: IVector128<longword>): IVector128<longword>;
		{ class } function HashUpdateMajority(hash_abcd: IVector128<longword>; hash_e: IVector64<longword>; wk: IVector128<longword>): IVector128<longword>;
		{ class } function HashUpdateParity(hash_abcd: IVector128<longword>; hash_e: IVector64<longword>; wk: IVector128<longword>): IVector128<longword>;
		{ class } function ScheduleUpdate0(w0_3: IVector128<longword>; w4_7: IVector128<longword>; w8_11: IVector128<longword>): IVector128<longword>;
		{ class } function ScheduleUpdate1(tw0_3: IVector128<longword>; w12_15: IVector128<longword>): IVector128<longword>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_SHA1)]
	ISha1 = interface(IArmBase)
	['{FB735B57-BF61-4F52-BC59-40FBA996FB6C}']
	end;

	ISha256Class = interface(ICoreClrClass)
	['{69323D78-DC1A-4351-AF39-2ECC07D26F9E}']
	{ private }
		{ class } function _GetProp_IsSupported: Boolean;
	{ public }
		{ class } function HashUpdate1(hash_abcd: IVector128<longword>; hash_efgh: IVector128<longword>; wk: IVector128<longword>): IVector128<longword>;
		{ class } function HashUpdate2(hash_efgh: IVector128<longword>; hash_abcd: IVector128<longword>; wk: IVector128<longword>): IVector128<longword>;
		{ class } function ScheduleUpdate0(w0_3: IVector128<longword>; w4_7: IVector128<longword>): IVector128<longword>;
		{ class } function ScheduleUpdate1(w0_3: IVector128<longword>; w8_11: IVector128<longword>; w12_15: IVector128<longword>): IVector128<longword>;
		{ class } property IsSupported: Boolean read _GetProp_IsSupported;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_ARM_SHA256)]
	ISha256 = interface(IArmBase)
	['{51D63123-697F-4F48-B119-A4388914034B}']
	end;

	ISignatureHelperClass = interface(ICoreClrClass)
	['{836A0A2E-3F95-4ED7-A97F-03C771AB0F3C}']
	{ public }
		{ class } function GetFieldSigHelper(mod_: IModule): ISignatureHelper;
		{ class } function GetLocalVarSigHelper(): ISignatureHelper; overload;
		{ class } function GetLocalVarSigHelper(mod_: IModule): ISignatureHelper; overload;
		{ class } function GetMethodSigHelper(mod_: IModule; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): ISignatureHelper; overload;
		{ class } function GetMethodSigHelper(mod_: IModule; callingConvention: TCallingConventions_Set; returnType: IType): ISignatureHelper; overload;
		{ class } function GetMethodSigHelper(mod_: IModule; unmanagedCallConv: TCallingConvention; returnType: IType): ISignatureHelper; overload;
		{ class } function GetMethodSigHelper(callingConvention: TCallingConventions_Set; returnType: IType): ISignatureHelper; overload;
		{ class } function GetMethodSigHelper(unmanagedCallingConvention: TCallingConvention; returnType: IType): ISignatureHelper; overload;
		{ class } function GetPropertySigHelper(mod_: IModule; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): ISignatureHelper; overload;
		{ class } function GetPropertySigHelper(mod_: IModule; returnType: IType; requiredReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; optionalReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; requiredParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; optionalParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): ISignatureHelper; overload;
		{ class } function GetPropertySigHelper(mod_: IModule; callingConvention: TCallingConventions_Set; returnType: IType; requiredReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; optionalReturnTypeCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; requiredParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; optionalParameterTypeCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): ISignatureHelper; overload;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_SIGNATUREHELPER)]
	ISignatureHelper = interface(IObject)
	['{228B3882-92EE-4BBD-8035-FB4F21068087}']
	{ public }
		procedure AddArgument(clsArgument: IType); overload;
		procedure AddArgument(argument: IType; pinned: Boolean); overload;
		procedure AddArgument(argument: IType; requiredCustomModifiers: ICoreClrBridgeArray<IType>; optionalCustomModifiers: ICoreClrBridgeArray<IType>); overload;
		procedure AddArguments(arguments: ICoreClrBridgeArray<IType>; requiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; optionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>);
		procedure AddSentinel();
		function GetSignature(): TArray<Byte>;
	end;

	ISignatureTokenClass = interface(ICoreClrClass)
	['{7A31A9B4-D144-4BE0-84CC-6A29DC115269}']
	{ private }
		{ class } function _GetFld_Empty: ISignatureToken;
	{ public }
		{ class } property Empty: ISignatureToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_SIGNATURETOKEN)]
	ISignatureToken = interface(IValueType)
	['{831CB7DB-D49D-40A0-84F6-DF8C3F7D5D09}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: ISignatureToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	ISingleClass = interface(ICoreClrClass)
	['{9D3958C8-D6B0-42BD-B7E0-457D8AF9AEC4}']
	{ private }
		{ class } function _GetFld_Epsilon: Single;
		{ class } function _GetFld_MaxValue: Single;
		{ class } function _GetFld_MinValue: Single;
		{ class } function _GetFld_NaN: Single;
		{ class } function _GetFld_NegativeInfinity: Single;
		{ class } function _GetFld_PositiveInfinity: Single;
	{ public }
		{ class } function IsFinite(f: Single): Boolean;
		{ class } function IsInfinity(f: Single): Boolean;
		{ class } function IsNaN(f: Single): Boolean;
		{ class } function IsNegative(f: Single): Boolean;
		{ class } function IsNegativeInfinity(f: Single): Boolean;
		{ class } function IsNormal(f: Single): Boolean;
		{ class } function IsPositiveInfinity(f: Single): Boolean;
		{ class } function IsSubnormal(f: Single): Boolean;
		{ class } function Parse(s: String): Single; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Single; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Single; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Single; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Single; overload;
		{ class } function TryParse(s: String; var result_: Single): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Single): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Single): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Single): Boolean; overload;
		{ class } property Epsilon: Single read _GetFld_Epsilon;
		{ class } property MaxValue: Single read _GetFld_MaxValue;
		{ class } property MinValue: Single read _GetFld_MinValue;
		{ class } property NaN: Single read _GetFld_NaN;
		{ class } property NegativeInfinity: Single read _GetFld_NegativeInfinity;
		{ class } property PositiveInfinity: Single read _GetFld_PositiveInfinity;
	end;

	[CoreTypeSignature(SYSTEM_SINGLE_)]
	ISingle = interface(IValueType)
	['{FA4E2722-68B1-48B4-913F-2BCD600DF978}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Single): Integer; overload;
		function Equals(obj: Single): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_SKIPLOCALSINITATTRIBUTE)]
	ISkipLocalsInitAttribute = interface(IAttribute)
	['{4CD03C38-0907-4EAA-9F82-8221A6432AC9}']
	end;

	ISortKeyClass = interface(ICoreClrClass)
	['{7D1F5063-34F5-46D2-ACE7-80A3B9D26BA1}']
	{ public }
		{ class } function Compare(sortkey1: ISortKey; sortkey2: ISortKey): Integer;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_SORTKEY)]
	ISortKey = interface(IObject)
	['{D0CCD2F5-084E-4C4B-ADB6-7F109356210B}']
	{ private }
		function _GetProp_KeyData: TArray<Byte>;
		function _GetProp_OriginalString: String;
	{ public }
		property KeyData: TArray<Byte> read _GetProp_KeyData;
		property OriginalString: String read _GetProp_OriginalString;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_SORTVERSION)]
	ISortVersion = interface(IIEquatable<ICoreClrInstance{ISortVersion}>)
	['{7717445B-D8A5-42ED-86C5-CA77843B04B6}']
	{ private }
		function _GetProp_FullVersion: Integer;
		function _GetProp_SortId: IGuid;
	{ public }
		function Equals(other: ISortVersion): Boolean;
		property FullVersion: Integer read _GetProp_FullVersion;
		property SortId: IGuid read _GetProp_SortId;
	end;

	ISpanClass<T> = interface(ICoreClrClass)
	['{8DC9C287-0458-45ED-A8AE-8A5823A29FC1}']
	{ private }
		{ class } function _GetProp_Empty: ISpan<T>;
	{ public }
		{ class } property Empty: ISpan<T> read _GetProp_Empty;
	end;

	[CoreTypeSignature(SYSTEM_SPAN_1)]
	ISpan<T> = interface(IValueType)
	['{D11C055A-C0F8-428C-9FDA-29688C346141}']
	{ private }
		function _GetProp_IsEmpty: Boolean;
		function _GetProp_Item(index: Integer): T;
		function _GetProp_Length: Integer;
	{ public }
		procedure Clear();
		procedure CopyTo(destination: ISpan<T>);
		procedure Fill(value: T);
		function GetEnumerator(): ISpan_Enumerator<T>;
		function GetPinnableReference(): T;
		function Slice(start: Integer): ISpan<T>; overload;
		function Slice(start: Integer; length: Integer): ISpan<T>; overload;
		function ToArray(): TArray<T>;
		function TryCopyTo(destination: ISpan<T>): Boolean;
		property IsEmpty: Boolean read _GetProp_IsEmpty;
		property Item[index: Integer]: T read _GetProp_Item; default;
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_SPANRUNEENUMERATOR)]
	ISpanRuneEnumerator = interface(IValueType)
	['{AF99AA6A-0202-4B98-ACDF-F14B7AC661A5}']
	{ private }
		function _GetProp_Current: IRune;
	{ public }
		function GetEnumerator(): ISpanRuneEnumerator;
		function MoveNext(): Boolean;
		property Current: IRune read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_SPECIALNAMEATTRIBUTE)]
	ISpecialNameAttribute = interface(IAttribute)
	['{4363D78E-F90F-4734-B84C-198B7E86F5FD}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SPINLOCK)]
	ISpinLock = interface(IValueType)
	['{62F02658-A13B-43DD-9636-91CBC3CDC4FF}']
	{ private }
		function _GetProp_IsHeld: Boolean;
		function _GetProp_IsHeldByCurrentThread: Boolean;
		function _GetProp_IsThreadOwnerTrackingEnabled: Boolean;
	{ public }
		procedure Enter(var lockTaken: Boolean);
		procedure Exit(); overload;
		procedure Exit(useMemoryBarrier: Boolean); overload;
		procedure TryEnter(var lockTaken: Boolean); overload;
		procedure TryEnter(timeout: ITimeSpan; var lockTaken: Boolean); overload;
		procedure TryEnter(millisecondsTimeout: Integer; var lockTaken: Boolean); overload;
		property IsHeld: Boolean read _GetProp_IsHeld;
		property IsHeldByCurrentThread: Boolean read _GetProp_IsHeldByCurrentThread;
		property IsThreadOwnerTrackingEnabled: Boolean read _GetProp_IsThreadOwnerTrackingEnabled;
	end;

	ISpinWaitClass = interface(ICoreClrClass)
	['{58C30925-D05B-497D-BC26-2B6578F743D7}']
	{ public }
		{ class } procedure SpinUntil(condition: TClrFunc<Boolean>); overload;
		{ class } function SpinUntil(condition: TClrFunc<Boolean>; timeout: ITimeSpan): Boolean; overload;
		{ class } function SpinUntil(condition: TClrFunc<Boolean>; millisecondsTimeout: Integer): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SPINWAIT)]
	ISpinWait = interface(IValueType)
	['{2F3E9386-DCA2-4D27-B6C9-FEDF473B4DCA}']
	{ private }
		function _GetProp_Count: Integer;
		function _GetProp_NextSpinWillYield: Boolean;
	{ public }
		procedure Reset();
		procedure SpinOnce(); overload;
		procedure SpinOnce(sleep1Threshold: Integer); overload;
		property Count: Integer read _GetProp_Count;
		property NextSpinWillYield: Boolean read _GetProp_NextSpinWillYield;
	end;

	IStackFrameClass = interface(ICoreClrClass)
	['{83A91C23-B1F5-4055-92FE-25EC9A73B9B3}']
	{ private }
		{ class } function _GetFld_OFFSET_UNKNOWN: Integer;
	{ public }
		{ class } property OFFSET_UNKNOWN: Integer read _GetFld_OFFSET_UNKNOWN;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_STACKFRAME)]
	IStackFrame = interface(IObject)
	['{E2857D9B-DCAB-438A-B4C9-2A351A1B4011}']
	{ public }
		function GetFileColumnNumber(): Integer;
		function GetFileLineNumber(): Integer;
		function GetFileName(): String;
		function GetILOffset(): Integer;
		function GetMethod(): IMethodBase;
		function GetNativeOffset(): Integer;
	end;

	[CoreTypeSignature(SYSTEM_STACKOVERFLOWEXCEPTION)]
	IStackOverflowException = interface(ISystemException)
	['{FAF2F546-B8BD-4D87-93F1-C9CA333B5107}']
	end;

	IStackTraceClass = interface(ICoreClrClass)
	['{AA1185C6-097A-4E8A-912E-56C26523413F}']
	{ private }
		{ class } function _GetFld_METHODS_TO_SKIP: Integer;
	{ public }
		{ class } property METHODS_TO_SKIP: Integer read _GetFld_METHODS_TO_SKIP;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_STACKTRACE)]
	IStackTrace = interface(IObject)
	['{F8806220-DDC5-4534-8E6E-94EF973D7EED}']
	{ private }
		function _GetProp_FrameCount: Integer;
	{ public }
		function GetFrame(index: Integer): IStackFrame;
		function GetFrames(): TArray<IStackFrame>;
		property FrameCount: Integer read _GetProp_FrameCount;
	end;

	IStandardFormatClass = interface(ICoreClrClass)
	['{F633CCAE-0965-4233-9664-75FC6F107224}']
	{ private }
		{ class } function _GetFld_MaxPrecision: Byte;
		{ class } function _GetFld_NoPrecision: Byte;
	{ public }
		{ class } function Parse(format: IReadOnlySpan<Char>): IStandardFormat; overload;
		{ class } function Parse(format: String): IStandardFormat; overload;
		{ class } function TryParse(format: IReadOnlySpan<Char>; var result_: IStandardFormat): Boolean;
		{ class } property MaxPrecision: Byte read _GetFld_MaxPrecision;
		{ class } property NoPrecision: Byte read _GetFld_NoPrecision;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_STANDARDFORMAT)]
	IStandardFormat = interface(IValueType)
	['{28263FCA-B8E9-4EE0-9D02-EE568FFF9C20}']
	{ private }
		function _GetProp_HasPrecision: Boolean;
		function _GetProp_IsDefault: Boolean;
		function _GetProp_Precision: Byte;
		function _GetProp_Symbol: Char;
	{ public }
		function Equals(other: IStandardFormat): Boolean;
		property HasPrecision: Boolean read _GetProp_HasPrecision;
		property IsDefault: Boolean read _GetProp_IsDefault;
		property Precision: Byte read _GetProp_Precision;
		property Symbol: Char read _GetProp_Symbol;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_STANDARDOLEMARSHALOBJECT)]
	IStandardOleMarshalObject = interface(IMarshalByRefObject)
	['{369B5BC1-1770-41CA-8F54-D55DD4A75C09}']
	end;

	[CoreTypeSignature(SYSTEM_STATHREADATTRIBUTE)]
	ISTAThreadAttribute = interface(IAttribute)
	['{0BEDCC2B-877A-4BF4-BA18-433EAA754B05}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_STATSTG)]
	ISTATSTG = interface(IValueType)
	['{71C14959-1818-4398-B427-25FB7A27346D}']
	{ private }
		function _GetFld_atime: IFILETIME;
		procedure _SetFld_atime(Value: IFILETIME);
		function _GetFld_cbSize: Int64;
		procedure _SetFld_cbSize(Value: Int64);
		function _GetFld_clsid: IGuid;
		procedure _SetFld_clsid(Value: IGuid);
		function _GetFld_ctime: IFILETIME;
		procedure _SetFld_ctime(Value: IFILETIME);
		function _GetFld_grfLocksSupported: Integer;
		procedure _SetFld_grfLocksSupported(Value: Integer);
		function _GetFld_grfMode: Integer;
		procedure _SetFld_grfMode(Value: Integer);
		function _GetFld_grfStateBits: Integer;
		procedure _SetFld_grfStateBits(Value: Integer);
		function _GetFld_mtime: IFILETIME;
		procedure _SetFld_mtime(Value: IFILETIME);
		function _GetFld_pwcsName: String;
		procedure _SetFld_pwcsName(Value: String);
		function _GetFld_reserved: Integer;
		procedure _SetFld_reserved(Value: Integer);
		function _GetFld_type: Integer;
		procedure _SetFld_type(Value: Integer);
	{ public }
		property atime: IFILETIME read _GetFld_atime write _SetFld_atime;
		property cbSize: Int64 read _GetFld_cbSize write _SetFld_cbSize;
		property clsid: IGuid read _GetFld_clsid write _SetFld_clsid;
		property ctime: IFILETIME read _GetFld_ctime write _SetFld_ctime;
		property grfLocksSupported: Integer read _GetFld_grfLocksSupported write _SetFld_grfLocksSupported;
		property grfMode: Integer read _GetFld_grfMode write _SetFld_grfMode;
		property grfStateBits: Integer read _GetFld_grfStateBits write _SetFld_grfStateBits;
		property mtime: IFILETIME read _GetFld_mtime write _SetFld_mtime;
		property pwcsName: String read _GetFld_pwcsName write _SetFld_pwcsName;
		property reserved: Integer read _GetFld_reserved write _SetFld_reserved;
		property &type: Integer read _GetFld_type write _SetFld_type;
	end;

	IStopwatchClass = interface(ICoreClrClass)
	['{C0F7487D-3548-468A-B687-A78A1F2B2BFD}']
	{ private }
		{ class } function _GetFld_Frequency: Int64;
		{ class } function _GetFld_IsHighResolution: Boolean;
	{ public }
		{ class } function GetTimestamp(): Int64;
		{ class } function StartNew(): IStopwatch;
		{ class } property Frequency: Int64 read _GetFld_Frequency;
		{ class } property IsHighResolution: Boolean read _GetFld_IsHighResolution;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_STOPWATCH)]
	IStopwatch = interface(IObject)
	['{C2126432-A11D-4FE2-B0FF-D04B645D63B3}']
	{ private }
		function _GetProp_Elapsed: ITimeSpan;
		function _GetProp_ElapsedMilliseconds: Int64;
		function _GetProp_ElapsedTicks: Int64;
		function _GetProp_IsRunning: Boolean;
	{ public }
		procedure Reset();
		procedure Restart();
		procedure Start();
		procedure Stop();
		property Elapsed: ITimeSpan read _GetProp_Elapsed;
		property ElapsedMilliseconds: Int64 read _GetProp_ElapsedMilliseconds;
		property ElapsedTicks: Int64 read _GetProp_ElapsedTicks;
		property IsRunning: Boolean read _GetProp_IsRunning;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_SERIALIZATION_STREAMINGCONTEXT)]
	IStreamingContext = interface(IValueType)
	['{CC2F49ED-2AAB-4FBF-B1CA-90F7BB8D2E24}']
	{ private }
		function _GetProp_Context: Variant;
		function _GetProp_State: TStreamingContextStates_Set;
	{ public }
		property Context: Variant read _GetProp_Context;
		property State: TStreamingContextStates_Set read _GetProp_State;
	end;

	ITextReaderClass = interface(ICoreClrClass)
	['{92567292-6EF8-4B21-B770-B5DCEEE473A2}']
	{ private }
		{ class } function _GetFld_Null: ITextReader;
	{ public }
		{ class } function Synchronized(reader: ITextReader): ITextReader;
		{ class } property Null: ITextReader read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_TEXTREADER)]
	ITextReader = interface(IMarshalByRefObject)
	['{394C96F4-EC6F-4524-8B38-E6A8449E0DF1}']
	{ public }
		procedure Close();
		procedure Dispose();
		function Peek(): Integer;
		function Read(): Integer; overload;
		function Read(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Char>): Integer; overload;
		function ReadAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadBlock(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function ReadBlock(buffer: ISpan<Char>): Integer; overload;
		function ReadBlockAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadBlockAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadLine(): String;
		function ReadLineAsync(): ITask<String>;
		function ReadToEnd(): String;
		function ReadToEndAsync(): ITask<String>;
	end;

	IStreamReaderClass = interface(ICoreClrClass)
	['{FF7A38B5-F7DD-401A-AB1D-5026502F2A24}']
	{ private }
		{ class } function _GetFld_Null: IStreamReader;
	{ public }
		{ class } property Null: IStreamReader read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_STREAMREADER)]
	IStreamReader = interface(ITextReader)
	['{64A23443-D358-4C79-BB2D-28C2961685A5}']
	{ private }
		function _GetProp_BaseStream: IStream;
		function _GetProp_CurrentEncoding: IEncoding;
		function _GetProp_EndOfStream: Boolean;
	{ public }
		procedure Close();
		procedure DiscardBufferedData();
		function Peek(): Integer;
		function Read(): Integer; overload;
		function Read(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Char>): Integer; overload;
		function ReadAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadBlock(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function ReadBlock(buffer: ISpan<Char>): Integer; overload;
		function ReadBlockAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadBlockAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadLine(): String;
		function ReadLineAsync(): ITask<String>;
		function ReadToEnd(): String;
		function ReadToEndAsync(): ITask<String>;
		property BaseStream: IStream read _GetProp_BaseStream;
		property CurrentEncoding: IEncoding read _GetProp_CurrentEncoding;
		property EndOfStream: Boolean read _GetProp_EndOfStream;
	end;

	IStreamWriterClass = interface(ICoreClrClass)
	['{BCFB9130-4E3D-4B56-8707-33FB755D48F5}']
	{ private }
		{ class } function _GetFld_Null: IStreamWriter;
	{ public }
		{ class } property Null: IStreamWriter read _GetFld_Null;
	end;

	[CoreTypeSignature(SYSTEM_IO_STREAMWRITER)]
	IStreamWriter = interface(ITextWriter)
	['{860C7AF9-511C-4948-8D99-78D4B53E7844}']
	{ private }
		function _GetProp_AutoFlush: Boolean;
		procedure _SetProp_AutoFlush(Value: Boolean);
		function _GetProp_BaseStream: IStream;
		function _GetProp_Encoding: IEncoding;
	{ public }
		procedure Close();
		function DisposeAsync(): IValueTask;
		procedure Flush();
		function FlushAsync(): ITask;
		procedure Write(value: Char); overload;
		procedure Write(buffer: TArray<Char>); overload;
		procedure Write(buffer: IReadOnlySpan<Char>); overload;
		procedure Write(value: String); overload;
		procedure Write(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		procedure Write(format: String; arg0: Variant; arg1: Variant); overload;
		procedure Write(format: String; arg0: Variant); overload;
		procedure Write(format: String; arg: TArray<Variant>); overload;
		procedure Write(format: String; arg0: Variant; arg1: Variant; arg2: Variant); overload;
		function WriteAsync(value: Char): ITask; overload;
		function WriteAsync(value: String): ITask; overload;
		function WriteAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		procedure WriteLine(value: String); overload;
		procedure WriteLine(value: IReadOnlySpan<Char>); overload;
		procedure WriteLine(format: String; arg0: Variant); overload;
		procedure WriteLine(format: String; arg: TArray<Variant>); overload;
		procedure WriteLine(format: String; arg0: Variant; arg1: Variant); overload;
		procedure WriteLine(format: String; arg0: Variant; arg1: Variant; arg2: Variant); overload;
		function WriteLineAsync(): ITask; overload;
		function WriteLineAsync(value: Char): ITask; overload;
		function WriteLineAsync(value: String): ITask; overload;
		function WriteLineAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		function WriteLineAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		property AutoFlush: Boolean read _GetProp_AutoFlush write _SetProp_AutoFlush;
		property BaseStream: IStream read _GetProp_BaseStream;
		property Encoding: IEncoding read _GetProp_Encoding;
	end;

	IStringClass = interface(ICoreClrClass)
	['{07C7FB39-B0C5-4339-822C-6DC723429867}']
	{ private }
		{ class } function _GetFld_Empty: String;
	{ public }
		{ class } function Compare(strA: String; strB: String): Integer; overload;
		{ class } function Compare(strA: String; strB: String; ignoreCase: Boolean): Integer; overload;
		{ class } function Compare(strA: String; strB: String; comparisonType: TStringComparison): Integer; overload;
		{ class } function Compare(strA: String; strB: String; culture: ICultureInfo; options: TCompareOptions_Set): Integer; overload;
		{ class } function Compare(strA: String; strB: String; ignoreCase: Boolean; culture: ICultureInfo): Integer; overload;
		{ class } function Compare(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer): Integer; overload;
		{ class } function Compare(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer; ignoreCase: Boolean): Integer; overload;
		{ class } function Compare(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer; comparisonType: TStringComparison): Integer; overload;
		{ class } function Compare(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer; ignoreCase: Boolean; culture: ICultureInfo): Integer; overload;
		{ class } function Compare(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer; culture: ICultureInfo; options: TCompareOptions_Set): Integer; overload;
		{ class } function CompareOrdinal(strA: String; strB: String): Integer; overload;
		{ class } function CompareOrdinal(strA: String; indexA: Integer; strB: String; indexB: Integer; length: Integer): Integer; overload;
		{ class } function Concat(arg0: Variant): String; overload;
		{ class } function Concat(args: TArray<Variant>): String; overload;
		{ class } function Concat(T: PTypeInfo; values: IIEnumerable<Variant{T}>): String; overload;
		{ class } function Concat(values: IIEnumerable<String>): String; overload;
		{ class } function Concat(values: TArray<String>): String; overload;
		{ class } function Concat(arg0: Variant; arg1: Variant): String; overload;
		{ class } function Concat(str0: String; str1: String): String; overload;
		{ class } function Concat(str0: IReadOnlySpan<Char>; str1: IReadOnlySpan<Char>): String; overload;
		{ class } function Concat(arg0: Variant; arg1: Variant; arg2: Variant): String; overload;
		{ class } function Concat(str0: String; str1: String; str2: String): String; overload;
		{ class } function Concat(str0: IReadOnlySpan<Char>; str1: IReadOnlySpan<Char>; str2: IReadOnlySpan<Char>): String; overload;
		{ class } function Concat(str0: String; str1: String; str2: String; str3: String): String; overload;
		{ class } function Concat(str0: IReadOnlySpan<Char>; str1: IReadOnlySpan<Char>; str2: IReadOnlySpan<Char>; str3: IReadOnlySpan<Char>): String; overload;
		{ class } function Copy(str: String): String;
		{ class } function Create(TState: PTypeInfo; length: Integer; state: Variant{TState}; action: TSpanAction<Char, Variant{TState}>): String;
		{ class } function Equals(a: String; b: String): Boolean; overload;
		{ class } function Equals(a: String; b: String; comparisonType: TStringComparison): Boolean; overload;
		{ class } function Format(format: String; arg0: Variant): String; overload;
		{ class } function Format(format: String; args: TArray<Variant>): String; overload;
		{ class } function Format(format: String; arg0: Variant; arg1: Variant): String; overload;
		{ class } function Format(provider: IIFormatProvider; format: String; arg0: Variant): String; overload;
		{ class } function Format(provider: IIFormatProvider; format: String; args: TArray<Variant>): String; overload;
		{ class } function Format(format: String; arg0: Variant; arg1: Variant; arg2: Variant): String; overload;
		{ class } function Format(provider: IIFormatProvider; format: String; arg0: Variant; arg1: Variant): String; overload;
		{ class } function Format(provider: IIFormatProvider; format: String; arg0: Variant; arg1: Variant; arg2: Variant): String; overload;
		{ class } function GetHashCode(value: IReadOnlySpan<Char>): Integer; overload;
		{ class } function GetHashCode(value: IReadOnlySpan<Char>; comparisonType: TStringComparison): Integer; overload;
		{ class } function Intern(str: String): String;
		{ class } function IsInterned(str: String): String;
		{ class } function IsNullOrEmpty(value: String): Boolean;
		{ class } function IsNullOrWhiteSpace(value: String): Boolean;
		{ class } function Join(separator: Char; value: TArray<String>): String; overload;
		{ class } function Join(separator: Char; values: TArray<Variant>): String; overload;
		{ class } function Join(T: PTypeInfo; separator: Char; values: IIEnumerable<Variant{T}>): String; overload;
		{ class } function Join(separator: String; value: TArray<String>): String; overload;
		{ class } function Join(separator: String; values: TArray<Variant>): String; overload;
		{ class } function Join(T: PTypeInfo; separator: String; values: IIEnumerable<Variant{T}>): String; overload;
		{ class } function Join(separator: String; values: IIEnumerable<String>): String; overload;
		{ class } function Join(separator: Char; value: TArray<String>; startIndex: Integer; count: Integer): String; overload;
		{ class } function Join(separator: String; value: TArray<String>; startIndex: Integer; count: Integer): String; overload;
		{ class } property Empty: String read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_STRING_)]
	IString = interface(IObject)
	['{977075B4-3B8A-4649-94BB-B590D72C133A}']
	{ private }
		function _GetProp_Chars(index: Integer): Char;
		function _GetProp_Length: Integer;
	{ public }
		function Clone(): Variant;
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(strB: String): Integer; overload;
		function Contains(value: String): Boolean; overload;
		function Contains(value: Char): Boolean; overload;
		function Contains(value: String; comparisonType: TStringComparison): Boolean; overload;
		function Contains(value: Char; comparisonType: TStringComparison): Boolean; overload;
		procedure CopyTo(sourceIndex: Integer; destination: TArray<Char>; destinationIndex: Integer; count: Integer);
		function EndsWith(value: String): Boolean; overload;
		function EndsWith(value: Char): Boolean; overload;
		function EndsWith(value: String; comparisonType: TStringComparison): Boolean; overload;
		function EndsWith(value: String; ignoreCase: Boolean; culture: ICultureInfo): Boolean; overload;
		function EnumerateRunes(): IStringRuneEnumerator;
		function Equals(value: String): Boolean; overload;
		function Equals(value: String; comparisonType: TStringComparison): Boolean; overload;
		function GetEnumerator(): ICharEnumerator;
		function GetHashCode(comparisonType: TStringComparison): Integer;
		function GetPinnableReference(): IChar;
		function GetTypeCode(): TTypeCode;
		function IndexOf(value: Char): Integer; overload;
		function IndexOf(value: String): Integer; overload;
		function IndexOf(value: Char; startIndex: Integer): Integer; overload;
		function IndexOf(value: Char; comparisonType: TStringComparison): Integer; overload;
		function IndexOf(value: String; startIndex: Integer): Integer; overload;
		function IndexOf(value: String; comparisonType: TStringComparison): Integer; overload;
		function IndexOf(value: Char; startIndex: Integer; count: Integer): Integer; overload;
		function IndexOf(value: String; startIndex: Integer; count: Integer): Integer; overload;
		function IndexOf(value: String; startIndex: Integer; comparisonType: TStringComparison): Integer; overload;
		function IndexOf(value: String; startIndex: Integer; count: Integer; comparisonType: TStringComparison): Integer; overload;
		function IndexOfAny(anyOf: TArray<Char>): Integer; overload;
		function IndexOfAny(anyOf: TArray<Char>; startIndex: Integer): Integer; overload;
		function IndexOfAny(anyOf: TArray<Char>; startIndex: Integer; count: Integer): Integer; overload;
		function Insert(startIndex: Integer; value: String): String;
		function IsNormalized(): Boolean; overload;
		function IsNormalized(normalizationForm: TNormalizationForm): Boolean; overload;
		function LastIndexOf(value: Char): Integer; overload;
		function LastIndexOf(value: String): Integer; overload;
		function LastIndexOf(value: Char; startIndex: Integer): Integer; overload;
		function LastIndexOf(value: String; startIndex: Integer): Integer; overload;
		function LastIndexOf(value: String; comparisonType: TStringComparison): Integer; overload;
		function LastIndexOf(value: Char; startIndex: Integer; count: Integer): Integer; overload;
		function LastIndexOf(value: String; startIndex: Integer; count: Integer): Integer; overload;
		function LastIndexOf(value: String; startIndex: Integer; comparisonType: TStringComparison): Integer; overload;
		function LastIndexOf(value: String; startIndex: Integer; count: Integer; comparisonType: TStringComparison): Integer; overload;
		function LastIndexOfAny(anyOf: TArray<Char>): Integer; overload;
		function LastIndexOfAny(anyOf: TArray<Char>; startIndex: Integer): Integer; overload;
		function LastIndexOfAny(anyOf: TArray<Char>; startIndex: Integer; count: Integer): Integer; overload;
		function Normalize(): String; overload;
		function Normalize(normalizationForm: TNormalizationForm): String; overload;
		function PadLeft(totalWidth: Integer): String; overload;
		function PadLeft(totalWidth: Integer; paddingChar: Char): String; overload;
		function PadRight(totalWidth: Integer): String; overload;
		function PadRight(totalWidth: Integer; paddingChar: Char): String; overload;
		function Remove(startIndex: Integer; count: Integer): String; overload;
		function Remove(startIndex: Integer): String; overload;
		function Replace(oldValue: String; newValue: String; ignoreCase: Boolean; culture: ICultureInfo): String; overload;
		function Replace(oldValue: String; newValue: String; comparisonType: TStringComparison): String; overload;
		function Replace(oldChar: Char; newChar: Char): String; overload;
		function Replace(oldValue: String; newValue: String): String; overload;
		function Split(separator: Char; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: TArray<Char>; count: Integer): TArray<String>; overload;
		function Split(separator: TArray<Char>; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: String; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: TArray<String>; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: Char; count: Integer; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: TArray<Char>; count: Integer; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: String; count: Integer; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: TArray<String>; count: Integer; options: TStringSplitOptions_Set): TArray<String>; overload;
		function Split(separator: TArray<Char>): TArray<String>; overload;
		function StartsWith(value: String): Boolean; overload;
		function StartsWith(value: Char): Boolean; overload;
		function StartsWith(value: String; comparisonType: TStringComparison): Boolean; overload;
		function StartsWith(value: String; ignoreCase: Boolean; culture: ICultureInfo): Boolean; overload;
		function Substring(startIndex: Integer): String; overload;
		function Substring(startIndex: Integer; length: Integer): String; overload;
		function ToCharArray(): TArray<Char>; overload;
		function ToCharArray(startIndex: Integer; length: Integer): TArray<Char>; overload;
		function ToLower(): String; overload;
		function ToLower(culture: ICultureInfo): String; overload;
		function ToLowerInvariant(): String;
		function ToString(provider: IIFormatProvider): String;
		function ToUpper(): String; overload;
		function ToUpper(culture: ICultureInfo): String; overload;
		function ToUpperInvariant(): String;
		function Trim(): String; overload;
		function Trim(trimChar: Char): String; overload;
		function Trim(trimChars: TArray<Char>): String; overload;
		function TrimEnd(): String; overload;
		function TrimEnd(trimChar: Char): String; overload;
		function TrimEnd(trimChars: TArray<Char>): String; overload;
		function TrimStart(): String; overload;
		function TrimStart(trimChar: Char): String; overload;
		function TrimStart(trimChars: TArray<Char>): String; overload;
		property Chars[index: Integer]: Char read _GetProp_Chars; default;
		property Length: Integer read _GetProp_Length;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_STRINGBUILDER)]
	IStringBuilder = interface(IISerializable)
	['{E50FD548-C3B1-44CF-8E0E-49237ADC611C}']
	{ private }
		function _GetProp_Capacity: Integer;
		procedure _SetProp_Capacity(Value: Integer);
		function _GetProp_Chars(index: Integer): Char;
		procedure _SetProp_Chars(index: Integer; Value: Char);
		function _GetProp_Length: Integer;
		procedure _SetProp_Length(Value: Integer);
		function _GetProp_MaxCapacity: Integer;
	{ public }
		function Append(value: ICoreClrInstance; valueCount: Integer): IStringBuilder; overload;
		function Append(value: Char; repeatCount: Integer): IStringBuilder; overload;
		function Append(value: TArray<Char>; startIndex: Integer; charCount: Integer): IStringBuilder; overload;
		function Append(value: String; startIndex: Integer; count: Integer): IStringBuilder; overload;
		function Append(value: IStringBuilder; startIndex: Integer; count: Integer): IStringBuilder; overload;
		function Append(value: String): IStringBuilder; overload;
		function Append(value: IStringBuilder): IStringBuilder; overload;
		function Append(value: Boolean): IStringBuilder; overload;
		function Append(value: Char): IStringBuilder; overload;
		function Append(value: Shortint): IStringBuilder; overload;
		function Append(value: Byte): IStringBuilder; overload;
		function Append(value: SmallInt): IStringBuilder; overload;
		function Append(value: Integer): IStringBuilder; overload;
		function Append(value: Int64): IStringBuilder; overload;
		function Append(value: Single): IStringBuilder; overload;
		function Append(value: Double): IStringBuilder; overload;
		function Append(value: IDecimal): IStringBuilder; overload;
		function Append(value: Word): IStringBuilder; overload;
		function Append(value: longword): IStringBuilder; overload;
		function Append(value: UInt64): IStringBuilder; overload;
		function Append(value: Variant): IStringBuilder; overload;
		function Append(value: TArray<Char>): IStringBuilder; overload;
		function Append(value: IReadOnlySpan<Char>): IStringBuilder; overload;
		function Append(value: IReadOnlyMemory<Char>): IStringBuilder; overload;
		function AppendFormat(format: String; arg0: Variant): IStringBuilder; overload;
		function AppendFormat(format: String; args: TArray<Variant>): IStringBuilder; overload;
		function AppendFormat(format: String; arg0: Variant; arg1: Variant): IStringBuilder; overload;
		function AppendFormat(provider: IIFormatProvider; format: String; arg0: Variant): IStringBuilder; overload;
		function AppendFormat(provider: IIFormatProvider; format: String; args: TArray<Variant>): IStringBuilder; overload;
		function AppendFormat(format: String; arg0: Variant; arg1: Variant; arg2: Variant): IStringBuilder; overload;
		function AppendFormat(provider: IIFormatProvider; format: String; arg0: Variant; arg1: Variant): IStringBuilder; overload;
		function AppendFormat(provider: IIFormatProvider; format: String; arg0: Variant; arg1: Variant; arg2: Variant): IStringBuilder; overload;
		function AppendJoin(separator: String; values: TArray<Variant>): IStringBuilder; overload;
		function AppendJoin(T: PTypeInfo; separator: String; values: IIEnumerable<Variant{T}>): IStringBuilder; overload;
		function AppendJoin(separator: String; values: TArray<String>): IStringBuilder; overload;
		function AppendJoin(separator: Char; values: TArray<Variant>): IStringBuilder; overload;
		function AppendJoin(T: PTypeInfo; separator: Char; values: IIEnumerable<Variant{T}>): IStringBuilder; overload;
		function AppendJoin(separator: Char; values: TArray<String>): IStringBuilder; overload;
		function AppendLine(): IStringBuilder; overload;
		function AppendLine(value: String): IStringBuilder; overload;
		function Clear(): IStringBuilder;
		procedure CopyTo(sourceIndex: Integer; destination: TArray<Char>; destinationIndex: Integer; count: Integer); overload;
		procedure CopyTo(sourceIndex: Integer; destination: ISpan<Char>; count: Integer); overload;
		function EnsureCapacity(capacity: Integer): Integer;
		function Equals(sb: IStringBuilder): Boolean; overload;
		function Equals(span: IReadOnlySpan<Char>): Boolean; overload;
		function GetChunks(): IChunkEnumerator;
		function Insert(index: Integer; value: longword): IStringBuilder; overload;
		function Insert(index: Integer; value: UInt64): IStringBuilder; overload;
		function Insert(index: Integer; value: Variant): IStringBuilder; overload;
		function Insert(index: Integer; value: IReadOnlySpan<Char>): IStringBuilder; overload;
		function Insert(index: Integer; value: String): IStringBuilder; overload;
		function Insert(index: Integer; value: Boolean): IStringBuilder; overload;
		function Insert(index: Integer; value: Shortint): IStringBuilder; overload;
		function Insert(index: Integer; value: Byte): IStringBuilder; overload;
		function Insert(index: Integer; value: SmallInt): IStringBuilder; overload;
		function Insert(index: Integer; value: Char): IStringBuilder; overload;
		function Insert(index: Integer; value: TArray<Char>): IStringBuilder; overload;
		function Insert(index: Integer; value: Integer): IStringBuilder; overload;
		function Insert(index: Integer; value: Int64): IStringBuilder; overload;
		function Insert(index: Integer; value: Single): IStringBuilder; overload;
		function Insert(index: Integer; value: Double): IStringBuilder; overload;
		function Insert(index: Integer; value: IDecimal): IStringBuilder; overload;
		function Insert(index: Integer; value: Word): IStringBuilder; overload;
		function Insert(index: Integer; value: String; count: Integer): IStringBuilder; overload;
		function Insert(index: Integer; value: TArray<Char>; startIndex: Integer; charCount: Integer): IStringBuilder; overload;
		function Remove(startIndex: Integer; length: Integer): IStringBuilder;
		function Replace(oldValue: String; newValue: String): IStringBuilder; overload;
		function Replace(oldChar: Char; newChar: Char): IStringBuilder; overload;
		function Replace(oldValue: String; newValue: String; startIndex: Integer; count: Integer): IStringBuilder; overload;
		function Replace(oldChar: Char; newChar: Char; startIndex: Integer; count: Integer): IStringBuilder; overload;
		function ToString(startIndex: Integer; length: Integer): String;
		property Capacity: Integer read _GetProp_Capacity write _SetProp_Capacity;
		property Chars[index: Integer]: Char read _GetProp_Chars write _SetProp_Chars; default;
		property Length: Integer read _GetProp_Length write _SetProp_Length;
		property MaxCapacity: Integer read _GetProp_MaxCapacity;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_STRINGFREEZINGATTRIBUTE)]
	IStringFreezingAttribute = interface(IAttribute)
	['{788A5ED4-F13B-4A3B-8AD1-4488CAAD6FB4}']
	end;

	IStringInfoClass = interface(ICoreClrClass)
	['{3DE21EA0-340B-4324-8804-24ABD71DED23}']
	{ public }
		{ class } function GetNextTextElement(str: String): String; overload;
		{ class } function GetNextTextElement(str: String; index: Integer): String; overload;
		{ class } function GetTextElementEnumerator(str: String): ITextElementEnumerator; overload;
		{ class } function GetTextElementEnumerator(str: String; index: Integer): ITextElementEnumerator; overload;
		{ class } function ParseCombiningCharacters(str: String): TArray<Integer>;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_STRINGINFO)]
	IStringInfo = interface(IObject)
	['{92D00525-4362-4762-A225-24EDF62C3F4A}']
	{ private }
		function _GetProp_LengthInTextElements: Integer;
		function _GetProp_String: String;
		procedure _SetProp_String(Value: String);
	{ public }
		function SubstringByTextElements(startingTextElement: Integer): String; overload;
		function SubstringByTextElements(startingTextElement: Integer; lengthInTextElements: Integer): String; overload;
		property LengthInTextElements: Integer read _GetProp_LengthInTextElements;
		property &String: String read _GetProp_String write _SetProp_String;
	end;

	IStringNormalizationExtensionsClass = interface(ICoreClrClass)
	['{DF8112DF-183C-43F6-A679-F0F04730D114}']
	{ public }
		{ class } function IsNormalized(strInput: String): Boolean; overload;
		{ class } function IsNormalized(strInput: String; normalizationForm: TNormalizationForm): Boolean; overload;
		{ class } function Normalize(strInput: String): String; overload;
		{ class } function Normalize(strInput: String; normalizationForm: TNormalizationForm): String; overload;
	end;

	[CoreTypeSignature(SYSTEM_STRINGNORMALIZATIONEXTENSIONS)]
	IStringNormalizationExtensions = interface(IObject)
	['{CD92330A-8829-49E2-A7B7-1A3402E8AC1F}']
	end;

	[CoreTypeSignature(SYSTEM_IO_STRINGREADER)]
	IStringReader = interface(ITextReader)
	['{F4FE7258-18FB-4C5B-B8BB-FE4A60283DF9}']
	{ public }
		procedure Close();
		function Peek(): Integer;
		function Read(): Integer; overload;
		function Read(buffer: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Char>): Integer; overload;
		function ReadAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadBlock(buffer: ISpan<Char>): Integer;
		function ReadBlockAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask<Integer>; overload;
		function ReadBlockAsync(buffer: IMemory<Char>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadLine(): String;
		function ReadLineAsync(): ITask<String>;
		function ReadToEnd(): String;
		function ReadToEndAsync(): ITask<String>;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_STRINGRUNEENUMERATOR)]
	IStringRuneEnumerator = interface(IValueType)
	['{3CB47531-CAC8-4A0E-A529-EE6E70265D81}']
	{ private }
		function _GetProp_Current: IRune;
	{ public }
		function GetEnumerator(): IStringRuneEnumerator;
		function MoveNext(): Boolean;
		property Current: IRune read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_STRINGTOKEN)]
	IStringToken = interface(IValueType)
	['{E5C2DC22-3A15-421D-AC46-6E49845BC30D}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: IStringToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_IO_STRINGWRITER)]
	IStringWriter = interface(ITextWriter)
	['{FDDA8B9E-36D4-462A-9DD1-560ACD15FE5D}']
	{ private }
		function _GetProp_Encoding: IEncoding;
	{ public }
		procedure Close();
		function FlushAsync(): ITask;
		function GetStringBuilder(): IStringBuilder;
		procedure Write(value: Char); overload;
		procedure Write(buffer: IReadOnlySpan<Char>); overload;
		procedure Write(value: String); overload;
		procedure Write(value: IStringBuilder); overload;
		procedure Write(buffer: TArray<Char>; index: Integer; count: Integer); overload;
		function WriteAsync(value: Char): ITask; overload;
		function WriteAsync(value: String): ITask; overload;
		function WriteAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(value: IStringBuilder; cancellationToken: ICancellationToken): ITask; overload;
		procedure WriteLine(buffer: IReadOnlySpan<Char>); overload;
		procedure WriteLine(value: IStringBuilder); overload;
		function WriteLineAsync(value: Char): ITask; overload;
		function WriteLineAsync(value: String): ITask; overload;
		function WriteLineAsync(value: IStringBuilder; cancellationToken: ICancellationToken): ITask; overload;
		function WriteLineAsync(buffer: IReadOnlyMemory<Char>; cancellationToken: ICancellationToken): ITask; overload;
		function WriteLineAsync(buffer: TArray<Char>; index: Integer; count: Integer): ITask; overload;
		property Encoding: IEncoding read _GetProp_Encoding;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_STRONGBOX_1)]
	IStrongBox<T> = interface(IIStrongBox)
	['{9A1147C7-E102-430B-A216-AB5FDD736ADF}']
	{ private }
		function _GetFld_Value: T;
		procedure _SetFld_Value(Value: T);
	{ public }
		property Value: T read _GetFld_Value write _SetFld_Value;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_STRONGNAMEKEYPAIR)]
	IStrongNameKeyPair = interface(IObject)
	['{CC3722E5-D88D-4C4D-B6D0-6ADDFF758E55}']
	{ private }
		function _GetProp_PublicKey: TArray<Byte>;
	{ public }
		property PublicKey: TArray<Byte> read _GetProp_PublicKey;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_STRUCTLAYOUTATTRIBUTE)]
	IStructLayoutAttribute = interface(IAttribute)
	['{7915713A-9C44-45DC-8CE6-C3632AF40031}']
	{ private }
		function _GetFld_CharSet: TCharSet;
		procedure _SetFld_CharSet(Value: TCharSet);
		function _GetFld_Pack: Integer;
		procedure _SetFld_Pack(Value: Integer);
		function _GetFld_Size: Integer;
		procedure _SetFld_Size(Value: Integer);
		function _GetProp_Value: TLayoutKind;
	{ public }
		property CharSet: TCharSet read _GetFld_CharSet write _SetFld_CharSet;
		property Pack: Integer read _GetFld_Pack write _SetFld_Pack;
		property Size: Integer read _GetFld_Size write _SetFld_Size;
		property Value: TLayoutKind read _GetProp_Value;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_SUPPORTEDOSPLATFORMATTRIBUTE)]
	ISupportedOSPlatformAttribute = interface(IOSPlatformAttribute)
	['{4195C937-E42F-4032-92B7-3878083A0788}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_SUPPRESSGCTRANSITIONATTRIBUTE)]
	ISuppressGCTransitionAttribute = interface(IAttribute)
	['{73851B51-8869-4FF6-B31F-C3C19BD5E7A5}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_SUPPRESSILDASMATTRIBUTE)]
	ISuppressIldasmAttribute = interface(IAttribute)
	['{123D91BF-8130-4BDF-97E1-79170F228FC5}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_SUPPRESSMESSAGEATTRIBUTE)]
	ISuppressMessageAttribute = interface(IAttribute)
	['{B1BDA30E-974C-4566-AD4C-C3543C80FC2A}']
	{ private }
		function _GetProp_Category: String;
		function _GetProp_CheckId: String;
		function _GetProp_Justification: String;
		procedure _SetProp_Justification(Value: String);
		function _GetProp_MessageId: String;
		procedure _SetProp_MessageId(Value: String);
		function _GetProp_Scope: String;
		procedure _SetProp_Scope(Value: String);
		function _GetProp_Target: String;
		procedure _SetProp_Target(Value: String);
	{ public }
		property Category: String read _GetProp_Category;
		property CheckId: String read _GetProp_CheckId;
		property Justification: String read _GetProp_Justification write _SetProp_Justification;
		property MessageId: String read _GetProp_MessageId write _SetProp_MessageId;
		property Scope: String read _GetProp_Scope write _SetProp_Scope;
		property Target: String read _GetProp_Target write _SetProp_Target;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_SUPPRESSUNMANAGEDCODESECURITYATTRIBUTE)]
	ISuppressUnmanagedCodeSecurityAttribute = interface(IAttribute)
	['{C57E2BA7-EE96-4464-BC20-F2EA5FCD3A05}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_SWITCHEXPRESSIONEXCEPTION)]
	ISwitchExpressionException = interface(IInvalidOperationException)
	['{806CF97E-2E03-484A-98E1-DC5CDD9D2C00}']
	{ private }
		function _GetProp_Message: String;
		function _GetProp_UnmatchedValue: Variant;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property Message: String read _GetProp_Message;
		property UnmatchedValue: Variant read _GetProp_UnmatchedValue;
	end;

	ISynchronizationContextClass = interface(ICoreClrClass)
	['{45D0F9E0-F3C8-4F1E-98FC-BD38D3DBF6A7}']
	{ private }
		{ class } function _GetProp_Current: ISynchronizationContext;
	{ public }
		{ class } procedure SetSynchronizationContext(syncContext: ISynchronizationContext);
		{ class } property Current: ISynchronizationContext read _GetProp_Current;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SYNCHRONIZATIONCONTEXT)]
	ISynchronizationContext = interface(IObject)
	['{489389DB-1240-4DCA-A70E-995272AC6B53}']
	{ public }
		function CreateCopy(): ISynchronizationContext;
		function IsWaitNotificationRequired(): Boolean;
		procedure OperationCompleted();
		procedure OperationStarted();
		procedure Post(d: TSendOrPostCallback; state: Variant);
		procedure Send(d: TSendOrPostCallback; state: Variant);
		function Wait(waitHandles: ICoreClrBridgeArray<IIntPtr>; waitAll: Boolean; millisecondsTimeout: Integer): Integer;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_SYNCHRONIZATIONLOCKEXCEPTION)]
	ISynchronizationLockException = interface(ISystemException)
	['{4A4CA2DD-AD40-4DDB-A5B7-EF546905F5E0}']
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_TAIWANCALENDAR)]
	ITaiwanCalendar = interface(ICalendar)
	['{5810FA5C-C40C-429D-941F-3780E0BDD7D3}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetWeekOfYear(time: TDateTime; rule: TCalendarWeekRule; firstDayOfWeek: TDayOfWeek): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_TAIWANLUNISOLARCALENDAR)]
	ITaiwanLunisolarCalendar = interface(IEastAsianLunisolarCalendar)
	['{E7491D27-CE81-4AB8-90F2-8476BF4E8FA8}']
	{ private }
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_TARGETEDPATCHINGOPTOUTATTRIBUTE)]
	ITargetedPatchingOptOutAttribute = interface(IAttribute)
	['{9E5D3333-B850-4497-98C2-2AE866BF3D26}']
	{ private }
		function _GetProp_Reason: String;
	{ public }
		property Reason: String read _GetProp_Reason;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_TARGETEXCEPTION)]
	ITargetException = interface(IApplicationException)
	['{F0FC764F-3330-46E9-A774-ABEF676BF39A}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_TARGETFRAMEWORKATTRIBUTE)]
	ITargetFrameworkAttribute = interface(IAttribute)
	['{DCE4A2B1-11DE-4085-B1A1-CA46FC66EDB4}']
	{ private }
		function _GetProp_FrameworkDisplayName: String;
		procedure _SetProp_FrameworkDisplayName(Value: String);
		function _GetProp_FrameworkName: String;
	{ public }
		property FrameworkDisplayName: String read _GetProp_FrameworkDisplayName write _SetProp_FrameworkDisplayName;
		property FrameworkName: String read _GetProp_FrameworkName;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_TARGETINVOCATIONEXCEPTION)]
	ITargetInvocationException = interface(IApplicationException)
	['{9B8368E3-042F-4600-AAF9-B5CD5D578984}']
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_TARGETPARAMETERCOUNTEXCEPTION)]
	ITargetParameterCountException = interface(IApplicationException)
	['{1BD8ABAE-C448-43E7-AE27-5FDA893D0F89}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_TARGETPLATFORMATTRIBUTE)]
	ITargetPlatformAttribute = interface(IOSPlatformAttribute)
	['{B2ABFCB3-D9AF-443E-8E86-15DF78FB8B92}']
	end;

	ITaskClass = interface(ICoreClrClass)
	['{40D575D6-5146-4027-846C-CA4AF558ED05}']
	{ private }
		{ class } function _GetProp_CompletedTask: ITask;
		{ class } function _GetProp_CurrentId: Nullable<Integer>;
		{ class } function _GetProp_Factory: ITaskFactory;
	{ public }
		{ class } function Delay(delay: ITimeSpan): ITask; overload;
		{ class } function Delay(millisecondsDelay: Integer): ITask; overload;
		{ class } function Delay(delay: ITimeSpan; cancellationToken: ICancellationToken): ITask; overload;
		{ class } function Delay(millisecondsDelay: Integer; cancellationToken: ICancellationToken): ITask; overload;
		{ class } function FromCanceled(cancellationToken: ICancellationToken): ITask;
		{ class } function FromException(exception: IException): ITask;
		{ class } function FromResult(TResult: PTypeInfo; result_: Variant{TResult}): ITask<Variant{TResult}>;
		{ class } function Run(action: TClrAction): ITask; overload;
		{ class } function Run(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>): ITask<Variant{TResult}>; overload;
		{ class } function Run(function_: TClrFunc<ITask>): ITask; overload;
		{ class } function Run(TResult: PTypeInfo; function_: TClrFunc<ITask<Variant{TResult}>>): ITask<Variant{TResult}>; overload;
		{ class } function Run(action: TClrAction; cancellationToken: ICancellationToken): ITask; overload;
		{ class } function Run(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		{ class } function Run(function_: TClrFunc<ITask>; cancellationToken: ICancellationToken): ITask; overload;
		{ class } function Run(TResult: PTypeInfo; function_: TClrFunc<ITask<Variant{TResult}>>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		{ class } procedure WaitAll(tasks: ICoreClrBridgeArray<ITask>); overload;
		{ class } function WaitAll(tasks: ICoreClrBridgeArray<ITask>; timeout: ITimeSpan): Boolean; overload;
		{ class } function WaitAll(tasks: ICoreClrBridgeArray<ITask>; millisecondsTimeout: Integer): Boolean; overload;
		{ class } procedure WaitAll(tasks: ICoreClrBridgeArray<ITask>; cancellationToken: ICancellationToken); overload;
		{ class } function WaitAll(tasks: ICoreClrBridgeArray<ITask>; millisecondsTimeout: Integer; cancellationToken: ICancellationToken): Boolean; overload;
		{ class } function WaitAny(tasks: ICoreClrBridgeArray<ITask>): Integer; overload;
		{ class } function WaitAny(tasks: ICoreClrBridgeArray<ITask>; timeout: ITimeSpan): Integer; overload;
		{ class } function WaitAny(tasks: ICoreClrBridgeArray<ITask>; cancellationToken: ICancellationToken): Integer; overload;
		{ class } function WaitAny(tasks: ICoreClrBridgeArray<ITask>; millisecondsTimeout: Integer): Integer; overload;
		{ class } function WaitAny(tasks: ICoreClrBridgeArray<ITask>; millisecondsTimeout: Integer; cancellationToken: ICancellationToken): Integer; overload;
		{ class } function WhenAll(tasks: IIEnumerable<ITask>): ITask; overload;
		{ class } function WhenAll(tasks: ICoreClrBridgeArray<ITask>): ITask; overload;
		{ class } function WhenAll(TResult: PTypeInfo; tasks: IIEnumerable<ITask<Variant{TResult}>>): ITask<ICoreClrBridgeArray<Variant{TResult}>>; overload;
		{ class } function WhenAll(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TResult}>>): ITask<ICoreClrBridgeArray<Variant{TResult}>>; overload;
		{ class } function WhenAny(tasks: ICoreClrBridgeArray<ITask>): ITask<ITask>; overload;
		{ class } function WhenAny(tasks: IIEnumerable<ITask>): ITask<ITask>; overload;
		{ class } function WhenAny(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TResult}>>): ITask<ITask<Variant{TResult}>>; overload;
		{ class } function WhenAny(TResult: PTypeInfo; tasks: IIEnumerable<ITask<Variant{TResult}>>): ITask<ITask<Variant{TResult}>>; overload;
		{ class } function WhenAny(task1: ITask; task2: ITask): ITask<ITask>; overload;
		{ class } function WhenAny(TResult: PTypeInfo; task1: ITask<Variant{TResult}>; task2: ITask<Variant{TResult}>): ITask<ITask<Variant{TResult}>>; overload;
		{ class } function Yield(): IYieldAwaitable;
		{ class } property CompletedTask: ITask read _GetProp_CompletedTask;
		{ class } property CurrentId: Nullable<Integer> read _GetProp_CurrentId;
		{ class } property Factory: ITaskFactory read _GetProp_Factory;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASK)]
	ITask = interface(IObject)
	['{82E74932-B2AE-4E9F-86AF-72E17C1C1758}']
	{ private }
		function _GetProp_AsyncState: Variant;
		function _GetProp_CreationOptions: TTaskCreationOptions_Set;
		function _GetProp_Exception: IAggregateException;
		function _GetProp_Id: Integer;
		function _GetProp_IsCanceled: Boolean;
		function _GetProp_IsCompleted: Boolean;
		function _GetProp_IsCompletedSuccessfully: Boolean;
		function _GetProp_IsFaulted: Boolean;
		function _GetProp_Status: TTaskStatus;
	{ public }
		function ConfigureAwait(continueOnCapturedContext: Boolean): IConfiguredTaskAwaitable;
		function ContinueWith(continuationAction: TClrAction<ITask>): ITask; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask>; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask, Variant>; state: Variant): ITask; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant{TResult}>; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant{TResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant, Variant{TResult}>; state: Variant): ITask<Variant{TResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant{TResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask, Variant>; state: Variant; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask, Variant>; state: Variant; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask, Variant>; state: Variant; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant, Variant{TResult}>; state: Variant; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant, Variant{TResult}>; state: Variant; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant, Variant{TResult}>; state: Variant; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask, Variant>; state: Variant; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(TResult: PTypeInfo; continuationFunction: TClrFunc<ITask, Variant, Variant{TResult}>; state: Variant; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		procedure Dispose();
		function GetAwaiter(): ITaskAwaiter;
		procedure RunSynchronously(); overload;
		procedure RunSynchronously(scheduler: ITaskScheduler); overload;
		procedure Start(); overload;
		procedure Start(scheduler: ITaskScheduler); overload;
		procedure Wait(); overload;
		function Wait(timeout: ITimeSpan): Boolean; overload;
		procedure Wait(cancellationToken: ICancellationToken); overload;
		function Wait(millisecondsTimeout: Integer): Boolean; overload;
		function Wait(millisecondsTimeout: Integer; cancellationToken: ICancellationToken): Boolean; overload;
		property AsyncState: Variant read _GetProp_AsyncState;
		property CreationOptions: TTaskCreationOptions_Set read _GetProp_CreationOptions;
		property Exception: IAggregateException read _GetProp_Exception;
		property Id: Integer read _GetProp_Id;
		property IsCanceled: Boolean read _GetProp_IsCanceled;
		property IsCompleted: Boolean read _GetProp_IsCompleted;
		property IsCompletedSuccessfully: Boolean read _GetProp_IsCompletedSuccessfully;
		property IsFaulted: Boolean read _GetProp_IsFaulted;
		property Status: TTaskStatus read _GetProp_Status;
	end;

	ITaskClass<TResult> = interface(ICoreClrClass)
	['{D02BF4E6-F320-49C7-86F0-A0B89489AA72}']
	{ private }
		{ class } function _GetProp_Factory: ITaskFactory<TResult>;
	{ public }
		{ class } property Factory: ITaskFactory<TResult> read _GetProp_Factory;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASK_1)]
	ITask<TResult> = interface(ITask)
	['{34792002-2157-4BA0-8E10-93959E31515D}']
	{ private }
		function _GetProp_Result: TResult;
	{ public }
		function ConfigureAwait(continueOnCapturedContext: Boolean): IConfiguredTaskAwaitable<TResult>;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>>): ITask; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant{TNewResult}>): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>>; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>, Variant>; state: Variant): ITask; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant{TNewResult}>; cancellationToken: ICancellationToken): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant{TNewResult}>; scheduler: ITaskScheduler): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant{TNewResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant, Variant{TNewResult}>; state: Variant): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant{TNewResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>, Variant>; state: Variant; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>, Variant>; state: Variant; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>, Variant>; state: Variant; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant, Variant{TNewResult}>; state: Variant; cancellationToken: ICancellationToken): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant, Variant{TNewResult}>; state: Variant; scheduler: ITaskScheduler): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant, Variant{TNewResult}>; state: Variant; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TNewResult}>; overload;
		function ContinueWith(continuationAction: TClrAction<ITask<TResult>, Variant>; state: Variant; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWith(TNewResult: PTypeInfo; continuationFunction: TClrFunc<ITask<TResult>, Variant, Variant{TNewResult}>; state: Variant; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TNewResult}>; overload;
		function GetAwaiter(): ITaskAwaiter<TResult>;
		property &Result: TResult read _GetProp_Result;
	end;

	ITaskAsyncEnumerableExtensionsClass = interface(ICoreClrClass)
	['{40D0C192-9F3E-48AD-98CB-D98A645C0444}']
	{ public }
		{ class } function ConfigureAwait(source: IIAsyncDisposable; continueOnCapturedContext: Boolean): IConfiguredAsyncDisposable; overload;
		{ class } function ConfigureAwait(T: PTypeInfo; source: IIAsyncEnumerable<Variant{T}>; continueOnCapturedContext: Boolean): IConfiguredCancelableAsyncEnumerable<Variant{T}>; overload;
		{ class } function WithCancellation(T: PTypeInfo; source: IIAsyncEnumerable<Variant{T}>; cancellationToken: ICancellationToken): IConfiguredCancelableAsyncEnumerable<Variant{T}>;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKASYNCENUMERABLEEXTENSIONS)]
	ITaskAsyncEnumerableExtensions = interface(IObject)
	['{C6BA1CD9-7B5F-434C-8E15-C2B2630DD341}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_TASKAWAITER)]
	ITaskAwaiter = interface(IValueType)
	['{4135BDEA-4EFD-43F0-989C-04B47C871390}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		procedure GetResult();
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_TASKAWAITER_1)]
	ITaskAwaiter<TResult> = interface(IValueType)
	['{A73445CB-07C7-4F55-9AC1-C67CCBCB57D9}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		function GetResult(): TResult;
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKCANCELEDEXCEPTION)]
	ITaskCanceledException = interface(IOperationCanceledException)
	['{45CB704C-6964-4FC0-AF2E-5C367E3F4250}']
	{ private }
		function _GetProp_Task: ITask;
	{ public }
		property Task: ITask read _GetProp_Task;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKCOMPLETIONSOURCE)]
	ITaskCompletionSource = interface(IObject)
	['{2F86220D-9CF5-4BB4-B25E-FCDB6FCCB837}']
	{ private }
		function _GetProp_Task: ITask;
	{ public }
		procedure SetCanceled(); overload;
		procedure SetCanceled(cancellationToken: ICancellationToken); overload;
		procedure SetException(exception: IException); overload;
		procedure SetException(exceptions: IIEnumerable<IException>); overload;
		procedure SetResult();
		function TrySetCanceled(): Boolean; overload;
		function TrySetCanceled(cancellationToken: ICancellationToken): Boolean; overload;
		function TrySetException(exception: IException): Boolean; overload;
		function TrySetException(exceptions: IIEnumerable<IException>): Boolean; overload;
		function TrySetResult(): Boolean;
		property Task: ITask read _GetProp_Task;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKCOMPLETIONSOURCE_1)]
	ITaskCompletionSource<TResult> = interface(IObject)
	['{76ABBCBF-A00E-40A1-B930-568E65D2318E}']
	{ private }
		function _GetProp_Task: ITask<TResult>;
	{ public }
		procedure SetCanceled(); overload;
		procedure SetCanceled(cancellationToken: ICancellationToken); overload;
		procedure SetException(exception: IException); overload;
		procedure SetException(exceptions: IIEnumerable<IException>); overload;
		procedure SetResult(result_: TResult);
		function TrySetCanceled(): Boolean; overload;
		function TrySetCanceled(cancellationToken: ICancellationToken): Boolean; overload;
		function TrySetException(exception: IException): Boolean; overload;
		function TrySetException(exceptions: IIEnumerable<IException>): Boolean; overload;
		function TrySetResult(result_: TResult): Boolean;
		property Task: ITask<TResult> read _GetProp_Task;
	end;

	ITaskExtensionsClass = interface(ICoreClrClass)
	['{B939FFDC-0841-4703-B9D6-514023BC5B74}']
	{ public }
		{ class } function Unwrap(task: ITask<ITask>): ITask; overload;
		{ class } function Unwrap(TResult: PTypeInfo; task: ITask<ITask<Variant{TResult}>>): ITask<Variant{TResult}>; overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKEXTENSIONS)]
	ITaskExtensions = interface(IObject)
	['{03DA8CBE-CD6C-4C0D-AF1B-88138B227F1A}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKFACTORY)]
	ITaskFactory = interface(IObject)
	['{579B7875-31EC-4D19-9C41-23888BBA74A2}']
	{ private }
		function _GetProp_CancellationToken: ICancellationToken;
		function _GetProp_ContinuationOptions: TTaskContinuationOptions_Set;
		function _GetProp_CreationOptions: TTaskCreationOptions_Set;
		function _GetProp_Scheduler: ITaskScheduler;
	{ public }
		function ContinueWhenAll(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, Variant{TResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, Variant{TResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask>>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask>>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWhenAll(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, Variant{TResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, Variant{TResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask>>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask>>): ITask; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>>): ITask; overload;
		function ContinueWhenAll(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ITask>): ITask; overload;
		function ContinueWhenAny(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ITask<Variant{TAntecedentResult}>>): ITask; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ITask>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ITask>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWhenAny(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, Variant{TResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, Variant{TResult}>; continuationOptions: TTaskContinuationOptions_Set): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ITask<Variant{TAntecedentResult}>>; cancellationToken: ICancellationToken): ITask; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ITask<Variant{TAntecedentResult}>>; continuationOptions: TTaskContinuationOptions_Set): ITask; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationAction: TClrAction<ITask>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function ContinueWhenAny(TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, Variant{TResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; TResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, Variant{TResult}>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationAction: TClrAction<ITask<Variant{TAntecedentResult}>>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrAction<IIAsyncResult>): ITask; overload;
		function FromAsync(TResult: PTypeInfo; asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrAction<IIAsyncResult>; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function FromAsync(beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; state: Variant): ITask; overload;
		function FromAsync(TResult: PTypeInfo; asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function FromAsync(TResult: PTypeInfo; beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; state: Variant): ITask<Variant{TResult}>; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrAction<IIAsyncResult>; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function FromAsync(beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; state: Variant): ITask; overload;
		function FromAsync(TResult: PTypeInfo; asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function FromAsync(TResult: PTypeInfo; beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; state: Variant): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant): ITask<Variant{TResult}>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrAction<IIAsyncResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; TResult: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, Variant{TResult}>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function StartNew(action: TClrAction): ITask; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>): ITask<Variant{TResult}>; overload;
		function StartNew(action: TClrAction; cancellationToken: ICancellationToken): ITask; overload;
		function StartNew(action: TClrAction; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function StartNew(action: TClrAction<Variant>; state: Variant): ITask; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant, Variant{TResult}>; state: Variant): ITask<Variant{TResult}>; overload;
		function StartNew(action: TClrAction; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant{TResult}>; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		function StartNew(action: TClrAction<Variant>; state: Variant; cancellationToken: ICancellationToken): ITask; overload;
		function StartNew(action: TClrAction<Variant>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant, Variant{TResult}>; state: Variant; cancellationToken: ICancellationToken): ITask<Variant{TResult}>; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant, Variant{TResult}>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<Variant{TResult}>; overload;
		function StartNew(action: TClrAction<Variant>; state: Variant; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask; overload;
		function StartNew(TResult: PTypeInfo; function_: TClrFunc<Variant, Variant{TResult}>; state: Variant; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<Variant{TResult}>; overload;
		property CancellationToken: ICancellationToken read _GetProp_CancellationToken;
		property ContinuationOptions: TTaskContinuationOptions_Set read _GetProp_ContinuationOptions;
		property CreationOptions: TTaskCreationOptions_Set read _GetProp_CreationOptions;
		property Scheduler: ITaskScheduler read _GetProp_Scheduler;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKFACTORY_1)]
	ITaskFactory<TResult> = interface(IObject)
	['{3269A4F5-50B4-4A03-AE50-842E74D3BC04}']
	{ private }
		function _GetProp_CancellationToken: ICancellationToken;
		function _GetProp_ContinuationOptions: TTaskContinuationOptions_Set;
		function _GetProp_CreationOptions: TTaskCreationOptions_Set;
		function _GetProp_Scheduler: ITaskScheduler;
	{ public }
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, TResult>): ITask<TResult>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, TResult>): ITask<TResult>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, TResult>; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, TResult>; continuationOptions: TTaskContinuationOptions_Set): ITask<TResult>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, TResult>; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, TResult>; continuationOptions: TTaskContinuationOptions_Set): ITask<TResult>; overload;
		function ContinueWhenAll(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask>, TResult>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function ContinueWhenAll(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>, TResult>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, TResult>): ITask<TResult>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, TResult>): ITask<TResult>; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, TResult>; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, TResult>; continuationOptions: TTaskContinuationOptions_Set): ITask<TResult>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, TResult>; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, TResult>; continuationOptions: TTaskContinuationOptions_Set): ITask<TResult>; overload;
		function ContinueWhenAny(tasks: ICoreClrBridgeArray<ITask>; continuationFunction: TClrFunc<ITask, TResult>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function ContinueWhenAny(TAntecedentResult: PTypeInfo; tasks: ICoreClrBridgeArray<ITask<Variant{TAntecedentResult}>>; continuationFunction: TClrFunc<ITask<Variant{TAntecedentResult}>, TResult>; cancellationToken: ICancellationToken; continuationOptions: TTaskContinuationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, TResult>): ITask<TResult>; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, TResult>; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function FromAsync(beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; state: Variant): ITask<TResult>; overload;
		function FromAsync(asyncResult: IIAsyncResult; endMethod: TClrFunc<IIAsyncResult, TResult>; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function FromAsync(beginMethod: TClrFunc<TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; state: Variant): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant): ITask<TResult>; overload;
		function FromAsync(TArg1: PTypeInfo; TArg2: PTypeInfo; TArg3: PTypeInfo; beginMethod: TClrFunc<Variant{TArg1}, Variant{TArg2}, Variant{TArg3}, TAsyncCallback, Variant, IIAsyncResult>; endMethod: TClrFunc<IIAsyncResult, TResult>; arg1: Variant{TArg1}; arg2: Variant{TArg2}; arg3: Variant{TArg3}; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<TResult>): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<TResult>; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<TResult>; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<Variant, TResult>; state: Variant): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<TResult>; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<Variant, TResult>; state: Variant; cancellationToken: ICancellationToken): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<Variant, TResult>; state: Variant; creationOptions: TTaskCreationOptions_Set): ITask<TResult>; overload;
		function StartNew(function_: TClrFunc<Variant, TResult>; state: Variant; cancellationToken: ICancellationToken; creationOptions: TTaskCreationOptions_Set; scheduler: ITaskScheduler): ITask<TResult>; overload;
		property CancellationToken: ICancellationToken read _GetProp_CancellationToken;
		property ContinuationOptions: TTaskContinuationOptions_Set read _GetProp_ContinuationOptions;
		property CreationOptions: TTaskCreationOptions_Set read _GetProp_CreationOptions;
		property Scheduler: ITaskScheduler read _GetProp_Scheduler;
	end;

	ITasksClass = interface(ICoreClrClass)
	['{5BDAF2C6-2BA2-44A6-B464-A216F386ABCC}']
	{ private }
		{ class } function _GetFld_AwaitTaskContinuationScheduled: TEventTask;
		{ class } function _GetFld_ForkJoin: TEventTask;
		{ class } function _GetFld_Invoke: TEventTask;
		{ class } function _GetFld_Loop: TEventTask;
		{ class } function _GetFld_TaskExecute: TEventTask;
		{ class } function _GetFld_TaskScheduled: TEventTask;
		{ class } function _GetFld_TaskWait: TEventTask;
		{ class } function _GetFld_TraceOperation: TEventTask;
		{ class } function _GetFld_TraceSynchronousWork: TEventTask;
	{ public }
		{ class } property AwaitTaskContinuationScheduled: TEventTask read _GetFld_AwaitTaskContinuationScheduled;
		{ class } property ForkJoin: TEventTask read _GetFld_ForkJoin;
		{ class } property Invoke: TEventTask read _GetFld_Invoke;
		{ class } property Loop: TEventTask read _GetFld_Loop;
		{ class } property TaskExecute: TEventTask read _GetFld_TaskExecute;
		{ class } property TaskScheduled: TEventTask read _GetFld_TaskScheduled;
		{ class } property TaskWait: TEventTask read _GetFld_TaskWait;
		{ class } property TraceOperation: TEventTask read _GetFld_TraceOperation;
		{ class } property TraceSynchronousWork: TEventTask read _GetFld_TraceSynchronousWork;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKS)]
	ITasks = interface(IObject)
	['{53473CFE-6650-4135-A40C-E9AEDCB6D556}']
	end;

	ITasks_1Class = interface(ICoreClrClass)
	['{F7206A3A-8449-4858-AABE-981269CA6162}']
	{ private }
		{ class } function _GetFld_ThreadTransfer: TEventTask;
	{ public }
		{ class } property ThreadTransfer: TEventTask read _GetFld_ThreadTransfer;
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_TASKS)]
	ITasks_1 = interface(IObject)
	['{BD080549-5BA9-4FF7-832C-EFAC58C7F05C}']
	end;

	ITaskSchedulerClass = interface(ICoreClrClass)
	['{29659223-2EB5-45CF-B689-A828456E3A44}']
	{ private }
		{ class } function _GetProp_Current: ITaskScheduler;
		{ class } function _GetProp_Default: ITaskScheduler;
		{ class } function _GetEvt_UnobservedTaskException: TEventHandler<IUnobservedTaskExceptionEventArgs>;
		{ class } procedure _SetEvt_UnobservedTaskException(Value: TEventHandler<IUnobservedTaskExceptionEventArgs>);
	{ public }
		{ class } function FromCurrentSynchronizationContext(): ITaskScheduler;
		{ class } property Current: ITaskScheduler read _GetProp_Current;
		{ class } property &Default: ITaskScheduler read _GetProp_Default;
		{ class } property UnobservedTaskException: TEventHandler<IUnobservedTaskExceptionEventArgs> read _GetEvt_UnobservedTaskException write _SetEvt_UnobservedTaskException;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKSCHEDULER)]
	ITaskScheduler = interface(IObject)
	['{0BCBFD4A-AE92-40E6-84C9-8F360A30B8BA}']
	{ private }
		function _GetProp_Id: Integer;
		function _GetProp_MaximumConcurrencyLevel: Integer;
	{ public }
		property Id: Integer read _GetProp_Id;
		property MaximumConcurrencyLevel: Integer read _GetProp_MaximumConcurrencyLevel;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_TASKSCHEDULEREXCEPTION)]
	ITaskSchedulerException = interface(IException)
	['{B91D9964-8D54-4E6F-8CE5-36A2E5BA2902}']
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_TEXTELEMENTENUMERATOR)]
	ITextElementEnumerator = interface(IIEnumerator)
	['{5E976BF3-F38E-497F-AD07-033D48600803}']
	{ private }
		function _GetProp_Current: Variant;
		function _GetProp_ElementIndex: Integer;
	{ public }
		function GetTextElement(): String;
		function MoveNext(): Boolean;
		procedure Reset();
		property Current: Variant read _GetProp_Current;
		property ElementIndex: Integer read _GetProp_ElementIndex;
	end;

	ITextInfoClass = interface(ICoreClrClass)
	['{57ED19DB-CD3A-4C7C-A1A3-7FDA49117ECE}']
	{ public }
		{ class } function &ReadOnly(textInfo: ITextInfo): ITextInfo;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_TEXTINFO)]
	ITextInfo = interface(IObject)
	['{99E8BEB5-BBDE-4604-A3B7-BB1E5BBFDD51}']
	{ private }
		function _GetProp_ANSICodePage: Integer;
		function _GetProp_CultureName: String;
		function _GetProp_EBCDICCodePage: Integer;
		function _GetProp_IsReadOnly: Boolean;
		function _GetProp_IsRightToLeft: Boolean;
		function _GetProp_LCID: Integer;
		function _GetProp_ListSeparator: String;
		procedure _SetProp_ListSeparator(Value: String);
		function _GetProp_MacCodePage: Integer;
		function _GetProp_OEMCodePage: Integer;
	{ public }
		function Clone(): Variant;
		function ToLower(c: Char): Char; overload;
		function ToLower(str: String): String; overload;
		function ToTitleCase(str: String): String;
		function ToUpper(c: Char): Char; overload;
		function ToUpper(str: String): String; overload;
		property ANSICodePage: Integer read _GetProp_ANSICodePage;
		property CultureName: String read _GetProp_CultureName;
		property EBCDICCodePage: Integer read _GetProp_EBCDICCodePage;
		property IsReadOnly: Boolean read _GetProp_IsReadOnly;
		property IsRightToLeft: Boolean read _GetProp_IsRightToLeft;
		property LCID: Integer read _GetProp_LCID;
		property ListSeparator: String read _GetProp_ListSeparator write _SetProp_ListSeparator;
		property MacCodePage: Integer read _GetProp_MacCodePage;
		property OEMCodePage: Integer read _GetProp_OEMCodePage;
	end;

	IThaiBuddhistCalendarClass = interface(ICoreClrClass)
	['{C3CF8ECC-9B83-431C-8EDC-236D38019A4C}']
	{ private }
		{ class } function _GetFld_ThaiBuddhistEra: Integer;
	{ public }
		{ class } property ThaiBuddhistEra: Integer read _GetFld_ThaiBuddhistEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_THAIBUDDHISTCALENDAR)]
	IThaiBuddhistCalendar = interface(ICalendar)
	['{60CC09BA-021E-48A5-9F17-DC29C203FAAF}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetWeekOfYear(time: TDateTime; rule: TCalendarWeekRule; firstDayOfWeek: TDayOfWeek): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	IThreadClass = interface(ICoreClrClass)
	['{37A0C67D-CE7C-484E-A20A-3621C0897231}']
	{ private }
		{ class } function _GetProp_CurrentPrincipal: IIPrincipal;
		{ class } procedure _SetProp_CurrentPrincipal(Value: IIPrincipal);
		{ class } function _GetProp_CurrentThread: IThread;
	{ public }
		{ class } function AllocateDataSlot(): ILocalDataStoreSlot;
		{ class } function AllocateNamedDataSlot(name: String): ILocalDataStoreSlot;
		{ class } procedure BeginCriticalRegion();
		{ class } procedure BeginThreadAffinity();
		{ class } procedure EndCriticalRegion();
		{ class } procedure EndThreadAffinity();
		{ class } procedure FreeNamedDataSlot(name: String);
		{ class } function GetCurrentProcessorId(): Integer;
		{ class } function GetData(slot: ILocalDataStoreSlot): Variant;
		{ class } function GetDomain(): IAppDomain;
		{ class } function GetDomainID(): Integer;
		{ class } function GetNamedDataSlot(name: String): ILocalDataStoreSlot;
		{ class } procedure MemoryBarrier();
		{ class } procedure ResetAbort();
		{ class } procedure SetData(slot: ILocalDataStoreSlot; data: Variant);
		{ class } procedure Sleep(timeout: ITimeSpan); overload;
		{ class } procedure Sleep(millisecondsTimeout: Integer); overload;
		{ class } procedure SpinWait(iterations: Integer);
		{ class } function VolatileRead(var address: Byte): Byte; overload;
		{ class } function VolatileRead(var address: Double): Double; overload;
		{ class } function VolatileRead(var address: SmallInt): SmallInt; overload;
		{ class } function VolatileRead(var address: Integer): Integer; overload;
		{ class } function VolatileRead(var address: Int64): Int64; overload;
		{ class } function VolatileRead(var address: IIntPtr): IIntPtr; overload;
		{ class } function VolatileRead(var address: Variant): Variant; overload;
		{ class } function VolatileRead(var address: Shortint): Shortint; overload;
		{ class } function VolatileRead(var address: Single): Single; overload;
		{ class } function VolatileRead(var address: Word): Word; overload;
		{ class } function VolatileRead(var address: longword): longword; overload;
		{ class } function VolatileRead(var address: UInt64): UInt64; overload;
		{ class } function VolatileRead(var address: IUIntPtr): IUIntPtr; overload;
		{ class } procedure VolatileWrite(var address: Byte; value: Byte); overload;
		{ class } procedure VolatileWrite(var address: Double; value: Double); overload;
		{ class } procedure VolatileWrite(var address: SmallInt; value: SmallInt); overload;
		{ class } procedure VolatileWrite(var address: Integer; value: Integer); overload;
		{ class } procedure VolatileWrite(var address: Int64; value: Int64); overload;
		{ class } procedure VolatileWrite(var address: IIntPtr; value: IIntPtr); overload;
		{ class } procedure VolatileWrite(var address: Variant; value: Variant); overload;
		{ class } procedure VolatileWrite(var address: Shortint; value: Shortint); overload;
		{ class } procedure VolatileWrite(var address: Single; value: Single); overload;
		{ class } procedure VolatileWrite(var address: Word; value: Word); overload;
		{ class } procedure VolatileWrite(var address: longword; value: longword); overload;
		{ class } procedure VolatileWrite(var address: UInt64; value: UInt64); overload;
		{ class } procedure VolatileWrite(var address: IUIntPtr; value: IUIntPtr); overload;
		{ class } function Yield(): Boolean;
		{ class } property CurrentPrincipal: IIPrincipal read _GetProp_CurrentPrincipal write _SetProp_CurrentPrincipal;
		{ class } property CurrentThread: IThread read _GetProp_CurrentThread;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREAD)]
	IThread = interface(ICriticalFinalizerObject)
	['{C41BC899-B160-48BF-8978-B20B6C71CE9C}']
	{ private }
		function _GetProp_ApartmentState: TApartmentState;
		procedure _SetProp_ApartmentState(Value: TApartmentState);
		function _GetProp_CurrentCulture: ICultureInfo;
		procedure _SetProp_CurrentCulture(Value: ICultureInfo);
		function _GetProp_CurrentUICulture: ICultureInfo;
		procedure _SetProp_CurrentUICulture(Value: ICultureInfo);
		function _GetProp_ExecutionContext: IExecutionContext;
		function _GetProp_IsAlive: Boolean;
		function _GetProp_IsBackground: Boolean;
		procedure _SetProp_IsBackground(Value: Boolean);
		function _GetProp_IsThreadPoolThread: Boolean;
		function _GetProp_ManagedThreadId: Integer;
		function _GetProp_Name: String;
		procedure _SetProp_Name(Value: String);
		function _GetProp_Priority: TThreadPriority;
		procedure _SetProp_Priority(Value: TThreadPriority);
		function _GetProp_ThreadState: TThreadState_Set;
	{ public }
		procedure Abort(); overload;
		procedure Abort(stateInfo: Variant); overload;
		procedure DisableComObjectEagerCleanup();
		function GetApartmentState(): TApartmentState;
		function GetCompressedStack(): ICompressedStack;
		procedure Interrupt();
		procedure Join(); overload;
		function Join(timeout: ITimeSpan): Boolean; overload;
		function Join(millisecondsTimeout: Integer): Boolean; overload;
		procedure Resume();
		procedure SetApartmentState(state: TApartmentState);
		procedure SetCompressedStack(stack: ICompressedStack);
		procedure Start(parameter: Variant); overload;
		procedure Start(); overload;
		procedure Suspend();
		function TrySetApartmentState(state: TApartmentState): Boolean;
		property ApartmentState: TApartmentState read _GetProp_ApartmentState write _SetProp_ApartmentState;
		property CurrentCulture: ICultureInfo read _GetProp_CurrentCulture write _SetProp_CurrentCulture;
		property CurrentUICulture: ICultureInfo read _GetProp_CurrentUICulture write _SetProp_CurrentUICulture;
		property ExecutionContext: IExecutionContext read _GetProp_ExecutionContext;
		property IsAlive: Boolean read _GetProp_IsAlive;
		property IsBackground: Boolean read _GetProp_IsBackground write _SetProp_IsBackground;
		property IsThreadPoolThread: Boolean read _GetProp_IsThreadPoolThread;
		property ManagedThreadId: Integer read _GetProp_ManagedThreadId;
		property Name: String read _GetProp_Name write _SetProp_Name;
		property Priority: TThreadPriority read _GetProp_Priority write _SetProp_Priority;
		property ThreadState: TThreadState_Set read _GetProp_ThreadState;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADABORTEXCEPTION)]
	IThreadAbortException = interface(ISystemException)
	['{51B3E689-D208-4E7C-A6FC-19B664AEB4EB}']
	{ private }
		function _GetProp_ExceptionState: Variant;
	{ public }
		property ExceptionState: Variant read _GetProp_ExceptionState;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADEXCEPTIONEVENTARGS)]
	IThreadExceptionEventArgs = interface(IEventArgs)
	['{01650407-097E-4EC4-A7CB-295F7E684A01}']
	{ private }
		function _GetProp_Exception: IException;
	{ public }
		property Exception: IException read _GetProp_Exception;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADINTERRUPTEDEXCEPTION)]
	IThreadInterruptedException = interface(ISystemException)
	['{7BC11771-B2C3-4607-9F27-D75497B5DF39}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADLOCAL_1)]
	IThreadLocal<T> = interface(IIDisposable)
	['{9D7C250B-9B64-4C88-8279-48F2FE289D1D}']
	{ private }
		function _GetProp_IsValueCreated: Boolean;
		function _GetProp_Value: T;
		procedure _SetProp_Value(Value: T);
		function _GetProp_Values: IIList<T>;
	{ public }
		procedure Dispose();
		property IsValueCreated: Boolean read _GetProp_IsValueCreated;
		property Value: T read _GetProp_Value write _SetProp_Value;
		property Values: IIList<T> read _GetProp_Values;
	end;

	IThreadPoolClass = interface(ICoreClrClass)
	['{FB297239-B844-4126-AD32-6057C952538A}']
	{ private }
		{ class } function _GetProp_CompletedWorkItemCount: Int64;
		{ class } function _GetProp_PendingWorkItemCount: Int64;
		{ class } function _GetProp_ThreadCount: Integer;
	{ public }
		{ class } function BindHandle(osHandle: IIntPtr): Boolean; overload;
		{ class } function BindHandle(osHandle: ISafeHandle): Boolean; overload;
		{ class } procedure GetAvailableThreads(var workerThreads: Integer; var completionPortThreads: Integer);
		{ class } procedure GetMaxThreads(var workerThreads: Integer; var completionPortThreads: Integer);
		{ class } procedure GetMinThreads(var workerThreads: Integer; var completionPortThreads: Integer);
		{ class } function QueueUserWorkItem(callBack: TWaitCallback): Boolean; overload;
		{ class } function QueueUserWorkItem(callBack: TWaitCallback; state: Variant): Boolean; overload;
		{ class } function QueueUserWorkItem(TState: PTypeInfo; callBack: TClrAction<Variant{TState}>; state: Variant{TState}; preferLocal: Boolean): Boolean; overload;
		{ class } function RegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: longword; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function RegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: Integer; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function RegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: Int64; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function RegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; timeout: ITimeSpan; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function SetMaxThreads(workerThreads: Integer; completionPortThreads: Integer): Boolean;
		{ class } function SetMinThreads(workerThreads: Integer; completionPortThreads: Integer): Boolean;
		{ class } function UnsafeQueueNativeOverlapped(overlapped: ICoreClrInstance): Boolean;
		{ class } function UnsafeQueueUserWorkItem(TState: PTypeInfo; callBack: TClrAction<Variant{TState}>; state: Variant{TState}; preferLocal: Boolean): Boolean; overload;
		{ class } function UnsafeQueueUserWorkItem(callBack: TWaitCallback; state: Variant): Boolean; overload;
		{ class } function UnsafeQueueUserWorkItem(callBack: IIThreadPoolWorkItem; preferLocal: Boolean): Boolean; overload;
		{ class } function UnsafeRegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: longword; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function UnsafeRegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: Integer; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function UnsafeRegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; millisecondsTimeOutInterval: Int64; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } function UnsafeRegisterWaitForSingleObject(waitObject: IWaitHandle; callBack: TWaitOrTimerCallback; state: Variant; timeout: ITimeSpan; executeOnlyOnce: Boolean): IRegisteredWaitHandle; overload;
		{ class } property CompletedWorkItemCount: Int64 read _GetProp_CompletedWorkItemCount;
		{ class } property PendingWorkItemCount: Int64 read _GetProp_PendingWorkItemCount;
		{ class } property ThreadCount: Integer read _GetProp_ThreadCount;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADPOOL)]
	IThreadPool = interface(IObject)
	['{39F60C91-0AA1-451C-ACDE-5386AFA6A670}']
	end;

	IThreadPoolBoundHandleClass = interface(ICoreClrClass)
	['{55E8D312-C2E7-40F0-975A-7E6793364961}']
	{ public }
		{ class } function BindHandle(handle: ISafeHandle): IThreadPoolBoundHandle;
		{ class } function GetNativeOverlappedState(overlapped: ICoreClrInstance): Variant;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADPOOLBOUNDHANDLE)]
	IThreadPoolBoundHandle = interface(IIDisposable)
	['{A704E325-A491-44C0-AE4E-7A3FF62DD9A5}']
	{ private }
		function _GetProp_Handle: ISafeHandle;
	{ public }
		function AllocateNativeOverlapped(callback: TIOCompletionCallback; state: Variant; pinData: Variant): ICoreClrInstance; overload;
		function AllocateNativeOverlapped(preAllocated: IPreAllocatedOverlapped): ICoreClrInstance; overload;
		procedure Dispose();
		procedure FreeNativeOverlapped(overlapped: ICoreClrInstance);
		property Handle: ISafeHandle read _GetProp_Handle;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADSTARTEXCEPTION)]
	IThreadStartException = interface(ISystemException)
	['{CACF35AC-87ED-4555-80F5-A319523C2640}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_THREADSTATEEXCEPTION)]
	IThreadStateException = interface(ISystemException)
	['{4E694E90-CE17-430B-B097-DEF209D58907}']
	end;

	[CoreTypeSignature(SYSTEM_THREADSTATICATTRIBUTE)]
	IThreadStaticAttribute = interface(IAttribute)
	['{87B8CBF0-C518-4F1D-AB8F-DEE7001122BE}']
	end;

	ITimeoutClass = interface(ICoreClrClass)
	['{30106BEB-5F9C-4228-BAFA-B78251639010}']
	{ private }
		{ class } function _GetFld_Infinite: Integer;
		{ class } function _GetFld_InfiniteTimeSpan: ITimeSpan;
	{ public }
		{ class } property Infinite: Integer read _GetFld_Infinite;
		{ class } property InfiniteTimeSpan: ITimeSpan read _GetFld_InfiniteTimeSpan;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TIMEOUT)]
	ITimeout = interface(IObject)
	['{8CC12BFD-8557-4C9C-BF5B-D947D5F19653}']
	end;

	[CoreTypeSignature(SYSTEM_TIMEOUTEXCEPTION)]
	ITimeoutException = interface(ISystemException)
	['{1FA0ADB1-CB30-4614-8CC2-003122C73553}']
	end;

	ITimerClass = interface(ICoreClrClass)
	['{F8D169CE-C8B2-4244-AB3A-FA01A49F1886}']
	{ private }
		{ class } function _GetProp_ActiveCount: Int64;
	{ public }
		{ class } property ActiveCount: Int64 read _GetProp_ActiveCount;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TIMER)]
	ITimer = interface(IMarshalByRefObject)
	['{B17E43F4-7AA9-4E22-8B0C-9585B9BDECB2}']
	{ public }
		function Change(dueTime: Integer; period: Integer): Boolean; overload;
		function Change(dueTime: ITimeSpan; period: ITimeSpan): Boolean; overload;
		function Change(dueTime: longword; period: longword): Boolean; overload;
		function Change(dueTime: Int64; period: Int64): Boolean; overload;
		function Dispose(notifyObject: IWaitHandle): Boolean; overload;
		procedure Dispose(); overload;
		function DisposeAsync(): IValueTask;
	end;

	ITimeSpanClass = interface(ICoreClrClass)
	['{EF342A7C-B301-4E04-945A-32DC2016EE21}']
	{ private }
		{ class } function _GetFld_MaxValue: ITimeSpan;
		{ class } function _GetFld_MinValue: ITimeSpan;
		{ class } function _GetFld_TicksPerDay: Int64;
		{ class } function _GetFld_TicksPerHour: Int64;
		{ class } function _GetFld_TicksPerMillisecond: Int64;
		{ class } function _GetFld_TicksPerMinute: Int64;
		{ class } function _GetFld_TicksPerSecond: Int64;
		{ class } function _GetFld_Zero: ITimeSpan;
	{ public }
		{ class } function Compare(t1: ITimeSpan; t2: ITimeSpan): Integer;
		{ class } function Equals(t1: ITimeSpan; t2: ITimeSpan): Boolean;
		{ class } function FromDays(value: Double): ITimeSpan;
		{ class } function FromHours(value: Double): ITimeSpan;
		{ class } function FromMilliseconds(value: Double): ITimeSpan;
		{ class } function FromMinutes(value: Double): ITimeSpan;
		{ class } function FromSeconds(value: Double): ITimeSpan;
		{ class } function FromTicks(value: Int64): ITimeSpan;
		{ class } function Parse(s: String): ITimeSpan; overload;
		{ class } function Parse(input: String; formatProvider: IIFormatProvider): ITimeSpan; overload;
		{ class } function Parse(input: IReadOnlySpan<Char>; formatProvider: IIFormatProvider): ITimeSpan; overload;
		{ class } function ParseExact(input: String; format: String; formatProvider: IIFormatProvider): ITimeSpan; overload;
		{ class } function ParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider): ITimeSpan; overload;
		{ class } function ParseExact(input: String; format: String; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set): ITimeSpan; overload;
		{ class } function ParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set): ITimeSpan; overload;
		{ class } function ParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set): ITimeSpan; overload;
		{ class } function ParseExact(input: IReadOnlySpan<Char>; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set): ITimeSpan; overload;
		{ class } function TryParse(s: String; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParse(input: String; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParse(input: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: String; format: String; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; formats: TArray<String>; formatProvider: IIFormatProvider; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: String; format: String; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: String; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set; var result_: ITimeSpan): Boolean; overload;
		{ class } function TryParseExact(input: IReadOnlySpan<Char>; formats: TArray<String>; formatProvider: IIFormatProvider; styles: TTimeSpanStyles_Set; var result_: ITimeSpan): Boolean; overload;
		{ class } property MaxValue: ITimeSpan read _GetFld_MaxValue;
		{ class } property MinValue: ITimeSpan read _GetFld_MinValue;
		{ class } property TicksPerDay: Int64 read _GetFld_TicksPerDay;
		{ class } property TicksPerHour: Int64 read _GetFld_TicksPerHour;
		{ class } property TicksPerMillisecond: Int64 read _GetFld_TicksPerMillisecond;
		{ class } property TicksPerMinute: Int64 read _GetFld_TicksPerMinute;
		{ class } property TicksPerSecond: Int64 read _GetFld_TicksPerSecond;
		{ class } property Zero: ITimeSpan read _GetFld_Zero;
	end;

	[CoreTypeSignature(SYSTEM_TIMESPAN)]
	ITimeSpan = interface(IValueType)
	['{290FD8FF-9BB2-492B-8788-82E69090E584}']
	{ private }
		function _GetProp_Days: Integer;
		function _GetProp_Hours: Integer;
		function _GetProp_Milliseconds: Integer;
		function _GetProp_Minutes: Integer;
		function _GetProp_Seconds: Integer;
		function _GetProp_Ticks: Int64;
		function _GetProp_TotalDays: Double;
		function _GetProp_TotalHours: Double;
		function _GetProp_TotalMilliseconds: Double;
		function _GetProp_TotalMinutes: Double;
		function _GetProp_TotalSeconds: Double;
	{ public }
		function Add(ts: ITimeSpan): ITimeSpan;
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: ITimeSpan): Integer; overload;
		function Divide(divisor: Double): ITimeSpan; overload;
		function Divide(ts: ITimeSpan): Double; overload;
		function Duration(): ITimeSpan;
		function Equals(obj: ITimeSpan): Boolean;
		function Multiply(factor: Double): ITimeSpan;
		function Negate(): ITimeSpan;
		function Subtract(ts: ITimeSpan): ITimeSpan;
		function ToString(format: String): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; formatProvider: IIFormatProvider): Boolean;
		property Days: Integer read _GetProp_Days;
		property Hours: Integer read _GetProp_Hours;
		property Milliseconds: Integer read _GetProp_Milliseconds;
		property Minutes: Integer read _GetProp_Minutes;
		property Seconds: Integer read _GetProp_Seconds;
		property Ticks: Int64 read _GetProp_Ticks;
		property TotalDays: Double read _GetProp_TotalDays;
		property TotalHours: Double read _GetProp_TotalHours;
		property TotalMilliseconds: Double read _GetProp_TotalMilliseconds;
		property TotalMinutes: Double read _GetProp_TotalMinutes;
		property TotalSeconds: Double read _GetProp_TotalSeconds;
	end;

	ITimeZoneClass = interface(ICoreClrClass)
	['{F1E5CB5D-4775-49A1-9A66-8631DF1C9E05}']
	{ private }
		{ class } function _GetProp_CurrentTimeZone: ITimeZone;
	{ public }
		{ class } function IsDaylightSavingTime(time: TDateTime; daylightTimes: IDaylightTime): Boolean;
		{ class } property CurrentTimeZone: ITimeZone read _GetProp_CurrentTimeZone;
	end;

	[CoreTypeSignature(SYSTEM_TIMEZONE)]
	ITimeZone = interface(IObject)
	['{41EF4021-CF23-4321-9E92-9F47D29921E1}']
	{ private }
		function _GetProp_DaylightName: String;
		function _GetProp_StandardName: String;
	{ public }
		function GetDaylightChanges(year: Integer): IDaylightTime;
		function GetUtcOffset(time: TDateTime): ITimeSpan;
		function IsDaylightSavingTime(time: TDateTime): Boolean;
		function ToLocalTime(time: TDateTime): TDateTime;
		function ToUniversalTime(time: TDateTime): TDateTime;
		property DaylightName: String read _GetProp_DaylightName;
		property StandardName: String read _GetProp_StandardName;
	end;

	ITimeZoneInfoClass = interface(ICoreClrClass)
	['{086A43F6-E6AF-4647-9835-0AD02035C32E}']
	{ private }
		{ class } function _GetProp_Local: ITimeZoneInfo;
		{ class } function _GetProp_Utc: ITimeZoneInfo;
	{ public }
		{ class } procedure ClearCachedData();
		{ class } function ConvertTime(dateTimeOffset: IDateTimeOffset; destinationTimeZone: ITimeZoneInfo): IDateTimeOffset; overload;
		{ class } function ConvertTime(dateTime: TDateTime; destinationTimeZone: ITimeZoneInfo): TDateTime; overload;
		{ class } function ConvertTime(dateTime: TDateTime; sourceTimeZone: ITimeZoneInfo; destinationTimeZone: ITimeZoneInfo): TDateTime; overload;
		{ class } function ConvertTimeBySystemTimeZoneId(dateTimeOffset: IDateTimeOffset; destinationTimeZoneId: String): IDateTimeOffset; overload;
		{ class } function ConvertTimeBySystemTimeZoneId(dateTime: TDateTime; destinationTimeZoneId: String): TDateTime; overload;
		{ class } function ConvertTimeBySystemTimeZoneId(dateTime: TDateTime; sourceTimeZoneId: String; destinationTimeZoneId: String): TDateTime; overload;
		{ class } function ConvertTimeFromUtc(dateTime: TDateTime; destinationTimeZone: ITimeZoneInfo): TDateTime;
		{ class } function ConvertTimeToUtc(dateTime: TDateTime): TDateTime; overload;
		{ class } function ConvertTimeToUtc(dateTime: TDateTime; sourceTimeZone: ITimeZoneInfo): TDateTime; overload;
		{ class } function CreateCustomTimeZone(id: String; baseUtcOffset: ITimeSpan; displayName: String; standardDisplayName: String): ITimeZoneInfo; overload;
		{ class } function CreateCustomTimeZone(id: String; baseUtcOffset: ITimeSpan; displayName: String; standardDisplayName: String; daylightDisplayName: String; adjustmentRules: ICoreClrBridgeArray<IAdjustmentRule>): ITimeZoneInfo; overload;
		{ class } function CreateCustomTimeZone(id: String; baseUtcOffset: ITimeSpan; displayName: String; standardDisplayName: String; daylightDisplayName: String; adjustmentRules: ICoreClrBridgeArray<IAdjustmentRule>; disableDaylightSavingTime: Boolean): ITimeZoneInfo; overload;
		{ class } function FindSystemTimeZoneById(id: String): ITimeZoneInfo;
		{ class } function FromSerializedString(source: String): ITimeZoneInfo;
		{ class } function GetSystemTimeZones(): IReadOnlyCollection<ITimeZoneInfo>;
		{ class } property Local: ITimeZoneInfo read _GetProp_Local;
		{ class } property Utc: ITimeZoneInfo read _GetProp_Utc;
	end;

	[CoreTypeSignature(SYSTEM_TIMEZONEINFO)]
	ITimeZoneInfo = interface(IObject)
	['{E8F22E28-0F24-4472-A01E-E71377E06D09}']
	{ private }
		function _GetProp_BaseUtcOffset: ITimeSpan;
		function _GetProp_DaylightName: String;
		function _GetProp_DisplayName: String;
		function _GetProp_Id: String;
		function _GetProp_StandardName: String;
		function _GetProp_SupportsDaylightSavingTime: Boolean;
	{ public }
		function Equals(other: ITimeZoneInfo): Boolean;
		function GetAdjustmentRules(): TArray<IAdjustmentRule>;
		function GetAmbiguousTimeOffsets(dateTimeOffset: IDateTimeOffset): TArray<ITimeSpan>; overload;
		function GetAmbiguousTimeOffsets(dateTime: TDateTime): TArray<ITimeSpan>; overload;
		function GetUtcOffset(dateTimeOffset: IDateTimeOffset): ITimeSpan; overload;
		function GetUtcOffset(dateTime: TDateTime): ITimeSpan; overload;
		function HasSameRules(other: ITimeZoneInfo): Boolean;
		function IsAmbiguousTime(dateTimeOffset: IDateTimeOffset): Boolean; overload;
		function IsAmbiguousTime(dateTime: TDateTime): Boolean; overload;
		function IsDaylightSavingTime(dateTimeOffset: IDateTimeOffset): Boolean; overload;
		function IsDaylightSavingTime(dateTime: TDateTime): Boolean; overload;
		function IsInvalidTime(dateTime: TDateTime): Boolean;
		function ToSerializedString(): String;
		property BaseUtcOffset: ITimeSpan read _GetProp_BaseUtcOffset;
		property DaylightName: String read _GetProp_DaylightName;
		property DisplayName: String read _GetProp_DisplayName;
		property Id: String read _GetProp_Id;
		property StandardName: String read _GetProp_StandardName;
		property SupportsDaylightSavingTime: Boolean read _GetProp_SupportsDaylightSavingTime;
	end;

	ITransitionTimeClass = interface(ICoreClrClass)
	['{CE11249C-F31E-4C47-8F9F-98D67D2177D0}']
	{ public }
		{ class } function CreateFixedDateRule(timeOfDay: TDateTime; month: Integer; day: Integer): ITransitionTime;
		{ class } function CreateFloatingDateRule(timeOfDay: TDateTime; month: Integer; week: Integer; dayOfWeek: TDayOfWeek): ITransitionTime;
	end;

	[CoreTypeSignature(SYSTEM_TRANSITIONTIME)]
	ITransitionTime = interface(IValueType)
	['{82537BB7-058F-4933-B92B-29E5771B4AFF}']
	{ private }
		function _GetProp_Day: Integer;
		function _GetProp_DayOfWeek: TDayOfWeek;
		function _GetProp_IsFixedDateRule: Boolean;
		function _GetProp_Month: Integer;
		function _GetProp_TimeOfDay: TDateTime;
		function _GetProp_Week: Integer;
	{ public }
		function Equals(other: ITransitionTime): Boolean;
		property Day: Integer read _GetProp_Day;
		property DayOfWeek: TDayOfWeek read _GetProp_DayOfWeek;
		property IsFixedDateRule: Boolean read _GetProp_IsFixedDateRule;
		property Month: Integer read _GetProp_Month;
		property TimeOfDay: TDateTime read _GetProp_TimeOfDay;
		property Week: Integer read _GetProp_Week;
	end;

	[CoreTypeSignature(SYSTEM_TIMEZONENOTFOUNDEXCEPTION)]
	ITimeZoneNotFoundException = interface(IException)
	['{6E34A5CA-30B0-46ED-AFE0-403F9476EDBF}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_TRACING_TRACELOGGINGEVENTTYPES)]
	ITraceLoggingEventTypes = interface(IObject)
	['{028D8BB3-3505-46D2-B3AF-E6FAF69B235A}']
	end;

	ITupleClass = interface(ICoreClrClass)
	['{E934995B-AAEB-41FB-8C81-4AA08840E6ED}']
	{ public }
		{ class } function Create(T1: PTypeInfo; item1: Variant{T1}): ITuple<Variant{T1}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}): ITuple<Variant{T1},Variant{T2}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}): ITuple<Variant{T1},Variant{T2},Variant{T3}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}; item7: Variant{T7}): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}; item7: Variant{T7}; item8: Variant{T8}): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8}>>; overload;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE)]
	ITuple = interface(IObject)
	['{EE9FA8A2-5121-4B72-8FF1-4454B6FA83F5}']
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_1)]
	ITuple<T1> = interface(IObject)
	['{D984DB8B-6F3F-49F2-B7C7-C346A35D8F1A}']
	{ private }
		function _GetProp_Item1: T1;
	{ public }
		property Item1: T1 read _GetProp_Item1;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_2)]
	ITuple<T1,T2> = interface(IObject)
	['{B230A79B-4943-4A73-8DCE-7C03372E04CA}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_3)]
	ITuple<T1,T2,T3> = interface(IObject)
	['{27D38CE0-9928-4170-990F-6C5F8987FDA6}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_4)]
	ITuple<T1,T2,T3,T4> = interface(IObject)
	['{AB20F89A-314B-4A09-BC8B-A89330D30F42}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
		function _GetProp_Item4: T4;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
		property Item4: T4 read _GetProp_Item4;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_5)]
	ITuple<T1,T2,T3,T4,T5> = interface(IObject)
	['{4675B1A4-46D2-4FDD-87F7-C27CBBF5AEAE}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
		function _GetProp_Item4: T4;
		function _GetProp_Item5: T5;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
		property Item4: T4 read _GetProp_Item4;
		property Item5: T5 read _GetProp_Item5;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_6)]
	ITuple<T1,T2,T3,T4,T5,T6> = interface(IObject)
	['{A37EDE16-F813-459D-BD06-0DFA2DA4AC75}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
		function _GetProp_Item4: T4;
		function _GetProp_Item5: T5;
		function _GetProp_Item6: T6;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
		property Item4: T4 read _GetProp_Item4;
		property Item5: T5 read _GetProp_Item5;
		property Item6: T6 read _GetProp_Item6;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_7)]
	ITuple<T1,T2,T3,T4,T5,T6,T7> = interface(IObject)
	['{CD256520-4E69-471B-8BE0-E38CDD23338F}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
		function _GetProp_Item4: T4;
		function _GetProp_Item5: T5;
		function _GetProp_Item6: T6;
		function _GetProp_Item7: T7;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
		property Item4: T4 read _GetProp_Item4;
		property Item5: T5 read _GetProp_Item5;
		property Item6: T6 read _GetProp_Item6;
		property Item7: T7 read _GetProp_Item7;
	end;

	[CoreTypeSignature(SYSTEM_TUPLE_8)]
	ITuple<T1,T2,T3,T4,T5,T6,T7,TRest> = interface(IObject)
	['{4026F545-6D0D-49D9-87EA-4264D6BB61C4}']
	{ private }
		function _GetProp_Item1: T1;
		function _GetProp_Item2: T2;
		function _GetProp_Item3: T3;
		function _GetProp_Item4: T4;
		function _GetProp_Item5: T5;
		function _GetProp_Item6: T6;
		function _GetProp_Item7: T7;
		function _GetProp_Rest: TRest;
	{ public }
		property Item1: T1 read _GetProp_Item1;
		property Item2: T2 read _GetProp_Item2;
		property Item3: T3 read _GetProp_Item3;
		property Item4: T4 read _GetProp_Item4;
		property Item5: T5 read _GetProp_Item5;
		property Item6: T6 read _GetProp_Item6;
		property Item7: T7 read _GetProp_Item7;
		property Rest: TRest read _GetProp_Rest;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_TUPLEELEMENTNAMESATTRIBUTE)]
	ITupleElementNamesAttribute = interface(IAttribute)
	['{B937824D-FCB4-4942-9222-380B5256C25E}']
	{ private }
		function _GetProp_TransformNames: IIList<String>;
	{ public }
		property TransformNames: IIList<String> read _GetProp_TransformNames;
	end;

	ITupleExtensionsClass = interface(ICoreClrClass)
	['{7111F0B5-9236-4A66-B131-444611BFF0EC}']
	{ public }
		{ class } procedure Deconstruct(T1: PTypeInfo; value: ITuple<Variant{T1}>; var item1: Variant{T1}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; value: ITuple<Variant{T1},Variant{T2}>; var item1: Variant{T1}; var item2: Variant{T2}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3}>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15}>>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16}>>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17}>>>; var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}; var item17: Variant{T17}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18}>>>;
			var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}; var item17: Variant{T17}; var item18: Variant{T18}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19}>>>;
			var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}; var item17: Variant{T17}; var item18: Variant{T18}; var item19: Variant{T19}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20}>>>;
			var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}; var item17: Variant{T17}; var item18: Variant{T18}; var item19: Variant{T19}; var item20: Variant{T20}); overload;
		{ class } procedure Deconstruct(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; T21: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20},Variant{T21}>>>;
			var item1: Variant{T1}; var item2: Variant{T2}; var item3: Variant{T3}; var item4: Variant{T4}; var item5: Variant{T5}; var item6: Variant{T6}; var item7: Variant{T7}; var item8: Variant{T8}; var item9: Variant{T9}; var item10: Variant{T10}; var item11: Variant{T11}; var item12: Variant{T12}; var item13: Variant{T13}; var item14: Variant{T14}; var item15: Variant{T15}; var item16: Variant{T16}; var item17: Variant{T17}; var item18: Variant{T18}; var item19: Variant{T19}; var item20: Variant{T20}; var item21: Variant{T21}); overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; T21: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20},Variant{T21}>>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20},Variant{T21}>>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; value: IValueTuple<Variant{T1}>): ITuple<Variant{T1}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2}>): ITuple<Variant{T1},Variant{T2}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3}>): ITuple<Variant{T1},Variant{T2},Variant{T3}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8}>>; overload;
		{ class } function ToTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; value: IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9}>>): ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; value: ITuple<Variant{T1}>): IValueTuple<Variant{T1}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; value: ITuple<Variant{T1},Variant{T2}>): IValueTuple<Variant{T1},Variant{T2}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3}>): IValueTuple<Variant{T1},Variant{T2},Variant{T3}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20}>>>; overload;
		{ class } function ToValueTuple(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; T9: PTypeInfo; T10: PTypeInfo; T11: PTypeInfo; T12: PTypeInfo; T13: PTypeInfo; T14: PTypeInfo; T15: PTypeInfo; T16: PTypeInfo; T17: PTypeInfo; T18: PTypeInfo; T19: PTypeInfo; T20: PTypeInfo; T21: PTypeInfo; value: ITuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, ITuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, ITuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20},Variant{T21}>>>): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8},Variant{T9},Variant{T10},Variant{T11},Variant{T12},Variant{T13},Variant{T14}, IValueTuple<Variant{T15},Variant{T16},Variant{T17},Variant{T18},Variant{T19},Variant{T20},Variant{T21}>>>; overload;
	end;

	[CoreTypeSignature(SYSTEM_TUPLEEXTENSIONS)]
	ITupleExtensions = interface(IObject)
	['{D3A3C278-9A50-407A-922F-313B45BE0A47}']
	end;

	[CoreTypeSignature(SYSTEM_TYPEACCESSEXCEPTION)]
	ITypeAccessException = interface(ITypeLoadException)
	['{120637DE-904E-47B0-A743-6362BB796ED8}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
	end;

	ITYPEATTRClass = interface(ICoreClrClass)
	['{CB24FF8E-96A6-46F1-87CE-F0E9C80E7D28}']
	{ private }
		{ class } function _GetFld_MEMBER_ID_NIL: Integer;
	{ public }
		{ class } property MEMBER_ID_NIL: Integer read _GetFld_MEMBER_ID_NIL;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_TYPEATTR)]
	ITYPEATTR = interface(IValueType)
	['{FB85631E-469C-41B0-BBEB-BF499B63D1F9}']
	{ private }
		function _GetFld_cbAlignment: SmallInt;
		procedure _SetFld_cbAlignment(Value: SmallInt);
		function _GetFld_cbSizeInstance: Integer;
		procedure _SetFld_cbSizeInstance(Value: Integer);
		function _GetFld_cbSizeVft: SmallInt;
		procedure _SetFld_cbSizeVft(Value: SmallInt);
		function _GetFld_cFuncs: SmallInt;
		procedure _SetFld_cFuncs(Value: SmallInt);
		function _GetFld_cImplTypes: SmallInt;
		procedure _SetFld_cImplTypes(Value: SmallInt);
		function _GetFld_cVars: SmallInt;
		procedure _SetFld_cVars(Value: SmallInt);
		function _GetFld_dwReserved: Integer;
		procedure _SetFld_dwReserved(Value: Integer);
		function _GetFld_guid: IGuid;
		procedure _SetFld_guid(Value: IGuid);
		function _GetFld_idldescType: IIDLDESC;
		procedure _SetFld_idldescType(Value: IIDLDESC);
		function _GetFld_lcid: Integer;
		procedure _SetFld_lcid(Value: Integer);
		function _GetFld_lpstrSchema: IIntPtr;
		procedure _SetFld_lpstrSchema(Value: IIntPtr);
		function _GetFld_memidConstructor: Integer;
		procedure _SetFld_memidConstructor(Value: Integer);
		function _GetFld_memidDestructor: Integer;
		procedure _SetFld_memidDestructor(Value: Integer);
		function _GetFld_tdescAlias: ITYPEDESC;
		procedure _SetFld_tdescAlias(Value: ITYPEDESC);
		function _GetFld_typekind: TTYPEKIND;
		procedure _SetFld_typekind(Value: TTYPEKIND);
		function _GetFld_wMajorVerNum: SmallInt;
		procedure _SetFld_wMajorVerNum(Value: SmallInt);
		function _GetFld_wMinorVerNum: SmallInt;
		procedure _SetFld_wMinorVerNum(Value: SmallInt);
		function _GetFld_wTypeFlags: TTYPEFLAGS_Set;
		procedure _SetFld_wTypeFlags(Value: TTYPEFLAGS_Set);
	{ public }
		property cbAlignment: SmallInt read _GetFld_cbAlignment write _SetFld_cbAlignment;
		property cbSizeInstance: Integer read _GetFld_cbSizeInstance write _SetFld_cbSizeInstance;
		property cbSizeVft: SmallInt read _GetFld_cbSizeVft write _SetFld_cbSizeVft;
		property cFuncs: SmallInt read _GetFld_cFuncs write _SetFld_cFuncs;
		property cImplTypes: SmallInt read _GetFld_cImplTypes write _SetFld_cImplTypes;
		property cVars: SmallInt read _GetFld_cVars write _SetFld_cVars;
		property dwReserved: Integer read _GetFld_dwReserved write _SetFld_dwReserved;
		property guid: IGuid read _GetFld_guid write _SetFld_guid;
		property idldescType: IIDLDESC read _GetFld_idldescType write _SetFld_idldescType;
		property lcid: Integer read _GetFld_lcid write _SetFld_lcid;
		property lpstrSchema: IIntPtr read _GetFld_lpstrSchema write _SetFld_lpstrSchema;
		property memidConstructor: Integer read _GetFld_memidConstructor write _SetFld_memidConstructor;
		property memidDestructor: Integer read _GetFld_memidDestructor write _SetFld_memidDestructor;
		property tdescAlias: ITYPEDESC read _GetFld_tdescAlias write _SetFld_tdescAlias;
		property typekind: TTYPEKIND read _GetFld_typekind write _SetFld_typekind;
		property wMajorVerNum: SmallInt read _GetFld_wMajorVerNum write _SetFld_wMajorVerNum;
		property wMinorVerNum: SmallInt read _GetFld_wMinorVerNum write _SetFld_wMinorVerNum;
		property wTypeFlags: TTYPEFLAGS_Set read _GetFld_wTypeFlags write _SetFld_wTypeFlags;
	end;

	ITypeBuilderClass = interface(ICoreClrClass)
	['{9E5585BF-2234-4F72-95A9-4CB550194EC2}']
	{ private }
		{ class } function _GetFld_UnspecifiedTypeSize: Integer;
	{ public }
		{ class } function GetConstructor(type_: IType; constructor_: IConstructorInfo): IConstructorInfo;
		{ class } function GetField(type_: IType; field: IFieldInfo): IFieldInfo;
		{ class } function GetMethod(type_: IType; method: IMethodInfo): IMethodInfo;
		{ class } property UnspecifiedTypeSize: Integer read _GetFld_UnspecifiedTypeSize;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_TYPEBUILDER)]
	ITypeBuilder = interface(ITypeInfo)
	['{09E66493-8569-44B5-8BC0-49DDCA608725}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_AssemblyQualifiedName: String;
		function _GetProp_BaseType: IType;
		function _GetProp_DeclaringMethod: IMethodBase;
		function _GetProp_DeclaringType: IType;
		function _GetProp_FullName: String;
		function _GetProp_GenericParameterAttributes: TGenericParameterAttributes_Set;
		function _GetProp_GenericParameterPosition: Integer;
		function _GetProp_GUID: IGuid;
		function _GetProp_IsByRefLike: Boolean;
		function _GetProp_IsConstructedGenericType: Boolean;
		function _GetProp_IsGenericParameter: Boolean;
		function _GetProp_IsGenericType: Boolean;
		function _GetProp_IsGenericTypeDefinition: Boolean;
		function _GetProp_IsSecurityCritical: Boolean;
		function _GetProp_IsSecuritySafeCritical: Boolean;
		function _GetProp_IsSecurityTransparent: Boolean;
		function _GetProp_IsSZArray: Boolean;
		function _GetProp_IsTypeDefinition: Boolean;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_Namespace: String;
		function _GetProp_PackingSize: TPackingSize;
		function _GetProp_ReflectedType: IType;
		function _GetProp_Size: Integer;
		function _GetProp_TypeHandle: IRuntimeTypeHandle;
		function _GetProp_TypeToken: ITypeToken;
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		procedure AddInterfaceImplementation(interfaceType: IType);
		function CreateType(): IType;
		function CreateTypeInfo(): ITypeInfo;
		function DefineConstructor(attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; parameterTypes: ICoreClrBridgeArray<IType>): IConstructorBuilder; overload;
		function DefineConstructor(attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; parameterTypes: ICoreClrBridgeArray<IType>; requiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; optionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): IConstructorBuilder; overload;
		function DefineDefaultConstructor(attributes: TMethodAttributes_Set): IConstructorBuilder;
		function DefineEvent(name: String; attributes: TEventAttributes_Set; eventtype: IType): IEventBuilder;
		function DefineField(fieldName: String; type_: IType; attributes: TFieldAttributes_Set): IFieldBuilder; overload;
		function DefineField(fieldName: String; type_: IType; requiredCustomModifiers: ICoreClrBridgeArray<IType>; optionalCustomModifiers: ICoreClrBridgeArray<IType>; attributes: TFieldAttributes_Set): IFieldBuilder; overload;
		function DefineGenericParameters(names: TArray<String>): TArray<IGenericTypeParameterBuilder>;
		function DefineInitializedData(name: String; data: TArray<Byte>; attributes: TFieldAttributes_Set): IFieldBuilder;
		function DefineMethod(name: String; attributes: TMethodAttributes_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodBuilder; overload;
		function DefineMethod(name: String; attributes: TMethodAttributes_Set): IMethodBuilder; overload;
		function DefineMethod(name: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set): IMethodBuilder; overload;
		function DefineMethod(name: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IMethodBuilder; overload;
		function DefineMethod(name: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; returnTypeRequiredCustomModifiers: ICoreClrBridgeArray<IType>; returnTypeOptionalCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; parameterTypeRequiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; parameterTypeOptionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): IMethodBuilder; overload;
		procedure DefineMethodOverride(methodInfoBody: IMethodInfo; methodInfoDeclaration: IMethodInfo);
		function DefineNestedType(name: String): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set; parent: IType; interfaces: ICoreClrBridgeArray<IType>): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set; parent: IType; typeSize: Integer): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set; parent: IType; packSize: TPackingSize): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set; parent: IType): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set): ITypeBuilder; overload;
		function DefineNestedType(name: String; attr: TTypeAttributes_Set; parent: IType; packSize: TPackingSize; typeSize: Integer): ITypeBuilder; overload;
		function DefinePInvokeMethod(name: String; dllName: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>; nativeCallConv: TCallingConvention; nativeCharSet: TCharSet): IMethodBuilder; overload;
		function DefinePInvokeMethod(name: String; dllName: String; entryName: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>; nativeCallConv: TCallingConvention; nativeCharSet: TCharSet): IMethodBuilder; overload;
		function DefinePInvokeMethod(name: String; dllName: String; entryName: String; attributes: TMethodAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; returnTypeRequiredCustomModifiers: ICoreClrBridgeArray<IType>; returnTypeOptionalCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; parameterTypeRequiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; parameterTypeOptionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; nativeCallConv: TCallingConvention; nativeCharSet: TCharSet): IMethodBuilder; overload;
		function DefineProperty(name: String; attributes: TPropertyAttributes_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IPropertyBuilder; overload;
		function DefineProperty(name: String; attributes: TPropertyAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; parameterTypes: ICoreClrBridgeArray<IType>): IPropertyBuilder; overload;
		function DefineProperty(name: String; attributes: TPropertyAttributes_Set; returnType: IType; returnTypeRequiredCustomModifiers: ICoreClrBridgeArray<IType>; returnTypeOptionalCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; parameterTypeRequiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; parameterTypeOptionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): IPropertyBuilder; overload;
		function DefineProperty(name: String; attributes: TPropertyAttributes_Set; callingConvention: TCallingConventions_Set; returnType: IType; returnTypeRequiredCustomModifiers: ICoreClrBridgeArray<IType>; returnTypeOptionalCustomModifiers: ICoreClrBridgeArray<IType>; parameterTypes: ICoreClrBridgeArray<IType>; parameterTypeRequiredCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>; parameterTypeOptionalCustomModifiers: ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>): IPropertyBuilder; overload;
		function DefineTypeInitializer(): IConstructorBuilder;
		function DefineUninitializedData(name: String; size: Integer; attributes: TFieldAttributes_Set): IFieldBuilder;
		function GetConstructors(bindingAttr: TBindingFlags_Set): TArray<IConstructorInfo>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetElementType(): IType;
		function GetEvent(name: String; bindingAttr: TBindingFlags_Set): IEventInfo;
		function GetEvents(): TArray<IEventInfo>; overload;
		function GetEvents(bindingAttr: TBindingFlags_Set): TArray<IEventInfo>; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetGenericArguments(): TArray<IType>;
		function GetGenericTypeDefinition(): IType;
		function GetInterface(name: String; ignoreCase: Boolean): IType;
		function GetInterfaceMap(interfaceType: IType): IInterfaceMapping;
		function GetInterfaces(): TArray<IType>;
		function GetMember(name: String; type_: TMemberTypes_Set; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetNestedType(name: String; bindingAttr: TBindingFlags_Set): IType;
		function GetNestedTypes(bindingAttr: TBindingFlags_Set): TArray<IType>;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant;
		function IsAssignableFrom(c: IType): Boolean; overload;
		function IsAssignableFrom(typeInfo: ITypeInfo): Boolean; overload;
		function IsCreated(): Boolean;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		function IsSubclassOf(c: IType): Boolean;
		function MakeArrayType(): IType; overload;
		function MakeArrayType(rank: Integer): IType; overload;
		function MakeByRefType(): IType;
		function MakeGenericType(typeArguments: ICoreClrBridgeArray<IType>): IType;
		function MakePointerType(): IType;
		procedure SetCustomAttribute(con: IConstructorInfo; binaryAttribute: TArray<Byte>); overload;
		procedure SetCustomAttribute(customBuilder: ICustomAttributeBuilder); overload;
		procedure SetParent(parent: IType);
		property Assembly: IAssembly read _GetProp_Assembly;
		property AssemblyQualifiedName: String read _GetProp_AssemblyQualifiedName;
		property BaseType: IType read _GetProp_BaseType;
		property DeclaringMethod: IMethodBase read _GetProp_DeclaringMethod;
		property DeclaringType: IType read _GetProp_DeclaringType;
		property FullName: String read _GetProp_FullName;
		property GenericParameterAttributes: TGenericParameterAttributes_Set read _GetProp_GenericParameterAttributes;
		property GenericParameterPosition: Integer read _GetProp_GenericParameterPosition;
		property GUID: IGuid read _GetProp_GUID;
		property IsByRefLike: Boolean read _GetProp_IsByRefLike;
		property IsConstructedGenericType: Boolean read _GetProp_IsConstructedGenericType;
		property IsGenericParameter: Boolean read _GetProp_IsGenericParameter;
		property IsGenericType: Boolean read _GetProp_IsGenericType;
		property IsGenericTypeDefinition: Boolean read _GetProp_IsGenericTypeDefinition;
		property IsSecurityCritical: Boolean read _GetProp_IsSecurityCritical;
		property IsSecuritySafeCritical: Boolean read _GetProp_IsSecuritySafeCritical;
		property IsSecurityTransparent: Boolean read _GetProp_IsSecurityTransparent;
		property IsSZArray: Boolean read _GetProp_IsSZArray;
		property IsTypeDefinition: Boolean read _GetProp_IsTypeDefinition;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property Namespace: String read _GetProp_Namespace;
		property PackingSize: TPackingSize read _GetProp_PackingSize;
		property ReflectedType: IType read _GetProp_ReflectedType;
		property Size: Integer read _GetProp_Size;
		property TypeHandle: IRuntimeTypeHandle read _GetProp_TypeHandle;
		property TypeToken: ITypeToken read _GetProp_TypeToken;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_TYPEDELEGATOR)]
	ITypeDelegator = interface(ITypeInfo)
	['{8CC95FB3-838E-4D4F-BEF8-8581F967E131}']
	{ private }
		function _GetProp_Assembly: IAssembly;
		function _GetProp_AssemblyQualifiedName: String;
		function _GetProp_BaseType: IType;
		function _GetProp_FullName: String;
		function _GetProp_GUID: IGuid;
		function _GetProp_IsByRefLike: Boolean;
		function _GetProp_IsCollectible: Boolean;
		function _GetProp_IsConstructedGenericType: Boolean;
		function _GetProp_IsGenericMethodParameter: Boolean;
		function _GetProp_IsGenericTypeParameter: Boolean;
		function _GetProp_IsSZArray: Boolean;
		function _GetProp_IsTypeDefinition: Boolean;
		function _GetProp_IsVariableBoundArray: Boolean;
		function _GetProp_MetadataToken: Integer;
		function _GetProp_Module: IModule;
		function _GetProp_Name: String;
		function _GetProp_Namespace: String;
		function _GetProp_TypeHandle: IRuntimeTypeHandle;
		function _GetProp_UnderlyingSystemType: IType;
	{ public }
		function GetConstructors(bindingAttr: TBindingFlags_Set): TArray<IConstructorInfo>;
		function GetCustomAttributes(inherit: Boolean): TArray<Variant>; overload;
		function GetCustomAttributes(attributeType: IType; inherit: Boolean): TArray<Variant>; overload;
		function GetElementType(): IType;
		function GetEvent(name: String; bindingAttr: TBindingFlags_Set): IEventInfo;
		function GetEvents(): TArray<IEventInfo>; overload;
		function GetEvents(bindingAttr: TBindingFlags_Set): TArray<IEventInfo>; overload;
		function GetField(name: String; bindingAttr: TBindingFlags_Set): IFieldInfo;
		function GetFields(bindingAttr: TBindingFlags_Set): TArray<IFieldInfo>;
		function GetInterface(name: String; ignoreCase: Boolean): IType;
		function GetInterfaceMap(interfaceType: IType): IInterfaceMapping;
		function GetInterfaces(): TArray<IType>;
		function GetMember(name: String; type_: TMemberTypes_Set; bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMembers(bindingAttr: TBindingFlags_Set): TArray<IMemberInfo>;
		function GetMethods(bindingAttr: TBindingFlags_Set): TArray<IMethodInfo>;
		function GetNestedType(name: String; bindingAttr: TBindingFlags_Set): IType;
		function GetNestedTypes(bindingAttr: TBindingFlags_Set): TArray<IType>;
		function GetProperties(bindingAttr: TBindingFlags_Set): TArray<IPropertyInfo>;
		function InvokeMember(name: String; invokeAttr: TBindingFlags_Set; binder: IBinder; target: Variant; args: TArray<Variant>; modifiers: ICoreClrBridgeArray<IParameterModifier>; culture: ICultureInfo; namedParameters: TArray<String>): Variant;
		function IsAssignableFrom(typeInfo: ITypeInfo): Boolean;
		function IsDefined(attributeType: IType; inherit: Boolean): Boolean;
		property Assembly: IAssembly read _GetProp_Assembly;
		property AssemblyQualifiedName: String read _GetProp_AssemblyQualifiedName;
		property BaseType: IType read _GetProp_BaseType;
		property FullName: String read _GetProp_FullName;
		property GUID: IGuid read _GetProp_GUID;
		property IsByRefLike: Boolean read _GetProp_IsByRefLike;
		property IsCollectible: Boolean read _GetProp_IsCollectible;
		property IsConstructedGenericType: Boolean read _GetProp_IsConstructedGenericType;
		property IsGenericMethodParameter: Boolean read _GetProp_IsGenericMethodParameter;
		property IsGenericTypeParameter: Boolean read _GetProp_IsGenericTypeParameter;
		property IsSZArray: Boolean read _GetProp_IsSZArray;
		property IsTypeDefinition: Boolean read _GetProp_IsTypeDefinition;
		property IsVariableBoundArray: Boolean read _GetProp_IsVariableBoundArray;
		property MetadataToken: Integer read _GetProp_MetadataToken;
		property Module: IModule read _GetProp_Module;
		property Name: String read _GetProp_Name;
		property Namespace: String read _GetProp_Namespace;
		property TypeHandle: IRuntimeTypeHandle read _GetProp_TypeHandle;
		property UnderlyingSystemType: IType read _GetProp_UnderlyingSystemType;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_TYPEDESC)]
	ITYPEDESC = interface(IValueType)
	['{A9E870F5-29C1-4A69-B969-54E2A206827C}']
	{ private }
		function _GetFld_lpValue: IIntPtr;
		procedure _SetFld_lpValue(Value: IIntPtr);
		function _GetFld_vt: SmallInt;
		procedure _SetFld_vt(Value: SmallInt);
	{ public }
		property lpValue: IIntPtr read _GetFld_lpValue write _SetFld_lpValue;
		property vt: SmallInt read _GetFld_vt write _SetFld_vt;
	end;

	ITypedReferenceClass = interface(ICoreClrClass)
	['{1CA3FA33-88BB-4CCD-AFC3-C2AB038D651A}']
	{ public }
		{ class } function GetTargetType(value: ITypedReference): IType;
		{ class } function MakeTypedReference(target: Variant; flds: ICoreClrBridgeArray<IFieldInfo>): ITypedReference;
		{ class } procedure SetTypedReference(target: ITypedReference; value: Variant);
		{ class } function TargetTypeToken(value: ITypedReference): IRuntimeTypeHandle;
		{ class } function ToObject(value: ITypedReference): Variant;
	end;

	[CoreTypeSignature(SYSTEM_TYPEDREFERENCE)]
	ITypedReference = interface(IValueType)
	['{5E814F57-6ACF-49C2-A5C1-056730612817}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_TYPEFORWARDEDFROMATTRIBUTE)]
	ITypeForwardedFromAttribute = interface(IAttribute)
	['{4C4BE1D2-322A-4B7F-BAEA-D3598424C756}']
	{ private }
		function _GetProp_AssemblyFullName: String;
	{ public }
		property AssemblyFullName: String read _GetProp_AssemblyFullName;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_TYPEFORWARDEDTOATTRIBUTE)]
	ITypeForwardedToAttribute = interface(IAttribute)
	['{1410878F-C0B0-4D5F-B5BE-4AFB3CE5BDB4}']
	{ private }
		function _GetProp_Destination: IType;
	{ public }
		property Destination: IType read _GetProp_Destination;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_TYPEIDENTIFIERATTRIBUTE)]
	ITypeIdentifierAttribute = interface(IAttribute)
	['{98E5D8F9-C2D3-464E-AD76-32D358B2F8FF}']
	{ private }
		function _GetProp_Identifier: String;
		function _GetProp_Scope: String;
	{ public }
		property Identifier: String read _GetProp_Identifier;
		property Scope: String read _GetProp_Scope;
	end;

	[CoreTypeSignature(SYSTEM_TYPEINITIALIZATIONEXCEPTION)]
	ITypeInitializationException = interface(ISystemException)
	['{F8E623DF-D3D5-4202-BF10-6EAF6D37B7BF}']
	{ private }
		function _GetProp_TypeName: String;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property TypeName: String read _GetProp_TypeName;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_TYPELIBATTR)]
	ITYPELIBATTR = interface(IValueType)
	['{B2E3DE85-C299-4849-973F-71A6523901E9}']
	{ private }
		function _GetFld_guid: IGuid;
		procedure _SetFld_guid(Value: IGuid);
		function _GetFld_lcid: Integer;
		procedure _SetFld_lcid(Value: Integer);
		function _GetFld_syskind: TSYSKIND;
		procedure _SetFld_syskind(Value: TSYSKIND);
		function _GetFld_wLibFlags: TLIBFLAGS_Set;
		procedure _SetFld_wLibFlags(Value: TLIBFLAGS_Set);
		function _GetFld_wMajorVerNum: SmallInt;
		procedure _SetFld_wMajorVerNum(Value: SmallInt);
		function _GetFld_wMinorVerNum: SmallInt;
		procedure _SetFld_wMinorVerNum(Value: SmallInt);
	{ public }
		property guid: IGuid read _GetFld_guid write _SetFld_guid;
		property lcid: Integer read _GetFld_lcid write _SetFld_lcid;
		property syskind: TSYSKIND read _GetFld_syskind write _SetFld_syskind;
		property wLibFlags: TLIBFLAGS_Set read _GetFld_wLibFlags write _SetFld_wLibFlags;
		property wMajorVerNum: SmallInt read _GetFld_wMajorVerNum write _SetFld_wMajorVerNum;
		property wMinorVerNum: SmallInt read _GetFld_wMinorVerNum write _SetFld_wMinorVerNum;
	end;

	ITypeTokenClass = interface(ICoreClrClass)
	['{C488BA6C-4CF4-4EA4-9DA2-65CC4CA22155}']
	{ private }
		{ class } function _GetFld_Empty: ITypeToken;
	{ public }
		{ class } property Empty: ITypeToken read _GetFld_Empty;
	end;

	[CoreTypeSignature(SYSTEM_REFLECTION_EMIT_TYPETOKEN)]
	ITypeToken = interface(IValueType)
	['{CA98F37D-D548-4417-828E-DF7D391104AD}']
	{ private }
		function _GetProp_Token: Integer;
	{ public }
		function Equals(obj: ITypeToken): Boolean;
		property Token: Integer read _GetProp_Token;
	end;

	[CoreTypeSignature(SYSTEM_TYPEUNLOADEDEXCEPTION)]
	ITypeUnloadedException = interface(ISystemException)
	['{65B7E8BD-E2FF-4E67-81AF-5CA04C6CCE86}']
	end;

	IUInt16Class = interface(ICoreClrClass)
	['{59E9AAEC-EF77-4923-975E-52BB435295DD}']
	{ private }
		{ class } function _GetFld_MaxValue: Word;
		{ class } function _GetFld_MinValue: Word;
	{ public }
		{ class } function Parse(s: String): Word; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): Word; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): Word; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): Word; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): Word; overload;
		{ class } function TryParse(s: String; var result_: Word): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: Word): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Word): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: Word): Boolean; overload;
		{ class } property MaxValue: Word read _GetFld_MaxValue;
		{ class } property MinValue: Word read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_UINT16)]
	IUInt16 = interface(IValueType)
	['{95FDAA65-8C14-4119-ACDB-B138BA167135}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: Word): Integer; overload;
		function Equals(obj: Word): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IUInt32Class = interface(ICoreClrClass)
	['{FDEBE3B3-8B87-4C89-AC3E-4BFE21DF20DD}']
	{ private }
		{ class } function _GetFld_MaxValue: longword;
		{ class } function _GetFld_MinValue: longword;
	{ public }
		{ class } function Parse(s: String): longword; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): longword; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): longword; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): longword; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): longword; overload;
		{ class } function TryParse(s: String; var result_: longword): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: longword): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: longword): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: longword): Boolean; overload;
		{ class } property MaxValue: longword read _GetFld_MaxValue;
		{ class } property MinValue: longword read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_UINT32)]
	IUInt32 = interface(IValueType)
	['{238DC1A0-8498-4F3A-BB81-76F58FD2DC56}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: longword): Integer; overload;
		function Equals(obj: longword): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IUInt64Class = interface(ICoreClrClass)
	['{EE75F5BF-C969-4053-AD71-75873C03158B}']
	{ private }
		{ class } function _GetFld_MaxValue: UInt64;
		{ class } function _GetFld_MinValue: UInt64;
	{ public }
		{ class } function Parse(s: String): UInt64; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): UInt64; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): UInt64; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): UInt64; overload;
		{ class } function Parse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider): UInt64; overload;
		{ class } function TryParse(s: String; var result_: UInt64): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; var result_: UInt64): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: UInt64): Boolean; overload;
		{ class } function TryParse(s: IReadOnlySpan<Char>; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: UInt64): Boolean; overload;
		{ class } property MaxValue: UInt64 read _GetFld_MaxValue;
		{ class } property MinValue: UInt64 read _GetFld_MinValue;
	end;

	[CoreTypeSignature(SYSTEM_UINT64)]
	IUInt64 = interface(IValueType)
	['{685D422B-F234-4A42-A38E-AB00C6C0B4DF}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: UInt64): Integer; overload;
		function Equals(obj: UInt64): Boolean;
		function GetTypeCode(): TTypeCode;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer; format: IReadOnlySpan<Char>; provider: IIFormatProvider): Boolean;
	end;

	IUIntPtrClass = interface(ICoreClrClass)
	['{BDA1A7BB-13A8-443F-8AA4-F797C1F2DA4E}']
	{ private }
		{ class } function _GetFld_Zero: IUIntPtr;
		{ class } function _GetProp_MaxValue: IUIntPtr;
		{ class } function _GetProp_MinValue: IUIntPtr;
		{ class } function _GetProp_Size: Integer;
	{ public }
		{ class } function Add(pointer: IUIntPtr; offset: Integer): IUIntPtr;
		{ class } function Parse(s: String): IUIntPtr; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set): IUIntPtr; overload;
		{ class } function Parse(s: String; provider: IIFormatProvider): IUIntPtr; overload;
		{ class } function Parse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider): IUIntPtr; overload;
		{ class } function Subtract(pointer: IUIntPtr; offset: Integer): IUIntPtr;
		{ class } function TryParse(s: String; var result_: IUIntPtr): Boolean; overload;
		{ class } function TryParse(s: String; style: TNumberStyles_Set; provider: IIFormatProvider; var result_: IUIntPtr): Boolean; overload;
		{ class } property Zero: IUIntPtr read _GetFld_Zero;
		{ class } property MaxValue: IUIntPtr read _GetProp_MaxValue;
		{ class } property MinValue: IUIntPtr read _GetProp_MinValue;
		{ class } property Size: Integer read _GetProp_Size;
	end;

	[CoreTypeSignature(SYSTEM_UINTPTR)]
	IUIntPtr = interface(IValueType)
	['{D284E70E-7D91-4D19-82CC-1BA5A176F670}']
	{ public }
		function CompareTo(value: Variant): Integer; overload;
		function CompareTo(value: IUIntPtr): Integer; overload;
		function Equals(other: IUIntPtr): Boolean;
		function ToPointer(): ICoreClrInstance;
		function ToString(format: String): String; overload;
		function ToString(provider: IIFormatProvider): String; overload;
		function ToString(format: String; provider: IIFormatProvider): String; overload;
		function ToUInt32(): longword;
		function ToUInt64(): UInt64;
	end;

	IUmAlQuraCalendarClass = interface(ICoreClrClass)
	['{9035A45F-EC76-48D0-BCBD-4B6D454FA01D}']
	{ private }
		{ class } function _GetFld_UmAlQuraEra: Integer;
	{ public }
		{ class } property UmAlQuraEra: Integer read _GetFld_UmAlQuraEra;
	end;

	[CoreTypeSignature(SYSTEM_GLOBALIZATION_UMALQURACALENDAR)]
	IUmAlQuraCalendar = interface(ICalendar)
	['{59650085-EAD2-47F9-8FA2-8D749E906416}']
	{ private }
		function _GetProp_AlgorithmType: TCalendarAlgorithmType;
		function _GetProp_Eras: TArray<Integer>;
		function _GetProp_MaxSupportedDateTime: TDateTime;
		function _GetProp_MinSupportedDateTime: TDateTime;
		function _GetProp_TwoDigitYearMax: Integer;
		procedure _SetProp_TwoDigitYearMax(Value: Integer);
	{ public }
		function AddMonths(time: TDateTime; months: Integer): TDateTime;
		function AddYears(time: TDateTime; years: Integer): TDateTime;
		function GetDayOfMonth(time: TDateTime): Integer;
		function GetDayOfWeek(time: TDateTime): TDayOfWeek;
		function GetDayOfYear(time: TDateTime): Integer;
		function GetDaysInMonth(year: Integer; month: Integer; era: Integer): Integer;
		function GetDaysInYear(year: Integer; era: Integer): Integer;
		function GetEra(time: TDateTime): Integer;
		function GetLeapMonth(year: Integer; era: Integer): Integer;
		function GetMonth(time: TDateTime): Integer;
		function GetMonthsInYear(year: Integer; era: Integer): Integer;
		function GetYear(time: TDateTime): Integer;
		function IsLeapDay(year: Integer; month: Integer; day: Integer; era: Integer): Boolean;
		function IsLeapMonth(year: Integer; month: Integer; era: Integer): Boolean;
		function IsLeapYear(year: Integer; era: Integer): Boolean;
		function ToDateTime(year: Integer; month: Integer; day: Integer; hour: Integer; minute: Integer; second: Integer; millisecond: Integer; era: Integer): TDateTime;
		function ToFourDigitYear(year: Integer): Integer;
		property AlgorithmType: TCalendarAlgorithmType read _GetProp_AlgorithmType;
		property Eras: TArray<Integer> read _GetProp_Eras;
		property MaxSupportedDateTime: TDateTime read _GetProp_MaxSupportedDateTime;
		property MinSupportedDateTime: TDateTime read _GetProp_MinSupportedDateTime;
		property TwoDigitYearMax: Integer read _GetProp_TwoDigitYearMax write _SetProp_TwoDigitYearMax;
	end;

	[CoreTypeSignature(SYSTEM_UNAUTHORIZEDACCESSEXCEPTION)]
	IUnauthorizedAccessException = interface(ISystemException)
	['{2D7D4912-85C9-4FF8-8F84-E5A356721470}']
	end;

	[CoreTypeSignature(SYSTEM_DIAGNOSTICS_CODEANALYSIS_UNCONDITIONALSUPPRESSMESSAGEATTRIBUTE)]
	IUnconditionalSuppressMessageAttribute = interface(IAttribute)
	['{E7DE459A-952D-4E88-B88C-C859E06BD314}']
	{ private }
		function _GetProp_Category: String;
		function _GetProp_CheckId: String;
		function _GetProp_Justification: String;
		procedure _SetProp_Justification(Value: String);
		function _GetProp_MessageId: String;
		procedure _SetProp_MessageId(Value: String);
		function _GetProp_Scope: String;
		procedure _SetProp_Scope(Value: String);
		function _GetProp_Target: String;
		procedure _SetProp_Target(Value: String);
	{ public }
		property Category: String read _GetProp_Category;
		property CheckId: String read _GetProp_CheckId;
		property Justification: String read _GetProp_Justification write _SetProp_Justification;
		property MessageId: String read _GetProp_MessageId write _SetProp_MessageId;
		property Scope: String read _GetProp_Scope write _SetProp_Scope;
		property Target: String read _GetProp_Target write _SetProp_Target;
	end;

	[CoreTypeSignature(SYSTEM_UNHANDLEDEXCEPTIONEVENTARGS)]
	IUnhandledExceptionEventArgs = interface(IEventArgs)
	['{61D57DF3-FF2D-488A-97A4-A0474F1FE433}']
	{ private }
		function _GetProp_ExceptionObject: Variant;
		function _GetProp_IsTerminating: Boolean;
	{ public }
		property ExceptionObject: Variant read _GetProp_ExceptionObject;
		property IsTerminating: Boolean read _GetProp_IsTerminating;
	end;

	IUnicodeEncodingClass = interface(ICoreClrClass)
	['{20F9AD63-8F2E-414D-88FE-F9F3BE660872}']
	{ private }
		{ class } function _GetFld_CharSize: Integer;
	{ public }
		{ class } property CharSize: Integer read _GetFld_CharSize;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_UNICODEENCODING)]
	IUnicodeEncoding = interface(IEncoding)
	['{77AB82A3-38BB-4473-9C7E-6A1FD4740638}']
	{ private }
		function _GetProp_Preamble: IReadOnlySpan<Byte>;
	{ public }
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(s: String): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(s: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetPreamble(): TArray<Byte>;
		function GetString(bytes: TArray<Byte>; index: Integer; count: Integer): String;
		property Preamble: IReadOnlySpan<Byte> read _GetProp_Preamble;
	end;

	[CoreTypeSignature(SYSTEM_UNITYSERIALIZATIONHOLDER)]
	IUnitySerializationHolder = interface(IObject)
	['{D4A6062A-1352-414B-B4A1-72DD57263F87}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		function GetRealObject(context: IStreamingContext): Variant;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_UNKNOWNWRAPPER)]
	IUnknownWrapper = interface(IObject)
	['{71BACE2D-29EE-4784-B807-C1179E439C3C}']
	{ private }
		function _GetProp_WrappedObject: Variant;
	{ public }
		property WrappedObject: Variant read _GetProp_WrappedObject;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_UNMANAGEDCALLERSONLYATTRIBUTE)]
	IUnmanagedCallersOnlyAttribute = interface(IAttribute)
	['{E7557E63-D71C-41D4-AA1C-5F5632E28FFF}']
	{ private }
		function _GetFld_CallConvs: ICoreClrBridgeArray<IType>;
		procedure _SetFld_CallConvs(Value: ICoreClrBridgeArray<IType>);
		function _GetFld_EntryPoint: String;
		procedure _SetFld_EntryPoint(Value: String);
	{ public }
		property CallConvs: ICoreClrBridgeArray<IType> read _GetFld_CallConvs write _SetFld_CallConvs;
		property EntryPoint: String read _GetFld_EntryPoint write _SetFld_EntryPoint;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_UNMANAGEDFUNCTIONPOINTERATTRIBUTE)]
	IUnmanagedFunctionPointerAttribute = interface(IAttribute)
	['{1E8D7C19-3CF4-4E0D-B623-A09336A1AB8E}']
	{ private }
		function _GetFld_BestFitMapping: Boolean;
		procedure _SetFld_BestFitMapping(Value: Boolean);
		function _GetFld_CharSet: TCharSet;
		procedure _SetFld_CharSet(Value: TCharSet);
		function _GetFld_SetLastError: Boolean;
		procedure _SetFld_SetLastError(Value: Boolean);
		function _GetFld_ThrowOnUnmappableChar: Boolean;
		procedure _SetFld_ThrowOnUnmappableChar(Value: Boolean);
		function _GetProp_CallingConvention: TCallingConvention;
	{ public }
		property BestFitMapping: Boolean read _GetFld_BestFitMapping write _SetFld_BestFitMapping;
		property CharSet: TCharSet read _GetFld_CharSet write _SetFld_CharSet;
		property SetLastError: Boolean read _GetFld_SetLastError write _SetFld_SetLastError;
		property ThrowOnUnmappableChar: Boolean read _GetFld_ThrowOnUnmappableChar write _SetFld_ThrowOnUnmappableChar;
		property CallingConvention: TCallingConvention read _GetProp_CallingConvention;
	end;

	[CoreTypeSignature(SYSTEM_IO_UNMANAGEDMEMORYACCESSOR)]
	IUnmanagedMemoryAccessor = interface(IIDisposable)
	['{9359BC95-754E-4F02-AE79-2F888291B245}']
	{ private }
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Capacity: Int64;
	{ public }
		procedure Dispose();
		procedure Read(T: PTypeInfo; position: Int64; var structure: Variant{T});
		function ReadArray(T: PTypeInfo; position: Int64; array_: ICoreClrBridgeArray<Variant{T}>; offset: Integer; count: Integer): Integer;
		function ReadBoolean(position: Int64): Boolean;
		function ReadByte(position: Int64): Byte;
		function ReadChar(position: Int64): Char;
		function ReadDecimal(position: Int64): IDecimal;
		function ReadDouble(position: Int64): Double;
		function ReadInt16(position: Int64): SmallInt;
		function ReadInt32(position: Int64): Integer;
		function ReadInt64(position: Int64): Int64;
		function ReadSByte(position: Int64): Shortint;
		function ReadSingle(position: Int64): Single;
		function ReadUInt16(position: Int64): Word;
		function ReadUInt32(position: Int64): longword;
		function ReadUInt64(position: Int64): UInt64;
		procedure Write(position: Int64; value: Boolean); overload;
		procedure Write(position: Int64; value: Byte); overload;
		procedure Write(position: Int64; value: Char); overload;
		procedure Write(position: Int64; value: SmallInt); overload;
		procedure Write(position: Int64; value: Integer); overload;
		procedure Write(position: Int64; value: Int64); overload;
		procedure Write(position: Int64; value: IDecimal); overload;
		procedure Write(position: Int64; value: Single); overload;
		procedure Write(position: Int64; value: Double); overload;
		procedure Write(position: Int64; value: Shortint); overload;
		procedure Write(position: Int64; value: Word); overload;
		procedure Write(position: Int64; value: longword); overload;
		procedure Write(position: Int64; value: UInt64); overload;
		procedure Write(T: PTypeInfo; position: Int64; var structure: Variant{T}); overload;
		procedure WriteArray(T: PTypeInfo; position: Int64; array_: ICoreClrBridgeArray<Variant{T}>; offset: Integer; count: Integer);
		property CanRead: Boolean read _GetProp_CanRead;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Capacity: Int64 read _GetProp_Capacity;
	end;

	[CoreTypeSignature(SYSTEM_IO_UNMANAGEDMEMORYSTREAM)]
	IUnmanagedMemoryStream = interface(IStream)
	['{A315CBB8-A515-4361-B57F-1673267E22DC}']
	{ private }
		function _GetProp_CanRead: Boolean;
		function _GetProp_CanSeek: Boolean;
		function _GetProp_CanWrite: Boolean;
		function _GetProp_Capacity: Int64;
		function _GetProp_Length: Int64;
		function _GetProp_Position: Int64;
		procedure _SetProp_Position(Value: Int64);
		function _GetProp_PositionPointer: ICoreClrInstance;
		procedure _SetProp_PositionPointer(Value: ICoreClrInstance);
	{ public }
		procedure Flush();
		function FlushAsync(cancellationToken: ICancellationToken): ITask;
		function Read(buffer: TArray<Byte>; offset: Integer; count: Integer): Integer; overload;
		function Read(buffer: ISpan<Byte>): Integer; overload;
		function ReadAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask<Integer>; overload;
		function ReadAsync(buffer: IMemory<Byte>; cancellationToken: ICancellationToken): IValueTask<Integer>; overload;
		function ReadByte(): Integer;
		function Seek(offset: Int64; loc: TSeekOrigin): Int64;
		procedure SetLength(value: Int64);
		procedure Write(buffer: TArray<Byte>; offset: Integer; count: Integer); overload;
		procedure Write(buffer: IReadOnlySpan<Byte>); overload;
		function WriteAsync(buffer: TArray<Byte>; offset: Integer; count: Integer; cancellationToken: ICancellationToken): ITask; overload;
		function WriteAsync(buffer: IReadOnlyMemory<Byte>; cancellationToken: ICancellationToken): IValueTask; overload;
		procedure WriteByte(value: Byte);
		property CanRead: Boolean read _GetProp_CanRead;
		property CanSeek: Boolean read _GetProp_CanSeek;
		property CanWrite: Boolean read _GetProp_CanWrite;
		property Capacity: Int64 read _GetProp_Capacity;
		property Length: Int64 read _GetProp_Length;
		property Position: Int64 read _GetProp_Position write _SetProp_Position;
		property PositionPointer: ICoreClrInstance read _GetProp_PositionPointer write _SetProp_PositionPointer;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_UNOBSERVEDTASKEXCEPTIONEVENTARGS)]
	IUnobservedTaskExceptionEventArgs = interface(IEventArgs)
	['{0FD6644C-822C-4DEE-8073-441C6D84EEDC}']
	{ private }
		function _GetProp_Exception: IAggregateException;
		function _GetProp_Observed: Boolean;
	{ public }
		procedure SetObserved();
		property Exception: IAggregateException read _GetProp_Exception;
		property Observed: Boolean read _GetProp_Observed;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_UNSAFEVALUETYPEATTRIBUTE)]
	IUnsafeValueTypeAttribute = interface(IAttribute)
	['{2B824EE2-4098-4661-9FF4-998528C5D333}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_UNSUPPORTEDOSPLATFORMATTRIBUTE)]
	IUnsupportedOSPlatformAttribute = interface(IOSPlatformAttribute)
	['{4285580E-3DCD-4883-9B8C-FF66788C3AFD}']
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_UNVERIFIABLECODEATTRIBUTE)]
	IUnverifiableCodeAttribute = interface(IAttribute)
	['{9F8FA501-9260-4C2B-BA3A-667547598B68}']
	end;

	[CoreTypeSignature(SYSTEM_TEXT_UTF32ENCODING)]
	IUTF32Encoding = interface(IEncoding)
	['{C29D8579-0496-48DB-B254-FCDCC5A13FCE}']
	{ private }
		function _GetProp_Preamble: IReadOnlySpan<Byte>;
	{ public }
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(s: String): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(s: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetPreamble(): TArray<Byte>;
		function GetString(bytes: TArray<Byte>; index: Integer; count: Integer): String;
		property Preamble: IReadOnlySpan<Byte> read _GetProp_Preamble;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_UTF7ENCODING)]
	IUTF7Encoding = interface(IEncoding)
	['{4BEDA933-8AD5-4F2C-AB89-48DE26984486}']
	{ public }
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(s: String): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(s: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetString(bytes: TArray<Byte>; index: Integer; count: Integer): String;
	end;

	IUtf8Class = interface(ICoreClrClass)
	['{F7841E32-8138-4C9C-A85B-A0EE4C48A717}']
	{ public }
		{ class } function FromUtf16(source: IReadOnlySpan<Char>; destination: ISpan<Byte>; var charsRead: Integer; var bytesWritten: Integer; replaceInvalidSequences: Boolean; isFinalBlock: Boolean): TOperationStatus;
		{ class } function ToUtf16(source: IReadOnlySpan<Byte>; destination: ISpan<Char>; var bytesRead: Integer; var charsWritten: Integer; replaceInvalidSequences: Boolean; isFinalBlock: Boolean): TOperationStatus;
	end;

	[CoreTypeSignature(SYSTEM_TEXT_UNICODE_UTF8)]
	IUtf8 = interface(IObject)
	['{B923F553-A857-4309-A886-160DEAB06613}']
	end;

	[CoreTypeSignature(SYSTEM_TEXT_UTF8ENCODING)]
	IUTF8Encoding = interface(IEncoding)
	['{4B513693-D42B-4B60-99EF-C4627DC5AB8D}']
	{ private }
		function _GetProp_Preamble: IReadOnlySpan<Byte>;
	{ public }
		function GetByteCount(chars: TArray<Char>; index: Integer; count: Integer): Integer; overload;
		function GetByteCount(chars: String): Integer; overload;
		function GetByteCount(chars: IReadOnlySpan<Char>): Integer; overload;
		function GetByteCount(chars: ICoreClrInstance; count: Integer): Integer; overload;
		function GetBytes(s: String; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: TArray<Char>; charIndex: Integer; charCount: Integer; bytes: TArray<Byte>; byteIndex: Integer): Integer; overload;
		function GetBytes(chars: ICoreClrInstance; charCount: Integer; bytes: ICoreClrInstance; byteCount: Integer): Integer; overload;
		function GetBytes(chars: IReadOnlySpan<Char>; bytes: ISpan<Byte>): Integer; overload;
		function GetCharCount(bytes: TArray<Byte>; index: Integer; count: Integer): Integer; overload;
		function GetCharCount(bytes: ICoreClrInstance; count: Integer): Integer; overload;
		function GetCharCount(bytes: IReadOnlySpan<Byte>): Integer; overload;
		function GetChars(bytes: TArray<Byte>; byteIndex: Integer; byteCount: Integer; chars: TArray<Char>; charIndex: Integer): Integer; overload;
		function GetChars(bytes: ICoreClrInstance; byteCount: Integer; chars: ICoreClrInstance; charCount: Integer): Integer; overload;
		function GetChars(bytes: IReadOnlySpan<Byte>; chars: ISpan<Char>): Integer; overload;
		function GetDecoder(): IDecoder;
		function GetEncoder(): IEncoder;
		function GetMaxByteCount(charCount: Integer): Integer;
		function GetMaxCharCount(byteCount: Integer): Integer;
		function GetPreamble(): TArray<Byte>;
		function GetString(bytes: TArray<Byte>; index: Integer; count: Integer): String;
		property Preamble: IReadOnlySpan<Byte> read _GetProp_Preamble;
	end;

	IUtf8FormatterClass = interface(ICoreClrClass)
	['{69300490-B819-445D-9871-C903FA75D79D}']
	{ public }
		{ class } function TryFormat(value: Boolean; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: IDateTimeOffset; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: TDateTime; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: IDecimal; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Double; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Single; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: IGuid; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Byte; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Shortint; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Word; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: SmallInt; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: longword; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Integer; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: UInt64; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: Int64; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
		{ class } function TryFormat(value: ITimeSpan; destination: ISpan<Byte>; var bytesWritten: Integer; format: IStandardFormat): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_TEXT_UTF8FORMATTER)]
	IUtf8Formatter = interface(IObject)
	['{8D27C42C-3AED-48C5-89D9-4F9F71C51837}']
	end;

	IUtf8ParserClass = interface(ICoreClrClass)
	['{E502BA05-2EA8-409D-AD94-9F18BC7DFE4A}']
	{ public }
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Boolean; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: TDateTime; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: IDateTimeOffset; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: IDecimal; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Single; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Double; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: IGuid; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Shortint; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: SmallInt; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Integer; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Int64; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Byte; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: Word; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: longword; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: UInt64; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
		{ class } function TryParse(source: IReadOnlySpan<Byte>; var value: ITimeSpan; var bytesConsumed: Integer; standardFormat: Char): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_BUFFERS_TEXT_UTF8PARSER)]
	IUtf8Parser = interface(IObject)
	['{19D3E3CD-77CB-48E6-B9BA-CD40B0D32C02}']
	end;

	IValueTaskClass = interface(ICoreClrClass)
	['{593E391E-A61D-4382-8E77-2DF5EC5DC865}']
	{ private }
		{ class } function _GetProp_CompletedTask: IValueTask;
	{ public }
		{ class } function FromCanceled(cancellationToken: ICancellationToken): IValueTask;
		{ class } function FromException(exception: IException): IValueTask;
		{ class } function FromResult(TResult: PTypeInfo; result_: Variant{TResult}): IValueTask<Variant{TResult}>;
		{ class } property CompletedTask: IValueTask read _GetProp_CompletedTask;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_VALUETASK)]
	IValueTask = interface(IValueType)
	['{C2A89BDD-A1B2-4702-AD17-92256E5D09A3}']
	{ private }
		function _GetProp_IsCanceled: Boolean;
		function _GetProp_IsCompleted: Boolean;
		function _GetProp_IsCompletedSuccessfully: Boolean;
		function _GetProp_IsFaulted: Boolean;
	{ public }
		function AsTask(): ITask;
		function ConfigureAwait(continueOnCapturedContext: Boolean): IConfiguredValueTaskAwaitable;
		function Equals(other: IValueTask): Boolean;
		function GetAwaiter(): IValueTaskAwaiter;
		function Preserve(): IValueTask;
		property IsCanceled: Boolean read _GetProp_IsCanceled;
		property IsCompleted: Boolean read _GetProp_IsCompleted;
		property IsCompletedSuccessfully: Boolean read _GetProp_IsCompletedSuccessfully;
		property IsFaulted: Boolean read _GetProp_IsFaulted;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_TASKS_VALUETASK_1)]
	IValueTask<TResult> = interface(IValueType)
	['{CF0D23C6-A800-4EC8-A3D7-D70BFEB34B2C}']
	{ private }
		function _GetProp_IsCanceled: Boolean;
		function _GetProp_IsCompleted: Boolean;
		function _GetProp_IsCompletedSuccessfully: Boolean;
		function _GetProp_IsFaulted: Boolean;
		function _GetProp_Result: TResult;
	{ public }
		function AsTask(): ITask<TResult>;
		function ConfigureAwait(continueOnCapturedContext: Boolean): IConfiguredValueTaskAwaitable<TResult>;
		function Equals(other: IValueTask<TResult>): Boolean;
		function GetAwaiter(): IValueTaskAwaiter<TResult>;
		function Preserve(): IValueTask<TResult>;
		property IsCanceled: Boolean read _GetProp_IsCanceled;
		property IsCompleted: Boolean read _GetProp_IsCompleted;
		property IsCompletedSuccessfully: Boolean read _GetProp_IsCompletedSuccessfully;
		property IsFaulted: Boolean read _GetProp_IsFaulted;
		property &Result: TResult read _GetProp_Result;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_VALUETASKAWAITER)]
	IValueTaskAwaiter = interface(IValueType)
	['{DACA8309-B82A-405C-92BB-02FC3B3F843D}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		procedure GetResult();
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_VALUETASKAWAITER_1)]
	IValueTaskAwaiter<TResult> = interface(IValueType)
	['{4F69560A-0EC1-448E-8EB2-E7516BB62979}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		function GetResult(): TResult;
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	IValueTupleClass = interface(ICoreClrClass)
	['{04211A63-9555-43D1-8AA7-BD49029922A0}']
	{ public }
		{ class } function Create(): IValueTuple; overload;
		{ class } function Create(T1: PTypeInfo; item1: Variant{T1}): IValueTuple<Variant{T1}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}): IValueTuple<Variant{T1},Variant{T2}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}): IValueTuple<Variant{T1},Variant{T2},Variant{T3}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}; item7: Variant{T7}): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}>; overload;
		{ class } function Create(T1: PTypeInfo; T2: PTypeInfo; T3: PTypeInfo; T4: PTypeInfo; T5: PTypeInfo; T6: PTypeInfo; T7: PTypeInfo; T8: PTypeInfo; item1: Variant{T1}; item2: Variant{T2}; item3: Variant{T3}; item4: Variant{T4}; item5: Variant{T5}; item6: Variant{T6}; item7: Variant{T7}; item8: Variant{T8}): IValueTuple<Variant{T1},Variant{T2},Variant{T3},Variant{T4},Variant{T5},Variant{T6},Variant{T7}, IValueTuple<Variant{T8}>>; overload;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE)]
	IValueTuple = interface(IValueType)
	['{4D7C588F-65A1-4C89-BA29-8FFE174DB331}']
	{ public }
		function CompareTo(other: IValueTuple): Integer;
		function Equals(other: IValueTuple): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_1)]
	IValueTuple<T1> = interface(IValueType)
	['{BDA53D08-E0F2-4F4D-A631-1DF768B68259}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
	{ public }
		function CompareTo(other: IValueTuple<T1>): Integer;
		function Equals(other: IValueTuple<T1>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_2)]
	IValueTuple<T1,T2> = interface(IValueType)
	['{3E60189D-1FA2-463D-86A9-11F1B77A004E}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2>): Integer;
		function Equals(other: IValueTuple<T1,T2>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_3)]
	IValueTuple<T1,T2,T3> = interface(IValueType)
	['{227D6FE5-7E04-440B-9140-3F5029BB3F25}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_4)]
	IValueTuple<T1,T2,T3,T4> = interface(IValueType)
	['{A69BD7E1-DCBD-4414-90CA-E9AB5165F86E}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
		function _GetFld_Item4: T4;
		procedure _SetFld_Item4(Value: T4);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3,T4>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3,T4>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
		property Item4: T4 read _GetFld_Item4 write _SetFld_Item4;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_5)]
	IValueTuple<T1,T2,T3,T4,T5> = interface(IValueType)
	['{F10AC907-D7F6-4CEE-8CF6-4E5E39173D12}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
		function _GetFld_Item4: T4;
		procedure _SetFld_Item4(Value: T4);
		function _GetFld_Item5: T5;
		procedure _SetFld_Item5(Value: T5);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3,T4,T5>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3,T4,T5>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
		property Item4: T4 read _GetFld_Item4 write _SetFld_Item4;
		property Item5: T5 read _GetFld_Item5 write _SetFld_Item5;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_6)]
	IValueTuple<T1,T2,T3,T4,T5,T6> = interface(IValueType)
	['{BB3AF9C6-2466-4C34-949E-2FDFC9D34A75}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
		function _GetFld_Item4: T4;
		procedure _SetFld_Item4(Value: T4);
		function _GetFld_Item5: T5;
		procedure _SetFld_Item5(Value: T5);
		function _GetFld_Item6: T6;
		procedure _SetFld_Item6(Value: T6);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3,T4,T5,T6>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3,T4,T5,T6>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
		property Item4: T4 read _GetFld_Item4 write _SetFld_Item4;
		property Item5: T5 read _GetFld_Item5 write _SetFld_Item5;
		property Item6: T6 read _GetFld_Item6 write _SetFld_Item6;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_7)]
	IValueTuple<T1,T2,T3,T4,T5,T6,T7> = interface(IValueType)
	['{21E9E962-EE49-4980-A6CA-B74FADEC07D2}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
		function _GetFld_Item4: T4;
		procedure _SetFld_Item4(Value: T4);
		function _GetFld_Item5: T5;
		procedure _SetFld_Item5(Value: T5);
		function _GetFld_Item6: T6;
		procedure _SetFld_Item6(Value: T6);
		function _GetFld_Item7: T7;
		procedure _SetFld_Item7(Value: T7);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3,T4,T5,T6,T7>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3,T4,T5,T6,T7>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
		property Item4: T4 read _GetFld_Item4 write _SetFld_Item4;
		property Item5: T5 read _GetFld_Item5 write _SetFld_Item5;
		property Item6: T6 read _GetFld_Item6 write _SetFld_Item6;
		property Item7: T7 read _GetFld_Item7 write _SetFld_Item7;
	end;

	[CoreTypeSignature(SYSTEM_VALUETUPLE_8)]
	IValueTuple<T1,T2,T3,T4,T5,T6,T7,TRest> = interface(IValueType)
	['{CFFECBFA-549C-4E2A-860A-8E81BC1D35A6}']
	{ private }
		function _GetFld_Item1: T1;
		procedure _SetFld_Item1(Value: T1);
		function _GetFld_Item2: T2;
		procedure _SetFld_Item2(Value: T2);
		function _GetFld_Item3: T3;
		procedure _SetFld_Item3(Value: T3);
		function _GetFld_Item4: T4;
		procedure _SetFld_Item4(Value: T4);
		function _GetFld_Item5: T5;
		procedure _SetFld_Item5(Value: T5);
		function _GetFld_Item6: T6;
		procedure _SetFld_Item6(Value: T6);
		function _GetFld_Item7: T7;
		procedure _SetFld_Item7(Value: T7);
		function _GetFld_Rest: TRest;
		procedure _SetFld_Rest(Value: TRest);
	{ public }
		function CompareTo(other: IValueTuple<T1,T2,T3,T4,T5,T6,T7,TRest>): Integer;
		function Equals(other: IValueTuple<T1,T2,T3,T4,T5,T6,T7,TRest>): Boolean;
		property Item1: T1 read _GetFld_Item1 write _SetFld_Item1;
		property Item2: T2 read _GetFld_Item2 write _SetFld_Item2;
		property Item3: T3 read _GetFld_Item3 write _SetFld_Item3;
		property Item4: T4 read _GetFld_Item4 write _SetFld_Item4;
		property Item5: T5 read _GetFld_Item5 write _SetFld_Item5;
		property Item6: T6 read _GetFld_Item6 write _SetFld_Item6;
		property Item7: T7 read _GetFld_Item7 write _SetFld_Item7;
		property Rest: TRest read _GetFld_Rest write _SetFld_Rest;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_COMTYPES_VARDESC)]
	IVARDESC = interface(IValueType)
	['{9CC1690E-7039-42D4-AA21-F03716386456}']
	{ private }
		function _GetFld_desc: IDESCUNION_1;
		procedure _SetFld_desc(Value: IDESCUNION_1);
		function _GetFld_elemdescVar: IELEMDESC;
		procedure _SetFld_elemdescVar(Value: IELEMDESC);
		function _GetFld_lpstrSchema: String;
		procedure _SetFld_lpstrSchema(Value: String);
		function _GetFld_memid: Integer;
		procedure _SetFld_memid(Value: Integer);
		function _GetFld_varkind: TVARKIND;
		procedure _SetFld_varkind(Value: TVARKIND);
		function _GetFld_wVarFlags: SmallInt;
		procedure _SetFld_wVarFlags(Value: SmallInt);
	{ public }
		property desc: IDESCUNION_1 read _GetFld_desc write _SetFld_desc;
		property elemdescVar: IELEMDESC read _GetFld_elemdescVar write _SetFld_elemdescVar;
		property lpstrSchema: String read _GetFld_lpstrSchema write _SetFld_lpstrSchema;
		property memid: Integer read _GetFld_memid write _SetFld_memid;
		property varkind: TVARKIND read _GetFld_varkind write _SetFld_varkind;
		property wVarFlags: SmallInt read _GetFld_wVarFlags write _SetFld_wVarFlags;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTEROPSERVICES_VARIANTWRAPPER)]
	IVariantWrapper = interface(IObject)
	['{E35EF845-575C-4458-BEC7-E721CCCC990D}']
	{ private }
		function _GetProp_WrappedObject: Variant;
	{ public }
		property WrappedObject: Variant read _GetProp_WrappedObject;
	end;

	IVectorClass = interface(ICoreClrClass)
	['{EF5801AC-4201-410C-842E-7D903F38CAE5}']
	{ private }
		{ class } function _GetProp_IsHardwareAccelerated: Boolean;
	{ public }
		{ class } function Abs(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Add(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function AndNot(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function AsVectorByte(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Byte>;
		{ class } function AsVectorDouble(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Double>;
		{ class } function AsVectorInt16(T: PTypeInfo; value: IVector<Variant{T}>): IVector<SmallInt>;
		{ class } function AsVectorInt32(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Integer>;
		{ class } function AsVectorInt64(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Int64>;
		{ class } function AsVectorSByte(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Shortint>;
		{ class } function AsVectorSingle(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Single>;
		{ class } function AsVectorUInt16(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Word>;
		{ class } function AsVectorUInt32(T: PTypeInfo; value: IVector<Variant{T}>): IVector<longword>;
		{ class } function AsVectorUInt64(T: PTypeInfo; value: IVector<Variant{T}>): IVector<UInt64>;
		{ class } function BitwiseAnd(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function BitwiseOr(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Ceiling(value: IVector<Single>): IVector<Single>; overload;
		{ class } function Ceiling(value: IVector<Double>): IVector<Double>; overload;
		{ class } function ConditionalSelect(condition: IVector<Integer>; left: IVector<Single>; right: IVector<Single>): IVector<Single>; overload;
		{ class } function ConditionalSelect(condition: IVector<Int64>; left: IVector<Double>; right: IVector<Double>): IVector<Double>; overload;
		{ class } function ConditionalSelect(T: PTypeInfo; condition: IVector<Variant{T}>; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function ConvertToDouble(value: IVector<Int64>): IVector<Double>; overload;
		{ class } function ConvertToDouble(value: IVector<UInt64>): IVector<Double>; overload;
		{ class } function ConvertToInt32(value: IVector<Single>): IVector<Integer>;
		{ class } function ConvertToInt64(value: IVector<Double>): IVector<Int64>;
		{ class } function ConvertToSingle(value: IVector<Integer>): IVector<Single>; overload;
		{ class } function ConvertToSingle(value: IVector<longword>): IVector<Single>; overload;
		{ class } function ConvertToUInt32(value: IVector<Single>): IVector<longword>;
		{ class } function ConvertToUInt64(value: IVector<Double>): IVector<UInt64>;
		{ class } function Divide(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Dot(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Variant{T};
		{ class } function Equals(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function Equals(left: IVector<Single>; right: IVector<Single>): IVector<Integer>; overload;
		{ class } function Equals(left: IVector<Integer>; right: IVector<Integer>): IVector<Integer>; overload;
		{ class } function Equals(left: IVector<Double>; right: IVector<Double>): IVector<Int64>; overload;
		{ class } function Equals(left: IVector<Int64>; right: IVector<Int64>): IVector<Int64>; overload;
		{ class } function EqualsAll(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function EqualsAny(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function Floor(value: IVector<Single>): IVector<Single>; overload;
		{ class } function Floor(value: IVector<Double>): IVector<Double>; overload;
		{ class } function GreaterThan(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function GreaterThan(left: IVector<Single>; right: IVector<Single>): IVector<Integer>; overload;
		{ class } function GreaterThan(left: IVector<Integer>; right: IVector<Integer>): IVector<Integer>; overload;
		{ class } function GreaterThan(left: IVector<Double>; right: IVector<Double>): IVector<Int64>; overload;
		{ class } function GreaterThan(left: IVector<Int64>; right: IVector<Int64>): IVector<Int64>; overload;
		{ class } function GreaterThanAll(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function GreaterThanAny(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function GreaterThanOrEqual(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function GreaterThanOrEqual(left: IVector<Single>; right: IVector<Single>): IVector<Integer>; overload;
		{ class } function GreaterThanOrEqual(left: IVector<Integer>; right: IVector<Integer>): IVector<Integer>; overload;
		{ class } function GreaterThanOrEqual(left: IVector<Int64>; right: IVector<Int64>): IVector<Int64>; overload;
		{ class } function GreaterThanOrEqual(left: IVector<Double>; right: IVector<Double>): IVector<Int64>; overload;
		{ class } function GreaterThanOrEqualAll(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function GreaterThanOrEqualAny(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function LessThan(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function LessThan(left: IVector<Single>; right: IVector<Single>): IVector<Integer>; overload;
		{ class } function LessThan(left: IVector<Integer>; right: IVector<Integer>): IVector<Integer>; overload;
		{ class } function LessThan(left: IVector<Double>; right: IVector<Double>): IVector<Int64>; overload;
		{ class } function LessThan(left: IVector<Int64>; right: IVector<Int64>): IVector<Int64>; overload;
		{ class } function LessThanAll(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function LessThanAny(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function LessThanOrEqual(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function LessThanOrEqual(left: IVector<Single>; right: IVector<Single>): IVector<Integer>; overload;
		{ class } function LessThanOrEqual(left: IVector<Integer>; right: IVector<Integer>): IVector<Integer>; overload;
		{ class } function LessThanOrEqual(left: IVector<Int64>; right: IVector<Int64>): IVector<Int64>; overload;
		{ class } function LessThanOrEqual(left: IVector<Double>; right: IVector<Double>): IVector<Int64>; overload;
		{ class } function LessThanOrEqualAll(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function LessThanOrEqualAny(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): Boolean;
		{ class } function Max(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Min(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Multiply(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function Multiply(T: PTypeInfo; left: IVector<Variant{T}>; right: Variant{T}): IVector<Variant{T}>; overload;
		{ class } function Multiply(T: PTypeInfo; left: Variant{T}; right: IVector<Variant{T}>): IVector<Variant{T}>; overload;
		{ class } function Narrow(low: IVector<Word>; high: IVector<Word>): IVector<Byte>; overload;
		{ class } function Narrow(low: IVector<longword>; high: IVector<longword>): IVector<Word>; overload;
		{ class } function Narrow(low: IVector<UInt64>; high: IVector<UInt64>): IVector<longword>; overload;
		{ class } function Narrow(low: IVector<SmallInt>; high: IVector<SmallInt>): IVector<Shortint>; overload;
		{ class } function Narrow(low: IVector<Integer>; high: IVector<Integer>): IVector<SmallInt>; overload;
		{ class } function Narrow(low: IVector<Int64>; high: IVector<Int64>): IVector<Integer>; overload;
		{ class } function Narrow(low: IVector<Double>; high: IVector<Double>): IVector<Single>; overload;
		{ class } function Negate(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function OnesComplement(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function SquareRoot(T: PTypeInfo; value: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } function Subtract(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } procedure Widen(source: IVector<Byte>; var low: IVector<Word>; var high: IVector<Word>); overload;
		{ class } procedure Widen(source: IVector<Word>; var low: IVector<longword>; var high: IVector<longword>); overload;
		{ class } procedure Widen(source: IVector<longword>; var low: IVector<UInt64>; var high: IVector<UInt64>); overload;
		{ class } procedure Widen(source: IVector<Shortint>; var low: IVector<SmallInt>; var high: IVector<SmallInt>); overload;
		{ class } procedure Widen(source: IVector<SmallInt>; var low: IVector<Integer>; var high: IVector<Integer>); overload;
		{ class } procedure Widen(source: IVector<Integer>; var low: IVector<Int64>; var high: IVector<Int64>); overload;
		{ class } procedure Widen(source: IVector<Single>; var low: IVector<Double>; var high: IVector<Double>); overload;
		{ class } function &Xor(T: PTypeInfo; left: IVector<Variant{T}>; right: IVector<Variant{T}>): IVector<Variant{T}>;
		{ class } property IsHardwareAccelerated: Boolean read _GetProp_IsHardwareAccelerated;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_VECTOR)]
	IVector = interface(IObject)
	['{53E21157-E341-4587-8D14-4B22878E8A89}']
	end;

	IVectorClass<T> = interface(ICoreClrClass)
	['{3F63AF37-4DC8-41B5-96F1-1BD10E74AC87}']
	{ private }
		{ class } function _GetProp_Count: Integer;
		{ class } function _GetProp_One: IVector<T>;
		{ class } function _GetProp_Zero: IVector<T>;
	{ public }
		{ class } property Count: Integer read _GetProp_Count;
		{ class } property One: IVector<T> read _GetProp_One;
		{ class } property Zero: IVector<T> read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_VECTOR_1)]
	IVector<T> = interface(IValueType)
	['{4CB29C14-601B-4612-82C5-953B7E0D0B43}']
	{ private }
		function _GetProp_Item(index: Integer): T;
	{ public }
		procedure CopyTo(destination: ISpan<Byte>); overload;
		procedure CopyTo(destination: ISpan<T>); overload;
		procedure CopyTo(destination: ICoreClrBridgeArray<T>); overload;
		procedure CopyTo(destination: ICoreClrBridgeArray<T>; startIndex: Integer); overload;
		function Equals(other: IVector<T>): Boolean;
		function ToString(format: String): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		function TryCopyTo(destination: ISpan<Byte>): Boolean; overload;
		function TryCopyTo(destination: ISpan<T>): Boolean; overload;
		property Item[index: Integer]: T read _GetProp_Item; default;
	end;

	IVector128Class = interface(ICoreClrClass)
	['{018AE5CB-D6DA-4356-B221-C43827A7FE31}']
	{ public }
		{ class } function &As(T: PTypeInfo; U: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Variant{U}>;
		{ class } function AsByte(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Byte>;
		{ class } function AsDouble(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Double>;
		{ class } function AsInt16(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<SmallInt>;
		{ class } function AsInt32(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Integer>;
		{ class } function AsInt64(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Int64>;
		{ class } function AsSByte(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Shortint>;
		{ class } function AsSingle(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Single>;
		{ class } function AsUInt16(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<Word>;
		{ class } function AsUInt32(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<longword>;
		{ class } function AsUInt64(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector128<UInt64>;
		{ class } function AsVector(T: PTypeInfo; value: IVector128<Variant{T}>): IVector<Variant{T}>;
		{ class } function AsVector128(value: IVector2): IVector128<Single>; overload;
		{ class } function AsVector128(value: IVector3): IVector128<Single>; overload;
		{ class } function AsVector128(value: IVector4): IVector128<Single>; overload;
		{ class } function AsVector128(T: PTypeInfo; value: IVector<Variant{T}>): IVector128<Variant{T}>; overload;
		{ class } function AsVector2(value: IVector128<Single>): IVector2;
		{ class } function AsVector3(value: IVector128<Single>): IVector3;
		{ class } function AsVector4(value: IVector128<Single>): IVector4;
		{ class } function Create(value: Byte): IVector128<Byte>; overload;
		{ class } function Create(value: Double): IVector128<Double>; overload;
		{ class } function Create(value: SmallInt): IVector128<SmallInt>; overload;
		{ class } function Create(value: Integer): IVector128<Integer>; overload;
		{ class } function Create(value: Int64): IVector128<Int64>; overload;
		{ class } function Create(value: Shortint): IVector128<Shortint>; overload;
		{ class } function Create(value: Single): IVector128<Single>; overload;
		{ class } function Create(value: Word): IVector128<Word>; overload;
		{ class } function Create(value: longword): IVector128<longword>; overload;
		{ class } function Create(value: UInt64): IVector128<UInt64>; overload;
		{ class } function Create(e0: Byte; e1: Byte; e2: Byte; e3: Byte; e4: Byte; e5: Byte; e6: Byte; e7: Byte; e8: Byte; e9: Byte; e10: Byte; e11: Byte; e12: Byte; e13: Byte; e14: Byte; e15: Byte): IVector128<Byte>; overload;
		{ class } function Create(e0: Shortint; e1: Shortint; e2: Shortint; e3: Shortint; e4: Shortint; e5: Shortint; e6: Shortint; e7: Shortint; e8: Shortint; e9: Shortint; e10: Shortint; e11: Shortint; e12: Shortint; e13: Shortint; e14: Shortint; e15: Shortint): IVector128<Shortint>; overload;
		{ class } function Create(e0: Double; e1: Double): IVector128<Double>; overload;
		{ class } function Create(e0: Int64; e1: Int64): IVector128<Int64>; overload;
		{ class } function Create(e0: UInt64; e1: UInt64): IVector128<UInt64>; overload;
		{ class } function Create(lower: IVector64<Byte>; upper: IVector64<Byte>): IVector128<Byte>; overload;
		{ class } function Create(lower: IVector64<Double>; upper: IVector64<Double>): IVector128<Double>; overload;
		{ class } function Create(lower: IVector64<SmallInt>; upper: IVector64<SmallInt>): IVector128<SmallInt>; overload;
		{ class } function Create(lower: IVector64<Integer>; upper: IVector64<Integer>): IVector128<Integer>; overload;
		{ class } function Create(lower: IVector64<Int64>; upper: IVector64<Int64>): IVector128<Int64>; overload;
		{ class } function Create(lower: IVector64<Shortint>; upper: IVector64<Shortint>): IVector128<Shortint>; overload;
		{ class } function Create(lower: IVector64<Single>; upper: IVector64<Single>): IVector128<Single>; overload;
		{ class } function Create(lower: IVector64<Word>; upper: IVector64<Word>): IVector128<Word>; overload;
		{ class } function Create(lower: IVector64<longword>; upper: IVector64<longword>): IVector128<longword>; overload;
		{ class } function Create(lower: IVector64<UInt64>; upper: IVector64<UInt64>): IVector128<UInt64>; overload;
		{ class } function Create(e0: SmallInt; e1: SmallInt; e2: SmallInt; e3: SmallInt; e4: SmallInt; e5: SmallInt; e6: SmallInt; e7: SmallInt): IVector128<SmallInt>; overload;
		{ class } function Create(e0: Word; e1: Word; e2: Word; e3: Word; e4: Word; e5: Word; e6: Word; e7: Word): IVector128<Word>; overload;
		{ class } function Create(e0: Integer; e1: Integer; e2: Integer; e3: Integer): IVector128<Integer>; overload;
		{ class } function Create(e0: Single; e1: Single; e2: Single; e3: Single): IVector128<Single>; overload;
		{ class } function Create(e0: longword; e1: longword; e2: longword; e3: longword): IVector128<longword>; overload;
		{ class } function CreateScalar(value: Byte): IVector128<Byte>; overload;
		{ class } function CreateScalar(value: Double): IVector128<Double>; overload;
		{ class } function CreateScalar(value: SmallInt): IVector128<SmallInt>; overload;
		{ class } function CreateScalar(value: Integer): IVector128<Integer>; overload;
		{ class } function CreateScalar(value: Int64): IVector128<Int64>; overload;
		{ class } function CreateScalar(value: Shortint): IVector128<Shortint>; overload;
		{ class } function CreateScalar(value: Single): IVector128<Single>; overload;
		{ class } function CreateScalar(value: Word): IVector128<Word>; overload;
		{ class } function CreateScalar(value: longword): IVector128<longword>; overload;
		{ class } function CreateScalar(value: UInt64): IVector128<UInt64>; overload;
		{ class } function CreateScalarUnsafe(value: Byte): IVector128<Byte>; overload;
		{ class } function CreateScalarUnsafe(value: Double): IVector128<Double>; overload;
		{ class } function CreateScalarUnsafe(value: SmallInt): IVector128<SmallInt>; overload;
		{ class } function CreateScalarUnsafe(value: Integer): IVector128<Integer>; overload;
		{ class } function CreateScalarUnsafe(value: Int64): IVector128<Int64>; overload;
		{ class } function CreateScalarUnsafe(value: Shortint): IVector128<Shortint>; overload;
		{ class } function CreateScalarUnsafe(value: Single): IVector128<Single>; overload;
		{ class } function CreateScalarUnsafe(value: Word): IVector128<Word>; overload;
		{ class } function CreateScalarUnsafe(value: longword): IVector128<longword>; overload;
		{ class } function CreateScalarUnsafe(value: UInt64): IVector128<UInt64>; overload;
		{ class } function GetElement(T: PTypeInfo; vector: IVector128<Variant{T}>; index: Integer): Variant{T};
		{ class } function GetLower(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector64<Variant{T}>;
		{ class } function GetUpper(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector64<Variant{T}>;
		{ class } function ToScalar(T: PTypeInfo; vector: IVector128<Variant{T}>): Variant{T};
		{ class } function ToVector256(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector256<Variant{T}>;
		{ class } function ToVector256Unsafe(T: PTypeInfo; vector: IVector128<Variant{T}>): IVector256<Variant{T}>;
		{ class } function WithElement(T: PTypeInfo; vector: IVector128<Variant{T}>; index: Integer; value: Variant{T}): IVector128<Variant{T}>;
		{ class } function WithLower(T: PTypeInfo; vector: IVector128<Variant{T}>; value: IVector64<Variant{T}>): IVector128<Variant{T}>;
		{ class } function WithUpper(T: PTypeInfo; vector: IVector128<Variant{T}>; value: IVector64<Variant{T}>): IVector128<Variant{T}>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR128)]
	IVector128 = interface(IObject)
	['{1936D283-4D90-42C3-93D3-009097640D58}']
	end;

	IVector128Class<T> = interface(ICoreClrClass)
	['{E7E49BCB-41CD-47A6-AC4D-C8BE501AB9B4}']
	{ private }
		{ class } function _GetProp_AllBitsSet: IVector128<T>;
		{ class } function _GetProp_Count: Integer;
		{ class } function _GetProp_Zero: IVector128<T>;
	{ public }
		{ class } property AllBitsSet: IVector128<T> read _GetProp_AllBitsSet;
		{ class } property Count: Integer read _GetProp_Count;
		{ class } property Zero: IVector128<T> read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1)]
	IVector128<T> = interface(IValueType)
	['{71D8A73F-7238-4C60-9706-0CCE845624FC}']
	{ public }
		function Equals(other: IVector128<T>): Boolean;
	end;

	IVector2Class = interface(ICoreClrClass)
	['{C5BB4B59-6701-4307-A8E3-3877F6F83FE7}']
	{ private }
		{ class } function _GetProp_One: IVector2;
		{ class } function _GetProp_UnitX: IVector2;
		{ class } function _GetProp_UnitY: IVector2;
		{ class } function _GetProp_Zero: IVector2;
	{ public }
		{ class } function Abs(value: IVector2): IVector2;
		{ class } function Add(left: IVector2; right: IVector2): IVector2;
		{ class } function Clamp(value1: IVector2; min: IVector2; max: IVector2): IVector2;
		{ class } function Distance(value1: IVector2; value2: IVector2): Single;
		{ class } function DistanceSquared(value1: IVector2; value2: IVector2): Single;
		{ class } function Divide(left: IVector2; right: IVector2): IVector2; overload;
		{ class } function Divide(left: IVector2; divisor: Single): IVector2; overload;
		{ class } function Dot(value1: IVector2; value2: IVector2): Single;
		{ class } function Lerp(value1: IVector2; value2: IVector2; amount: Single): IVector2;
		{ class } function Max(value1: IVector2; value2: IVector2): IVector2;
		{ class } function Min(value1: IVector2; value2: IVector2): IVector2;
		{ class } function Multiply(left: IVector2; right: IVector2): IVector2; overload;
		{ class } function Multiply(left: IVector2; right: Single): IVector2; overload;
		{ class } function Multiply(left: Single; right: IVector2): IVector2; overload;
		{ class } function Negate(value: IVector2): IVector2;
		{ class } function Normalize(value: IVector2): IVector2;
		{ class } function Reflect(vector: IVector2; normal: IVector2): IVector2;
		{ class } function SquareRoot(value: IVector2): IVector2;
		{ class } function Subtract(left: IVector2; right: IVector2): IVector2;
		{ class } function Transform(position: IVector2; matrix: IMatrix3x2): IVector2; overload;
		{ class } function Transform(position: IVector2; matrix: IMatrix4x4): IVector2; overload;
		{ class } function Transform(value: IVector2; rotation: IQuaternion): IVector2; overload;
		{ class } function TransformNormal(normal: IVector2; matrix: IMatrix3x2): IVector2; overload;
		{ class } function TransformNormal(normal: IVector2; matrix: IMatrix4x4): IVector2; overload;
		{ class } property One: IVector2 read _GetProp_One;
		{ class } property UnitX: IVector2 read _GetProp_UnitX;
		{ class } property UnitY: IVector2 read _GetProp_UnitY;
		{ class } property Zero: IVector2 read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_VECTOR2)]
	IVector2 = interface(IValueType)
	['{00F2F149-58AC-4551-8CC3-3E0DD70CF013}']
	{ private }
		function _GetFld_X: Single;
		procedure _SetFld_X(Value: Single);
		function _GetFld_Y: Single;
		procedure _SetFld_Y(Value: Single);
	{ public }
		procedure CopyTo(array_: TArray<Single>); overload;
		procedure CopyTo(array_: TArray<Single>; index: Integer); overload;
		function Equals(other: IVector2): Boolean;
		function Length(): Single;
		function LengthSquared(): Single;
		function ToString(format: String): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		property X: Single read _GetFld_X write _SetFld_X;
		property Y: Single read _GetFld_Y write _SetFld_Y;
	end;

	IVector256Class = interface(ICoreClrClass)
	['{970417D8-D741-4662-AFAF-7F35B7958D88}']
	{ public }
		{ class } function &As(T: PTypeInfo; U: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Variant{U}>;
		{ class } function AsByte(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Byte>;
		{ class } function AsDouble(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Double>;
		{ class } function AsInt16(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<SmallInt>;
		{ class } function AsInt32(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Integer>;
		{ class } function AsInt64(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Int64>;
		{ class } function AsSByte(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Shortint>;
		{ class } function AsSingle(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Single>;
		{ class } function AsUInt16(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<Word>;
		{ class } function AsUInt32(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<longword>;
		{ class } function AsUInt64(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector256<UInt64>;
		{ class } function AsVector(T: PTypeInfo; value: IVector256<Variant{T}>): IVector<Variant{T}>;
		{ class } function AsVector256(T: PTypeInfo; value: IVector<Variant{T}>): IVector256<Variant{T}>;
		{ class } function Create(value: Byte): IVector256<Byte>; overload;
		{ class } function Create(value: Double): IVector256<Double>; overload;
		{ class } function Create(value: SmallInt): IVector256<SmallInt>; overload;
		{ class } function Create(value: Integer): IVector256<Integer>; overload;
		{ class } function Create(value: Int64): IVector256<Int64>; overload;
		{ class } function Create(value: Shortint): IVector256<Shortint>; overload;
		{ class } function Create(value: Single): IVector256<Single>; overload;
		{ class } function Create(value: Word): IVector256<Word>; overload;
		{ class } function Create(value: longword): IVector256<longword>; overload;
		{ class } function Create(value: UInt64): IVector256<UInt64>; overload;
		{ class } function Create(e0: Byte; e1: Byte; e2: Byte; e3: Byte; e4: Byte; e5: Byte; e6: Byte; e7: Byte; e8: Byte; e9: Byte; e10: Byte; e11: Byte; e12: Byte; e13: Byte; e14: Byte; e15: Byte; e16: Byte; e17: Byte; e18: Byte; e19: Byte; e20: Byte; e21: Byte; e22: Byte; e23: Byte; e24: Byte; e25: Byte; e26: Byte; e27: Byte; e28: Byte; e29: Byte; e30: Byte; e31: Byte): IVector256<Byte>; overload;
		{ class } function Create(e0: Shortint; e1: Shortint; e2: Shortint; e3: Shortint; e4: Shortint; e5: Shortint; e6: Shortint; e7: Shortint; e8: Shortint; e9: Shortint; e10: Shortint; e11: Shortint; e12: Shortint; e13: Shortint; e14: Shortint; e15: Shortint; e16: Shortint; e17: Shortint; e18: Shortint; e19: Shortint; e20: Shortint; e21: Shortint; e22: Shortint; e23: Shortint; e24: Shortint; e25: Shortint; e26: Shortint; e27: Shortint; e28: Shortint; e29: Shortint; e30: Shortint; e31: Shortint): IVector256<Shortint>; overload;
		{ class } function Create(e0: Double; e1: Double; e2: Double; e3: Double): IVector256<Double>; overload;
		{ class } function Create(e0: Int64; e1: Int64; e2: Int64; e3: Int64): IVector256<Int64>; overload;
		{ class } function Create(e0: UInt64; e1: UInt64; e2: UInt64; e3: UInt64): IVector256<UInt64>; overload;
		{ class } function Create(e0: SmallInt; e1: SmallInt; e2: SmallInt; e3: SmallInt; e4: SmallInt; e5: SmallInt; e6: SmallInt; e7: SmallInt; e8: SmallInt; e9: SmallInt; e10: SmallInt; e11: SmallInt; e12: SmallInt; e13: SmallInt; e14: SmallInt; e15: SmallInt): IVector256<SmallInt>; overload;
		{ class } function Create(e0: Word; e1: Word; e2: Word; e3: Word; e4: Word; e5: Word; e6: Word; e7: Word; e8: Word; e9: Word; e10: Word; e11: Word; e12: Word; e13: Word; e14: Word; e15: Word): IVector256<Word>; overload;
		{ class } function Create(e0: Integer; e1: Integer; e2: Integer; e3: Integer; e4: Integer; e5: Integer; e6: Integer; e7: Integer): IVector256<Integer>; overload;
		{ class } function Create(e0: Single; e1: Single; e2: Single; e3: Single; e4: Single; e5: Single; e6: Single; e7: Single): IVector256<Single>; overload;
		{ class } function Create(e0: longword; e1: longword; e2: longword; e3: longword; e4: longword; e5: longword; e6: longword; e7: longword): IVector256<longword>; overload;
		{ class } function Create(lower: IVector128<Byte>; upper: IVector128<Byte>): IVector256<Byte>; overload;
		{ class } function Create(lower: IVector128<Double>; upper: IVector128<Double>): IVector256<Double>; overload;
		{ class } function Create(lower: IVector128<SmallInt>; upper: IVector128<SmallInt>): IVector256<SmallInt>; overload;
		{ class } function Create(lower: IVector128<Integer>; upper: IVector128<Integer>): IVector256<Integer>; overload;
		{ class } function Create(lower: IVector128<Int64>; upper: IVector128<Int64>): IVector256<Int64>; overload;
		{ class } function Create(lower: IVector128<Shortint>; upper: IVector128<Shortint>): IVector256<Shortint>; overload;
		{ class } function Create(lower: IVector128<Single>; upper: IVector128<Single>): IVector256<Single>; overload;
		{ class } function Create(lower: IVector128<Word>; upper: IVector128<Word>): IVector256<Word>; overload;
		{ class } function Create(lower: IVector128<longword>; upper: IVector128<longword>): IVector256<longword>; overload;
		{ class } function Create(lower: IVector128<UInt64>; upper: IVector128<UInt64>): IVector256<UInt64>; overload;
		{ class } function CreateScalar(value: Byte): IVector256<Byte>; overload;
		{ class } function CreateScalar(value: Double): IVector256<Double>; overload;
		{ class } function CreateScalar(value: SmallInt): IVector256<SmallInt>; overload;
		{ class } function CreateScalar(value: Integer): IVector256<Integer>; overload;
		{ class } function CreateScalar(value: Int64): IVector256<Int64>; overload;
		{ class } function CreateScalar(value: Shortint): IVector256<Shortint>; overload;
		{ class } function CreateScalar(value: Single): IVector256<Single>; overload;
		{ class } function CreateScalar(value: Word): IVector256<Word>; overload;
		{ class } function CreateScalar(value: longword): IVector256<longword>; overload;
		{ class } function CreateScalar(value: UInt64): IVector256<UInt64>; overload;
		{ class } function CreateScalarUnsafe(value: Byte): IVector256<Byte>; overload;
		{ class } function CreateScalarUnsafe(value: Double): IVector256<Double>; overload;
		{ class } function CreateScalarUnsafe(value: SmallInt): IVector256<SmallInt>; overload;
		{ class } function CreateScalarUnsafe(value: Integer): IVector256<Integer>; overload;
		{ class } function CreateScalarUnsafe(value: Int64): IVector256<Int64>; overload;
		{ class } function CreateScalarUnsafe(value: Shortint): IVector256<Shortint>; overload;
		{ class } function CreateScalarUnsafe(value: Single): IVector256<Single>; overload;
		{ class } function CreateScalarUnsafe(value: Word): IVector256<Word>; overload;
		{ class } function CreateScalarUnsafe(value: longword): IVector256<longword>; overload;
		{ class } function CreateScalarUnsafe(value: UInt64): IVector256<UInt64>; overload;
		{ class } function GetElement(T: PTypeInfo; vector: IVector256<Variant{T}>; index: Integer): Variant{T};
		{ class } function GetLower(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector128<Variant{T}>;
		{ class } function GetUpper(T: PTypeInfo; vector: IVector256<Variant{T}>): IVector128<Variant{T}>;
		{ class } function ToScalar(T: PTypeInfo; vector: IVector256<Variant{T}>): Variant{T};
		{ class } function WithElement(T: PTypeInfo; vector: IVector256<Variant{T}>; index: Integer; value: Variant{T}): IVector256<Variant{T}>;
		{ class } function WithLower(T: PTypeInfo; vector: IVector256<Variant{T}>; value: IVector128<Variant{T}>): IVector256<Variant{T}>;
		{ class } function WithUpper(T: PTypeInfo; vector: IVector256<Variant{T}>; value: IVector128<Variant{T}>): IVector256<Variant{T}>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR256)]
	IVector256 = interface(IObject)
	['{317B2954-7D77-402F-B9E7-28F71FBAA19D}']
	end;

	IVector256Class<T> = interface(ICoreClrClass)
	['{AA86F93D-381C-4943-ADB2-E032643679D9}']
	{ private }
		{ class } function _GetProp_AllBitsSet: IVector256<T>;
		{ class } function _GetProp_Count: Integer;
		{ class } function _GetProp_Zero: IVector256<T>;
	{ public }
		{ class } property AllBitsSet: IVector256<T> read _GetProp_AllBitsSet;
		{ class } property Count: Integer read _GetProp_Count;
		{ class } property Zero: IVector256<T> read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1)]
	IVector256<T> = interface(IValueType)
	['{14037792-C4DF-4A74-97CA-0787F45BB125}']
	{ public }
		function Equals(other: IVector256<T>): Boolean;
	end;

	IVector3Class = interface(ICoreClrClass)
	['{66401B33-4459-4FD4-A7DA-8EFE3FAB4BBF}']
	{ private }
		{ class } function _GetProp_One: IVector3;
		{ class } function _GetProp_UnitX: IVector3;
		{ class } function _GetProp_UnitY: IVector3;
		{ class } function _GetProp_UnitZ: IVector3;
		{ class } function _GetProp_Zero: IVector3;
	{ public }
		{ class } function Abs(value: IVector3): IVector3;
		{ class } function Add(left: IVector3; right: IVector3): IVector3;
		{ class } function Clamp(value1: IVector3; min: IVector3; max: IVector3): IVector3;
		{ class } function Cross(vector1: IVector3; vector2: IVector3): IVector3;
		{ class } function Distance(value1: IVector3; value2: IVector3): Single;
		{ class } function DistanceSquared(value1: IVector3; value2: IVector3): Single;
		{ class } function Divide(left: IVector3; right: IVector3): IVector3; overload;
		{ class } function Divide(left: IVector3; divisor: Single): IVector3; overload;
		{ class } function Dot(vector1: IVector3; vector2: IVector3): Single;
		{ class } function Lerp(value1: IVector3; value2: IVector3; amount: Single): IVector3;
		{ class } function Max(value1: IVector3; value2: IVector3): IVector3;
		{ class } function Min(value1: IVector3; value2: IVector3): IVector3;
		{ class } function Multiply(left: IVector3; right: IVector3): IVector3; overload;
		{ class } function Multiply(left: IVector3; right: Single): IVector3; overload;
		{ class } function Multiply(left: Single; right: IVector3): IVector3; overload;
		{ class } function Negate(value: IVector3): IVector3;
		{ class } function Normalize(value: IVector3): IVector3;
		{ class } function Reflect(vector: IVector3; normal: IVector3): IVector3;
		{ class } function SquareRoot(value: IVector3): IVector3;
		{ class } function Subtract(left: IVector3; right: IVector3): IVector3;
		{ class } function Transform(position: IVector3; matrix: IMatrix4x4): IVector3; overload;
		{ class } function Transform(value: IVector3; rotation: IQuaternion): IVector3; overload;
		{ class } function TransformNormal(normal: IVector3; matrix: IMatrix4x4): IVector3;
		{ class } property One: IVector3 read _GetProp_One;
		{ class } property UnitX: IVector3 read _GetProp_UnitX;
		{ class } property UnitY: IVector3 read _GetProp_UnitY;
		{ class } property UnitZ: IVector3 read _GetProp_UnitZ;
		{ class } property Zero: IVector3 read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_VECTOR3)]
	IVector3 = interface(IValueType)
	['{02EBEE15-716F-4B67-A4FD-16B0E7D160C9}']
	{ private }
		function _GetFld_X: Single;
		procedure _SetFld_X(Value: Single);
		function _GetFld_Y: Single;
		procedure _SetFld_Y(Value: Single);
		function _GetFld_Z: Single;
		procedure _SetFld_Z(Value: Single);
	{ public }
		procedure CopyTo(array_: TArray<Single>); overload;
		procedure CopyTo(array_: TArray<Single>; index: Integer); overload;
		function Equals(other: IVector3): Boolean;
		function Length(): Single;
		function LengthSquared(): Single;
		function ToString(format: String): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		property X: Single read _GetFld_X write _SetFld_X;
		property Y: Single read _GetFld_Y write _SetFld_Y;
		property Z: Single read _GetFld_Z write _SetFld_Z;
	end;

	IVector4Class = interface(ICoreClrClass)
	['{F3D63B47-3C15-4819-93E0-FDDEC05A85D4}']
	{ private }
		{ class } function _GetProp_One: IVector4;
		{ class } function _GetProp_UnitW: IVector4;
		{ class } function _GetProp_UnitX: IVector4;
		{ class } function _GetProp_UnitY: IVector4;
		{ class } function _GetProp_UnitZ: IVector4;
		{ class } function _GetProp_Zero: IVector4;
	{ public }
		{ class } function Abs(value: IVector4): IVector4;
		{ class } function Add(left: IVector4; right: IVector4): IVector4;
		{ class } function Clamp(value1: IVector4; min: IVector4; max: IVector4): IVector4;
		{ class } function Distance(value1: IVector4; value2: IVector4): Single;
		{ class } function DistanceSquared(value1: IVector4; value2: IVector4): Single;
		{ class } function Divide(left: IVector4; right: IVector4): IVector4; overload;
		{ class } function Divide(left: IVector4; divisor: Single): IVector4; overload;
		{ class } function Dot(vector1: IVector4; vector2: IVector4): Single;
		{ class } function Lerp(value1: IVector4; value2: IVector4; amount: Single): IVector4;
		{ class } function Max(value1: IVector4; value2: IVector4): IVector4;
		{ class } function Min(value1: IVector4; value2: IVector4): IVector4;
		{ class } function Multiply(left: IVector4; right: IVector4): IVector4; overload;
		{ class } function Multiply(left: IVector4; right: Single): IVector4; overload;
		{ class } function Multiply(left: Single; right: IVector4): IVector4; overload;
		{ class } function Negate(value: IVector4): IVector4;
		{ class } function Normalize(vector: IVector4): IVector4;
		{ class } function SquareRoot(value: IVector4): IVector4;
		{ class } function Subtract(left: IVector4; right: IVector4): IVector4;
		{ class } function Transform(position: IVector2; matrix: IMatrix4x4): IVector4; overload;
		{ class } function Transform(position: IVector3; matrix: IMatrix4x4): IVector4; overload;
		{ class } function Transform(vector: IVector4; matrix: IMatrix4x4): IVector4; overload;
		{ class } function Transform(value: IVector2; rotation: IQuaternion): IVector4; overload;
		{ class } function Transform(value: IVector3; rotation: IQuaternion): IVector4; overload;
		{ class } function Transform(value: IVector4; rotation: IQuaternion): IVector4; overload;
		{ class } property One: IVector4 read _GetProp_One;
		{ class } property UnitW: IVector4 read _GetProp_UnitW;
		{ class } property UnitX: IVector4 read _GetProp_UnitX;
		{ class } property UnitY: IVector4 read _GetProp_UnitY;
		{ class } property UnitZ: IVector4 read _GetProp_UnitZ;
		{ class } property Zero: IVector4 read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_NUMERICS_VECTOR4)]
	IVector4 = interface(IValueType)
	['{720647B2-DD2E-42CC-A9A4-67AE717EB292}']
	{ private }
		function _GetFld_W: Single;
		procedure _SetFld_W(Value: Single);
		function _GetFld_X: Single;
		procedure _SetFld_X(Value: Single);
		function _GetFld_Y: Single;
		procedure _SetFld_Y(Value: Single);
		function _GetFld_Z: Single;
		procedure _SetFld_Z(Value: Single);
	{ public }
		procedure CopyTo(array_: TArray<Single>); overload;
		procedure CopyTo(array_: TArray<Single>; index: Integer); overload;
		function Equals(other: IVector4): Boolean;
		function Length(): Single;
		function LengthSquared(): Single;
		function ToString(format: String): String; overload;
		function ToString(format: String; formatProvider: IIFormatProvider): String; overload;
		property W: Single read _GetFld_W write _SetFld_W;
		property X: Single read _GetFld_X write _SetFld_X;
		property Y: Single read _GetFld_Y write _SetFld_Y;
		property Z: Single read _GetFld_Z write _SetFld_Z;
	end;

	IVector64Class = interface(ICoreClrClass)
	['{9E108CA9-C844-47E2-A40D-D97292A75BDC}']
	{ public }
		{ class } function &As(T: PTypeInfo; U: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Variant{U}>;
		{ class } function AsByte(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Byte>;
		{ class } function AsDouble(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Double>;
		{ class } function AsInt16(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<SmallInt>;
		{ class } function AsInt32(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Integer>;
		{ class } function AsInt64(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Int64>;
		{ class } function AsSByte(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Shortint>;
		{ class } function AsSingle(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Single>;
		{ class } function AsUInt16(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<Word>;
		{ class } function AsUInt32(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<longword>;
		{ class } function AsUInt64(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector64<UInt64>;
		{ class } function Create(value: Byte): IVector64<Byte>; overload;
		{ class } function Create(value: Double): IVector64<Double>; overload;
		{ class } function Create(value: SmallInt): IVector64<SmallInt>; overload;
		{ class } function Create(value: Integer): IVector64<Integer>; overload;
		{ class } function Create(value: Int64): IVector64<Int64>; overload;
		{ class } function Create(value: Shortint): IVector64<Shortint>; overload;
		{ class } function Create(value: Single): IVector64<Single>; overload;
		{ class } function Create(value: Word): IVector64<Word>; overload;
		{ class } function Create(value: longword): IVector64<longword>; overload;
		{ class } function Create(value: UInt64): IVector64<UInt64>; overload;
		{ class } function Create(e0: Byte; e1: Byte; e2: Byte; e3: Byte; e4: Byte; e5: Byte; e6: Byte; e7: Byte): IVector64<Byte>; overload;
		{ class } function Create(e0: Shortint; e1: Shortint; e2: Shortint; e3: Shortint; e4: Shortint; e5: Shortint; e6: Shortint; e7: Shortint): IVector64<Shortint>; overload;
		{ class } function Create(e0: SmallInt; e1: SmallInt; e2: SmallInt; e3: SmallInt): IVector64<SmallInt>; overload;
		{ class } function Create(e0: Word; e1: Word; e2: Word; e3: Word): IVector64<Word>; overload;
		{ class } function Create(e0: Integer; e1: Integer): IVector64<Integer>; overload;
		{ class } function Create(e0: Single; e1: Single): IVector64<Single>; overload;
		{ class } function Create(e0: longword; e1: longword): IVector64<longword>; overload;
		{ class } function CreateScalar(value: Byte): IVector64<Byte>; overload;
		{ class } function CreateScalar(value: Double): IVector64<Double>; overload;
		{ class } function CreateScalar(value: SmallInt): IVector64<SmallInt>; overload;
		{ class } function CreateScalar(value: Integer): IVector64<Integer>; overload;
		{ class } function CreateScalar(value: Int64): IVector64<Int64>; overload;
		{ class } function CreateScalar(value: Shortint): IVector64<Shortint>; overload;
		{ class } function CreateScalar(value: Single): IVector64<Single>; overload;
		{ class } function CreateScalar(value: Word): IVector64<Word>; overload;
		{ class } function CreateScalar(value: longword): IVector64<longword>; overload;
		{ class } function CreateScalar(value: UInt64): IVector64<UInt64>; overload;
		{ class } function CreateScalarUnsafe(value: Byte): IVector64<Byte>; overload;
		{ class } function CreateScalarUnsafe(value: SmallInt): IVector64<SmallInt>; overload;
		{ class } function CreateScalarUnsafe(value: Integer): IVector64<Integer>; overload;
		{ class } function CreateScalarUnsafe(value: Shortint): IVector64<Shortint>; overload;
		{ class } function CreateScalarUnsafe(value: Single): IVector64<Single>; overload;
		{ class } function CreateScalarUnsafe(value: Word): IVector64<Word>; overload;
		{ class } function CreateScalarUnsafe(value: longword): IVector64<longword>; overload;
		{ class } function GetElement(T: PTypeInfo; vector: IVector64<Variant{T}>; index: Integer): Variant{T};
		{ class } function ToScalar(T: PTypeInfo; vector: IVector64<Variant{T}>): Variant{T};
		{ class } function ToVector128(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector128<Variant{T}>;
		{ class } function ToVector128Unsafe(T: PTypeInfo; vector: IVector64<Variant{T}>): IVector128<Variant{T}>;
		{ class } function WithElement(T: PTypeInfo; vector: IVector64<Variant{T}>; index: Integer; value: Variant{T}): IVector64<Variant{T}>;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR64)]
	IVector64 = interface(IObject)
	['{8CFA5377-C825-49B5-A457-DCA6338F0205}']
	end;

	IVector64Class<T> = interface(ICoreClrClass)
	['{B535DFD3-F2E6-4A24-87A0-910BCDB6FD1B}']
	{ private }
		{ class } function _GetProp_AllBitsSet: IVector64<T>;
		{ class } function _GetProp_Count: Integer;
		{ class } function _GetProp_Zero: IVector64<T>;
	{ public }
		{ class } property AllBitsSet: IVector64<T> read _GetProp_AllBitsSet;
		{ class } property Count: Integer read _GetProp_Count;
		{ class } property Zero: IVector64<T> read _GetProp_Zero;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1)]
	IVector64<T> = interface(IValueType)
	['{121C5019-1526-4BF1-9AC3-793CC9103B6B}']
	{ public }
		function Equals(other: IVector64<T>): Boolean;
	end;

	[CoreTypeSignature(SYSTEM_SECURITY_VERIFICATIONEXCEPTION)]
	IVerificationException = interface(ISystemException)
	['{F0C12272-79E2-4E57-9913-09ACC64AD172}']
	end;

	IVersionClass = interface(ICoreClrClass)
	['{C30526CD-44B7-4921-B6D7-78E18E25F807}']
	{ public }
		{ class } function Parse(input: String): IVersion; overload;
		{ class } function Parse(input: IReadOnlySpan<Char>): IVersion; overload;
		{ class } function TryParse(input: String; var result_: IVersion): Boolean; overload;
		{ class } function TryParse(input: IReadOnlySpan<Char>; var result_: IVersion): Boolean; overload;
	end;

	[CoreTypeSignature(SYSTEM_VERSION)]
	IVersion = interface(IObject)
	['{95E9CA08-619F-4500-8998-34002B8035D1}']
	{ private }
		function _GetProp_Build: Integer;
		function _GetProp_Major: Integer;
		function _GetProp_MajorRevision: SmallInt;
		function _GetProp_Minor: Integer;
		function _GetProp_MinorRevision: SmallInt;
		function _GetProp_Revision: Integer;
	{ public }
		function Clone(): Variant;
		function CompareTo(version: Variant): Integer; overload;
		function CompareTo(value: IVersion): Integer; overload;
		function Equals(obj: IVersion): Boolean;
		function ToString(fieldCount: Integer): String;
		function TryFormat(destination: ISpan<Char>; var charsWritten: Integer): Boolean; overload;
		function TryFormat(destination: ISpan<Char>; fieldCount: Integer; var charsWritten: Integer): Boolean; overload;
		property Build: Integer read _GetProp_Build;
		property Major: Integer read _GetProp_Major;
		property MajorRevision: SmallInt read _GetProp_MajorRevision;
		property Minor: Integer read _GetProp_Minor;
		property MinorRevision: SmallInt read _GetProp_MinorRevision;
		property Revision: Integer read _GetProp_Revision;
	end;

	IVersioningHelperClass = interface(ICoreClrClass)
	['{0B38A7B4-D831-46CE-9FA5-42A1B38F1BA5}']
	{ public }
		{ class } function MakeVersionSafeName(name: String; from: TResourceScope_Set; to_: TResourceScope_Set): String; overload;
		{ class } function MakeVersionSafeName(name: String; from: TResourceScope_Set; to_: TResourceScope_Set; type_: IType): String; overload;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_VERSIONING_VERSIONINGHELPER)]
	IVersioningHelper = interface(IObject)
	['{0EE961E5-C964-4906-911C-6DF9D1FFE4D4}']
	end;

	[CoreTypeSignature(SYSTEM_VOID)]
	IVoid = interface(IValueType)
	['{05F0479E-5539-4D81-807D-BE8262BF385B}']
	end;

	IVolatileClass = interface(ICoreClrClass)
	['{5154C235-F5E8-41E6-A8D2-244CE6628497}']
	{ public }
		{ class } function Read(var location: Boolean): Boolean; overload;
		{ class } function Read(var location: Byte): Byte; overload;
		{ class } function Read(var location: Double): Double; overload;
		{ class } function Read(var location: SmallInt): SmallInt; overload;
		{ class } function Read(var location: Integer): Integer; overload;
		{ class } function Read(var location: Int64): Int64; overload;
		{ class } function Read(var location: IIntPtr): IIntPtr; overload;
		{ class } function Read(var location: Shortint): Shortint; overload;
		{ class } function Read(var location: Single): Single; overload;
		{ class } function Read(var location: Word): Word; overload;
		{ class } function Read(var location: longword): longword; overload;
		{ class } function Read(var location: UInt64): UInt64; overload;
		{ class } function Read(var location: IUIntPtr): IUIntPtr; overload;
		{ class } function Read(T: PTypeInfo; var location: Variant{T}): Variant{T}; overload;
		{ class } procedure Write(var location: Boolean; value: Boolean); overload;
		{ class } procedure Write(var location: Byte; value: Byte); overload;
		{ class } procedure Write(var location: Double; value: Double); overload;
		{ class } procedure Write(var location: SmallInt; value: SmallInt); overload;
		{ class } procedure Write(var location: Integer; value: Integer); overload;
		{ class } procedure Write(var location: Int64; value: Int64); overload;
		{ class } procedure Write(var location: IIntPtr; value: IIntPtr); overload;
		{ class } procedure Write(var location: Shortint; value: Shortint); overload;
		{ class } procedure Write(var location: Single; value: Single); overload;
		{ class } procedure Write(var location: Word; value: Word); overload;
		{ class } procedure Write(var location: longword; value: longword); overload;
		{ class } procedure Write(var location: UInt64; value: UInt64); overload;
		{ class } procedure Write(var location: IUIntPtr; value: IUIntPtr); overload;
		{ class } procedure Write(T: PTypeInfo; var location: Variant{T}; value: Variant{T}); overload;
	end;

	[CoreTypeSignature(SYSTEM_THREADING_VOLATILE)]
	IVolatile = interface(IObject)
	['{17F224DD-5E76-4DD9-B190-7E11036A98AC}']
	end;

	[CoreTypeSignature(SYSTEM_THREADING_WAITHANDLECANNOTBEOPENEDEXCEPTION)]
	IWaitHandleCannotBeOpenedException = interface(IApplicationException)
	['{21CAEA07-114D-4D78-AA98-7CE947D56037}']
	end;

	IWaitHandleExtensionsClass = interface(ICoreClrClass)
	['{8F6FA671-8A31-42FB-8FC0-9E156C20C49B}']
	{ public }
		{ class } function GetSafeWaitHandle(waitHandle: IWaitHandle): ISafeWaitHandle;
		{ class } procedure SetSafeWaitHandle(waitHandle: IWaitHandle; value: ISafeWaitHandle);
	end;

	[CoreTypeSignature(SYSTEM_THREADING_WAITHANDLEEXTENSIONS)]
	IWaitHandleExtensions = interface(IObject)
	['{ACC1BA38-C2E7-4310-A911-46F9732E5F21}']
	end;

	[CoreTypeSignature(SYSTEM_WEAKREFERENCE)]
	IWeakReference = interface(IISerializable)
	['{103124E3-D605-4827-AF6D-7CC78ED07995}']
	{ private }
		function _GetProp_IsAlive: Boolean;
		function _GetProp_Target: Variant;
		procedure _SetProp_Target(Value: Variant);
		function _GetProp_TrackResurrection: Boolean;
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		property IsAlive: Boolean read _GetProp_IsAlive;
		property Target: Variant read _GetProp_Target write _SetProp_Target;
		property TrackResurrection: Boolean read _GetProp_TrackResurrection;
	end;

	[CoreTypeSignature(SYSTEM_WEAKREFERENCE_1)]
	IWeakReference<T> = interface(IISerializable)
	['{A69C08D8-6307-4E0F-A304-CD99B7171373}']
	{ public }
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure SetTarget(target: T);
		function TryGetTarget(var target: T): Boolean;
	end;

	IWebUtilityClass = interface(ICoreClrClass)
	['{CF5C5BF0-CC37-4FB3-AEB0-1B26B2C919E5}']
	{ public }
		{ class } function HtmlDecode(value: String): String; overload;
		{ class } procedure HtmlDecode(value: String; output: ITextWriter); overload;
		{ class } function HtmlEncode(value: String): String; overload;
		{ class } procedure HtmlEncode(value: String; output: ITextWriter); overload;
		{ class } function UrlDecode(encodedValue: String): String;
		{ class } function UrlDecodeToBytes(encodedValue: TArray<Byte>; offset: Integer; count: Integer): TArray<Byte>;
		{ class } function UrlEncode(value: String): String;
		{ class } function UrlEncodeToBytes(value: TArray<Byte>; offset: Integer; count: Integer): TArray<Byte>;
	end;

	[CoreTypeSignature(SYSTEM_NET_WEBUTILITY)]
	IWebUtility = interface(IObject)
	['{54856E0A-AFBE-433C-BD9A-576303D256D1}']
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_YIELDAWAITABLE)]
	IYieldAwaitable = interface(IValueType)
	['{A6DF3705-9D96-4179-A592-F02A577AB2CB}']
	{ public }
		function GetAwaiter(): IYieldAwaiter;
	end;

	[CoreTypeSignature(SYSTEM_RUNTIME_COMPILERSERVICES_YIELDAWAITER)]
	IYieldAwaiter = interface(IValueType)
	['{47E64B91-E3CA-4FE3-A9C5-C963540DAFF5}']
	{ private }
		function _GetProp_IsCompleted: Boolean;
	{ public }
		procedure GetResult();
		procedure OnCompleted(continuation: TClrAction);
		procedure UnsafeOnCompleted(continuation: TClrAction);
		property IsCompleted: Boolean read _GetProp_IsCompleted;
	end;

	IHashSetClass<T> = interface(ICoreClrClass)
	['{A08ED54F-5665-4117-B646-A39D125DBAD0}']
	{ public }
		{ class } function CreateSetComparer(): IIEqualityComparer<IHashSet<T>>;
	end;

	[CoreTypeSignature(SYSTEM_COLLECTIONS_GENERIC_HASHSET_1)]
	IHashSet<T> = interface(IObject)
	['{B824F7F0-C1B4-47CB-96B5-41A4708CEA26}']
	{ private }
		function _GetProp_Comparer: IIEqualityComparer<T>;
		function _GetProp_Count: Integer;
	{ public }
		function Add(item: T): Boolean;
		procedure Clear();
		function Contains(item: T): Boolean;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>); overload;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; arrayIndex: Integer); overload;
		procedure CopyTo(array_: ICoreClrBridgeArray<T>; arrayIndex: Integer; count: Integer); overload;
		function EnsureCapacity(capacity: Integer): Integer;
		procedure ExceptWith(other: IIEnumerable<T>);
		function GetEnumerator(): IHashSet_Enumerator<T>;
		procedure GetObjectData(info: ISerializationInfo; context: IStreamingContext);
		procedure IntersectWith(other: IIEnumerable<T>);
		function IsProperSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsProperSupersetOf(other: IIEnumerable<T>): Boolean;
		function IsSubsetOf(other: IIEnumerable<T>): Boolean;
		function IsSupersetOf(other: IIEnumerable<T>): Boolean;
		procedure OnDeserialization(sender: Variant);
		function Overlaps(other: IIEnumerable<T>): Boolean;
		function Remove(item: T): Boolean;
		function RemoveWhere(match: TClrPredicate<T>): Integer;
		function SetEquals(other: IIEnumerable<T>): Boolean;
		procedure SymmetricExceptWith(other: IIEnumerable<T>);
		procedure TrimExcess();
		function TryGetValue(equalValue: T; var actualValue: T): Boolean;
		procedure UnionWith(other: IIEnumerable<T>);
		property Comparer: IIEqualityComparer<T> read _GetProp_Comparer;
		property Count: Integer read _GetProp_Count;
	end;

implementation

procedure RegisterTypes;
begin
	TRegGenericTypes.RegisterTypeNames('TComparison<T1>', SYSTEM_COMPARISON_1, True);
	TRegGenericTypes.RegisterTypeNames('TConverter<T1,T2>', SYSTEM_CONVERTER_2, True);
	TRegGenericTypes.RegisterTypeNames('TAsyncCallback', SYSTEM_ASYNCCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TContextCallback', SYSTEM_THREADING_CONTEXTCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TCreateValueCallback<T1,T2>', SYSTEM_RUNTIME_COMPILERSERVICES_CREATEVALUECALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TTypeFilter', SYSTEM_REFLECTION_TYPEFILTER, True);
	TRegGenericTypes.RegisterTypeNames('TDllImportResolver', SYSTEM_RUNTIME_INTEROPSERVICES_DLLIMPORTRESOLVER, True);
	TRegGenericTypes.RegisterTypeNames('TIOCompletionCallback', SYSTEM_THREADING_IOCOMPLETIONCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TTryCode', SYSTEM_RUNTIME_COMPILERSERVICES_TRYCODE, True);
	TRegGenericTypes.RegisterTypeNames('TCleanupCode', SYSTEM_RUNTIME_COMPILERSERVICES_CLEANUPCODE, True);
	TRegGenericTypes.RegisterTypeNames('TSpanAction<T1,T2>', SYSTEM_BUFFERS_SPANACTION_2, True);
	TRegGenericTypes.RegisterTypeNames('TSendOrPostCallback', SYSTEM_THREADING_SENDORPOSTCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TThreadStart', SYSTEM_THREADING_THREADSTART, True);
	TRegGenericTypes.RegisterTypeNames('TParameterizedThreadStart', SYSTEM_THREADING_PARAMETERIZEDTHREADSTART, True);
	TRegGenericTypes.RegisterTypeNames('TWaitCallback', SYSTEM_THREADING_WAITCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TWaitOrTimerCallback', SYSTEM_THREADING_WAITORTIMERCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TTimerCallback', SYSTEM_THREADING_TIMERCALLBACK, True);
	TRegGenericTypes.RegisterTypeNames('TMemberFilter', SYSTEM_REFLECTION_MEMBERFILTER, True);
	TRegGenericTypes.RegisterTypeNames('TEventHandler<T1>', SYSTEM_EVENTHANDLER_1, True);
	TRegGenericTypes.RegisterTypeNames('TEventHandler', SYSTEM_EVENTHANDLER, True);
	TRegGenericTypes.RegisterTypeNames('TUnhandledExceptionEventHandler', SYSTEM_UNHANDLEDEXCEPTIONEVENTHANDLER, True);
	TRegGenericTypes.RegisterTypeNames('TAssemblyLoadEventHandler', SYSTEM_ASSEMBLYLOADEVENTHANDLER, True);
	TRegGenericTypes.RegisterTypeNames('TResolveEventHandler', SYSTEM_RESOLVEEVENTHANDLER, True);
	TRegGenericTypes.RegisterTypeNames('TModuleResolveEventHandler', SYSTEM_REFLECTION_MODULERESOLVEEVENTHANDLER, True);
	TRegGenericTypes.RegisterTypeNames('IArrayPool<T1>', SYSTEM_BUFFERS_ARRAYPOOL_1);
	TRegGenericTypes.RegisterTypeNames('IArraySegment<T1>', SYSTEM_ARRAYSEGMENT_1);
	TRegGenericTypes.RegisterTypeNames('IArraySegment_Enumerator<T1>', SYSTEM_ENUMERATOR);
	TRegGenericTypes.RegisterTypeNames('IAsyncLocal<T1>', SYSTEM_THREADING_ASYNCLOCAL_1);
	TRegGenericTypes.RegisterTypeNames('IAsyncLocalValueChangedArgs<T1>', SYSTEM_THREADING_ASYNCLOCALVALUECHANGEDARGS_1);
	TRegGenericTypes.RegisterTypeNames('IAsyncTaskMethodBuilder<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCTASKMETHODBUILDER_1);
	TRegGenericTypes.RegisterTypeNames('IAsyncValueTaskMethodBuilder<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_ASYNCVALUETASKMETHODBUILDER_1);
	TRegGenericTypes.RegisterTypeNames('IEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_EQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('ICollection<T1>', SYSTEM_COLLECTIONS_OBJECTMODEL_COLLECTION_1);
	TRegGenericTypes.RegisterTypeNames('IComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_COMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IConcurrentQueue<T1>', SYSTEM_COLLECTIONS_CONCURRENT_CONCURRENTQUEUE_1);
	TRegGenericTypes.RegisterTypeNames('IConditionalWeakTable<T1,T2>', SYSTEM_RUNTIME_COMPILERSERVICES_CONDITIONALWEAKTABLE_2);
	TRegGenericTypes.RegisterTypeNames('IConfiguredCancelableAsyncEnumerable<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDCANCELABLEASYNCENUMERABLE_1);
	TRegGenericTypes.RegisterTypeNames('IConfiguredCancelableAsyncEnumerable_Enumerator<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_ENUMERATOR);
	TRegGenericTypes.RegisterTypeNames('IConfiguredTaskAwaitable<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITABLE_1);
	TRegGenericTypes.RegisterTypeNames('IConfiguredTaskAwaitable_ConfiguredTaskAwaiter<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDTASKAWAITER_2);
	TRegGenericTypes.RegisterTypeNames('IConfiguredValueTaskAwaitable<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITABLE_1);
	TRegGenericTypes.RegisterTypeNames('IConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITER_2);
	TRegGenericTypes.RegisterTypeNames('IDictionary<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_DICTIONARY_2);
	TRegGenericTypes.RegisterTypeNames('IDictionary_Enumerator<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR);
	TRegGenericTypes.RegisterTypeNames('IDictionary_KeyCollection<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_KEYCOLLECTION);
	TRegGenericTypes.RegisterTypeNames('IKeyCollection_Enumerator<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_2);
	TRegGenericTypes.RegisterTypeNames('IDictionary_ValueCollection<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_VALUECOLLECTION);
	TRegGenericTypes.RegisterTypeNames('IValueCollection_Enumerator<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_3);
	TRegGenericTypes.RegisterTypeNames('IEnumEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_ENUMEQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IHashSet_Enumerator<T1>', SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_4);
	TRegGenericTypes.RegisterTypeNames('IList_Enumerator<T1>', SYSTEM_COLLECTIONS_GENERIC_ENUMERATOR_5);
	TRegGenericTypes.RegisterTypeNames('IReadOnlySpan_Enumerator<T1>', SYSTEM_ENUMERATOR_2);
	TRegGenericTypes.RegisterTypeNames('ISpan_Enumerator<T1>', SYSTEM_ENUMERATOR_3);
	TRegGenericTypes.RegisterTypeNames('IIEquatable<T1>', SYSTEM_IEQUATABLE_1);
	TRegGenericTypes.RegisterTypeNames('IGenericComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_GENERICCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IGenericEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_GENERICEQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IIAsyncEnumerable<T1>', SYSTEM_COLLECTIONS_GENERIC_IASYNCENUMERABLE_1);
	TRegGenericTypes.RegisterTypeNames('IIAsyncEnumerator<T1>', SYSTEM_COLLECTIONS_GENERIC_IASYNCENUMERATOR_1);
	TRegGenericTypes.RegisterTypeNames('IICollection<T1>', SYSTEM_COLLECTIONS_GENERIC_ICOLLECTION_1);
	TRegGenericTypes.RegisterTypeNames('IIComparable<T1>', SYSTEM_ICOMPARABLE_1);
	TRegGenericTypes.RegisterTypeNames('IIComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_ICOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IIDictionary<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_IDICTIONARY_2);
	TRegGenericTypes.RegisterTypeNames('IIEnumerable<T1>', SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1);
	TRegGenericTypes.RegisterTypeNames('IIEnumerator<T1>', SYSTEM_COLLECTIONS_GENERIC_IENUMERATOR_1);
	TRegGenericTypes.RegisterTypeNames('IIEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_IEQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IIList<T1>', SYSTEM_COLLECTIONS_GENERIC_ILIST_1);
	TRegGenericTypes.RegisterTypeNames('IIMemoryOwner<T1>', SYSTEM_BUFFERS_IMEMORYOWNER_1);
	TRegGenericTypes.RegisterTypeNames('IIObservable<T1>', SYSTEM_IOBSERVABLE_1);
	TRegGenericTypes.RegisterTypeNames('IIObserver<T1>', SYSTEM_IOBSERVER_1);
	TRegGenericTypes.RegisterTypeNames('IIProducerConsumerCollection<T1>', SYSTEM_COLLECTIONS_CONCURRENT_IPRODUCERCONSUMERCOLLECTION_1);
	TRegGenericTypes.RegisterTypeNames('IIProgress<T1>', SYSTEM_IPROGRESS_1);
	TRegGenericTypes.RegisterTypeNames('IIReadOnlyCollection<T1>', SYSTEM_COLLECTIONS_GENERIC_IREADONLYCOLLECTION_1);
	TRegGenericTypes.RegisterTypeNames('IIReadOnlyDictionary<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_IREADONLYDICTIONARY_2);
	TRegGenericTypes.RegisterTypeNames('IIReadOnlyList<T1>', SYSTEM_COLLECTIONS_GENERIC_IREADONLYLIST_1);
	TRegGenericTypes.RegisterTypeNames('IIReadOnlySet<T1>', SYSTEM_COLLECTIONS_GENERIC_IREADONLYSET_1);
	TRegGenericTypes.RegisterTypeNames('IISet<T1>', SYSTEM_COLLECTIONS_GENERIC_ISET_1);
	TRegGenericTypes.RegisterTypeNames('IIValueTaskSource<T1>', SYSTEM_THREADING_TASKS_SOURCES_IVALUETASKSOURCE_1);
	TRegGenericTypes.RegisterTypeNames('IKeyValuePair<T1,T2>', SYSTEM_COLLECTIONS_GENERIC_KEYVALUEPAIR_2);
	TRegGenericTypes.RegisterTypeNames('ILazy<T1>', SYSTEM_LAZY_1);
	TRegGenericTypes.RegisterTypeNames('ILazy<T1,T2>', SYSTEM_LAZY_2);
	TRegGenericTypes.RegisterTypeNames('IList<T1>', SYSTEM_COLLECTIONS_GENERIC_LIST_1);
	TRegGenericTypes.RegisterTypeNames('IManualResetValueTaskSourceCore<T1>', SYSTEM_THREADING_TASKS_SOURCES_MANUALRESETVALUETASKSOURCECORE_1);
	TRegGenericTypes.RegisterTypeNames('IMemory<T1>', SYSTEM_MEMORY_1);
	TRegGenericTypes.RegisterTypeNames('IMemoryManager<T1>', SYSTEM_BUFFERS_MEMORYMANAGER_1);
	TRegGenericTypes.RegisterTypeNames('INullable<T1>', SYSTEM_NULLABLE_1);
	TRegGenericTypes.RegisterTypeNames('INullableComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_NULLABLECOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('INullableEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_NULLABLEEQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IObjectComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_OBJECTCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IObjectEqualityComparer<T1>', SYSTEM_COLLECTIONS_GENERIC_OBJECTEQUALITYCOMPARER_1);
	TRegGenericTypes.RegisterTypeNames('IProgress<T1>', SYSTEM_PROGRESS_1);
	TRegGenericTypes.RegisterTypeNames('IReadOnlyCollection<T1>', SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1);
	TRegGenericTypes.RegisterTypeNames('IReadOnlyMemory<T1>', SYSTEM_READONLYMEMORY_1);
	TRegGenericTypes.RegisterTypeNames('IReadOnlySpan<T1>', SYSTEM_READONLYSPAN_1);
	TRegGenericTypes.RegisterTypeNames('ISpan<T1>', SYSTEM_SPAN_1);
	TRegGenericTypes.RegisterTypeNames('IStrongBox<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_STRONGBOX_1);
	TRegGenericTypes.RegisterTypeNames('ITask<T1>', SYSTEM_THREADING_TASKS_TASK_1);
	TRegGenericTypes.RegisterTypeNames('ITaskAwaiter<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_TASKAWAITER_1);
	TRegGenericTypes.RegisterTypeNames('ITaskCompletionSource<T1>', SYSTEM_THREADING_TASKS_TASKCOMPLETIONSOURCE_1);
	TRegGenericTypes.RegisterTypeNames('ITaskFactory<T1>', SYSTEM_THREADING_TASKS_TASKFACTORY_1);
	TRegGenericTypes.RegisterTypeNames('IThreadLocal<T1>', SYSTEM_THREADING_THREADLOCAL_1);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1>', SYSTEM_TUPLE_1);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2>', SYSTEM_TUPLE_2);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3>', SYSTEM_TUPLE_3);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3,T4>', SYSTEM_TUPLE_4);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3,T4,T5>', SYSTEM_TUPLE_5);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3,T4,T5,T6>', SYSTEM_TUPLE_6);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3,T4,T5,T6,T7>', SYSTEM_TUPLE_7);
	TRegGenericTypes.RegisterTypeNames('ITuple<T1,T2,T3,T4,T5,T6,T7,T8>', SYSTEM_TUPLE_8);
	TRegGenericTypes.RegisterTypeNames('IValueTask<T1>', SYSTEM_THREADING_TASKS_VALUETASK_1);
	TRegGenericTypes.RegisterTypeNames('IValueTaskAwaiter<T1>', SYSTEM_RUNTIME_COMPILERSERVICES_VALUETASKAWAITER_1);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1>', SYSTEM_VALUETUPLE_1);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2>', SYSTEM_VALUETUPLE_2);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3>', SYSTEM_VALUETUPLE_3);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3,T4>', SYSTEM_VALUETUPLE_4);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3,T4,T5>', SYSTEM_VALUETUPLE_5);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3,T4,T5,T6>', SYSTEM_VALUETUPLE_6);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3,T4,T5,T6,T7>', SYSTEM_VALUETUPLE_7);
	TRegGenericTypes.RegisterTypeNames('IValueTuple<T1,T2,T3,T4,T5,T6,T7,T8>', SYSTEM_VALUETUPLE_8);
	TRegGenericTypes.RegisterTypeNames('IVector<T1>', SYSTEM_NUMERICS_VECTOR_1);
	TRegGenericTypes.RegisterTypeNames('IVector128<T1>', SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1);
	TRegGenericTypes.RegisterTypeNames('IVector256<T1>', SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1);
	TRegGenericTypes.RegisterTypeNames('IVector64<T1>', SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1);
	TRegGenericTypes.RegisterTypeNames('IWeakReference<T1>', SYSTEM_WEAKREFERENCE_1);
	TRegGenericTypes.RegisterTypeNames('IHashSet<T1>', SYSTEM_COLLECTIONS_GENERIC_HASHSET_1);
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IException>), TypeInfo(TCoreClrBridgeArray<IException>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IAssembly>), TypeInfo(TCoreClrBridgeArray<IAssembly>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IType>), TypeInfo(TCoreClrBridgeArray<IType>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IFileStream>), TypeInfo(TCoreClrBridgeArray<IFileStream>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IModule>), TypeInfo(TCoreClrBridgeArray<IModule>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IAssemblyName>), TypeInfo(TCoreClrBridgeArray<IAssemblyName>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IAttribute>), TypeInfo(TCoreClrBridgeArray<IAttribute>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IFieldInfo>), TypeInfo(TCoreClrBridgeArray<IFieldInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IMethodBase>), TypeInfo(TCoreClrBridgeArray<IMethodBase>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IParameterModifier>), TypeInfo(TCoreClrBridgeArray<IParameterModifier>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IPropertyInfo>), TypeInfo(TCoreClrBridgeArray<IPropertyInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ICancellationToken>), TypeInfo(TCoreClrBridgeArray<ICancellationToken>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IParameterInfo>), TypeInfo(TCoreClrBridgeArray<IParameterInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ICultureInfo>), TypeInfo(TCoreClrBridgeArray<ICultureInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ICalendar>), TypeInfo(TCoreClrBridgeArray<ICalendar>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IDelegate>), TypeInfo(TCoreClrBridgeArray<IDelegate>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IEncodingInfo>), TypeInfo(TCoreClrBridgeArray<IEncodingInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IConstructorInfo>), TypeInfo(TCoreClrBridgeArray<IConstructorInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IEventInfo>), TypeInfo(TCoreClrBridgeArray<IEventInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IMemberInfo>), TypeInfo(TCoreClrBridgeArray<IMemberInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IMethodInfo>), TypeInfo(TCoreClrBridgeArray<IMethodInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IIConnectionPoint>), TypeInfo(TCoreClrBridgeArray<IIConnectionPoint>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ICONNECTDATA>), TypeInfo(TCoreClrBridgeArray<ICONNECTDATA>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IIMoniker>), TypeInfo(TCoreClrBridgeArray<IIMoniker>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ILabel>), TypeInfo(TCoreClrBridgeArray<ILabel>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IITypeInfo>), TypeInfo(TCoreClrBridgeArray<IITypeInfo>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IIntPtr>), TypeInfo(TCoreClrBridgeArray<IIntPtr>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IGenericTypeParameterBuilder>), TypeInfo(TCoreClrBridgeArray<IGenericTypeParameterBuilder>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ICoreClrBridgeArray<IType>>), TypeInfo(TCoreClrBridgeArray<ICoreClrBridgeArray<IType>>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IRuntimeTypeHandle>), TypeInfo(TCoreClrBridgeArray<IRuntimeTypeHandle>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IStackFrame>), TypeInfo(TCoreClrBridgeArray<IStackFrame>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ITask>), TypeInfo(TCoreClrBridgeArray<ITask>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IAdjustmentRule>), TypeInfo(TCoreClrBridgeArray<IAdjustmentRule>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<ITimeSpan>), TypeInfo(TCoreClrBridgeArray<ITimeSpan>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<IWaitHandle>), TypeInfo(TCoreClrBridgeArray<IWaitHandle>));
	TRegTypes.RegisterType(TypeInfo(ICoreClrBridgeArray<Variant{TOutput}>), TypeInfo(TCoreClrBridgeArray<Variant{TOutput}>));
	TRegTypes.RegisterType(TypeInfo(IVector64<SmallInt>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_2);
	TRegTypes.RegisterType(TypeInfo(IVector64<Integer>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_3);
	TRegTypes.RegisterType(TypeInfo(IVector64<Shortint>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_4);
	TRegTypes.RegisterType(TypeInfo(IVector64<Single>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_5);
	TRegTypes.RegisterType(TypeInfo(IVector128<SmallInt>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_2);
	TRegTypes.RegisterType(TypeInfo(IVector128<Integer>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_3);
	TRegTypes.RegisterType(TypeInfo(IVector128<Shortint>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_4);
	TRegTypes.RegisterType(TypeInfo(IVector128<Single>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_5);
	TRegTypes.RegisterType(TypeInfo(IVector64<Byte>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_6);
	TRegTypes.RegisterType(TypeInfo(IVector64<Word>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_7);
	TRegTypes.RegisterType(TypeInfo(IVector64<longword>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_8);
	TRegTypes.RegisterType(TypeInfo(IVector128<Byte>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_6);
	TRegTypes.RegisterType(TypeInfo(IVector128<Word>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_7);
	TRegTypes.RegisterType(TypeInfo(IVector128<longword>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_8);
	TRegTypes.RegisterType(TypeInfo(IVector128<Int64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_9);
	TRegTypes.RegisterType(TypeInfo(IVector128<UInt64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_10);
	TRegTypes.RegisterType(TypeInfo(IVector64<Double>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_9);
	TRegTypes.RegisterType(TypeInfo(IVector64<Int64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_10);
	TRegTypes.RegisterType(TypeInfo(IVector64<UInt64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR64_1_11);
	TRegTypes.RegisterType(TypeInfo(IVector128<Double>), SYSTEM_RUNTIME_INTRINSICS_VECTOR128_1_11);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IException>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_2);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyCollection<IException>), SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1_2);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<IException, Boolean>), SYSTEM_FUNC_2);
	TRegTypes.RegisterType(TypeInfo(IReadOnlySpan<Char>), SYSTEM_READONLYSPAN_1_2);
	TRegTypes.RegisterType(TypeInfo(ISpan<Byte>), SYSTEM_SPAN_1_2);
	TRegTypes.RegisterType(TypeInfo(IReadOnlySpan<Byte>), SYSTEM_READONLYSPAN_1_3);
	TRegTypes.RegisterType(TypeInfo(ISpan<Char>), SYSTEM_SPAN_1_3);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<ICustomAttributeData>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_3);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<ITypeInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_4);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IType>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_5);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IModule>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_6);
	TRegTypes.RegisterType(TypeInfo(IIList<ICustomAttributeData>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_2);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<ICustomAttributeBuilder>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_7);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IAssemblyLoadContext>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_8);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IAssembly>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_9);
	TRegTypes.RegisterType(TypeInfo(IVector256<Single>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_2);
	TRegTypes.RegisterType(TypeInfo(IVector256<Double>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_3);
	TRegTypes.RegisterType(TypeInfo(IVector256<Byte>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_4);
	TRegTypes.RegisterType(TypeInfo(IVector256<Shortint>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_5);
	TRegTypes.RegisterType(TypeInfo(IVector256<SmallInt>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_6);
	TRegTypes.RegisterType(TypeInfo(IVector256<Word>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_7);
	TRegTypes.RegisterType(TypeInfo(IVector256<Integer>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_8);
	TRegTypes.RegisterType(TypeInfo(IVector256<longword>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_9);
	TRegTypes.RegisterType(TypeInfo(IVector256<Int64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_10);
	TRegTypes.RegisterType(TypeInfo(IVector256<UInt64>), SYSTEM_RUNTIME_INTRINSICS_VECTOR256_1_11);
	TRegTypes.RegisterType(TypeInfo(ITask<Integer>), SYSTEM_THREADING_TASKS_TASK_1_2);
	TRegTypes.RegisterType(TypeInfo(IValueTask<Integer>), SYSTEM_THREADING_TASKS_VALUETASK_1_2);
	TRegTypes.RegisterType(TypeInfo(IMemory<Byte>), SYSTEM_MEMORY_1_2);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyMemory<Byte>), SYSTEM_READONLYMEMORY_1_2);
	TRegTypes.RegisterType(TypeInfo(TClrAction<Variant>), SYSTEM_ACTION_1);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyMemory<Char>), SYSTEM_READONLYMEMORY_1_3);
	TRegTypes.RegisterType(TypeInfo(IConfiguredValueTaskAwaitable<Boolean>), SYSTEM_RUNTIME_COMPILERSERVICES_CONFIGUREDVALUETASKAWAITABLE_1_2);
	TRegTypes.RegisterType(TypeInfo(TClrPredicate<Integer>), SYSTEM_PREDICATE_1);
	TRegTypes.RegisterType(TypeInfo(IIList<ICustomAttributeTypedArgument>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_3);
	TRegTypes.RegisterType(TypeInfo(IIList<ICustomAttributeNamedArgument>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_4);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IAttribute>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_10);
	TRegTypes.RegisterType(TypeInfo(ISpan<Integer>), SYSTEM_SPAN_1_4);
	TRegTypes.RegisterType(TypeInfo(IReadOnlySpan<Integer>), SYSTEM_READONLYSPAN_1_4);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IEncodingInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_11);
	TRegTypes.RegisterType(TypeInfo(IIDictionary<String, String>), SYSTEM_COLLECTIONS_GENERIC_IDICTIONARY_2_2);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IEventSource>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_12);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyCollection<Variant>), SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1_3);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyCollection<String>), SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1_4);
	TRegTypes.RegisterType(TypeInfo(IReadOnlySpan<IGCGenerationInfo>), SYSTEM_READONLYSPAN_1_5);
	TRegTypes.RegisterType(TypeInfo(IReadOnlySpan<ITimeSpan>), SYSTEM_READONLYSPAN_1_6);
	TRegTypes.RegisterType(TypeInfo(IValueTask<Boolean>), SYSTEM_THREADING_TASKS_VALUETASK_1_3);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<Double>), SYSTEM_FUNC_1);
	TRegTypes.RegisterType(TypeInfo(IMemory<Char>), SYSTEM_MEMORY_1_3);
	TRegTypes.RegisterType(TypeInfo(IArraySegment<Byte>), SYSTEM_ARRAYSEGMENT_1_2);
	TRegTypes.RegisterType(TypeInfo(IIList<IExceptionHandlingClause>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_5);
	TRegTypes.RegisterType(TypeInfo(IIList<ILocalVariableInfo>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_6);
	TRegTypes.RegisterType(TypeInfo(IList<Integer>), SYSTEM_COLLECTIONS_GENERIC_LIST_1_2);
	TRegTypes.RegisterType(TypeInfo(IIEqualityComparer<String>), SYSTEM_COLLECTIONS_GENERIC_IEQUALITYCOMPARER_1_2);
	TRegTypes.RegisterType(TypeInfo(IValueTuple<Integer, Integer>), SYSTEM_VALUETUPLE_2_2);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IEventInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_13);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IFieldInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_14);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IMethodInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_15);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IPropertyInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_16);
	TRegTypes.RegisterType(TypeInfo(ITask<Boolean>), SYSTEM_THREADING_TASKS_TASK_1_3);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<Boolean>), SYSTEM_FUNC_1_2);
	TRegTypes.RegisterType(TypeInfo(ITask<String>), SYSTEM_THREADING_TASKS_TASK_1_4);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<String>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_17);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<ITask>), SYSTEM_FUNC_1_3);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<ITask>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_18);
	TRegTypes.RegisterType(TypeInfo(ITask<ITask>), SYSTEM_THREADING_TASKS_TASK_1_5);
	TRegTypes.RegisterType(TypeInfo(TClrAction<ITask>), SYSTEM_ACTION_1_2);
	TRegTypes.RegisterType(TypeInfo(TClrAction<ITask, Variant>), SYSTEM_ACTION_2);
	TRegTypes.RegisterType(TypeInfo(TClrAction<ICoreClrBridgeArray<ITask>>), SYSTEM_ACTION_1_3);
	TRegTypes.RegisterType(TypeInfo(TClrAction<IIAsyncResult>), SYSTEM_ACTION_1_4);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<TAsyncCallback, Variant, IIAsyncResult>), SYSTEM_FUNC_3);
	TRegTypes.RegisterType(TypeInfo(IReadOnlyCollection<ITimeZoneInfo>), SYSTEM_COLLECTIONS_OBJECTMODEL_READONLYCOLLECTION_1_5);
	TRegTypes.RegisterType(TypeInfo(IIList<String>), SYSTEM_COLLECTIONS_GENERIC_ILIST_1_7);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<IAssemblyName, IAssembly>), SYSTEM_FUNC_2_2);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<IAssembly, String, Boolean, IType>), SYSTEM_FUNC_4);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IConstructorInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_19);
	TRegTypes.RegisterType(TypeInfo(IIEnumerable<IMemberInfo>), SYSTEM_COLLECTIONS_GENERIC_IENUMERABLE_1_20);
	TRegTypes.RegisterType(TypeInfo(IVector<Single>), SYSTEM_NUMERICS_VECTOR_1_2);
	TRegTypes.RegisterType(TypeInfo(IVector<Double>), SYSTEM_NUMERICS_VECTOR_1_3);
	TRegTypes.RegisterType(TypeInfo(IVector<Integer>), SYSTEM_NUMERICS_VECTOR_1_4);
	TRegTypes.RegisterType(TypeInfo(IVector<Int64>), SYSTEM_NUMERICS_VECTOR_1_5);
	TRegTypes.RegisterType(TypeInfo(IVector<UInt64>), SYSTEM_NUMERICS_VECTOR_1_6);
	TRegTypes.RegisterType(TypeInfo(IVector<longword>), SYSTEM_NUMERICS_VECTOR_1_7);
	TRegTypes.RegisterType(TypeInfo(IVector<Word>), SYSTEM_NUMERICS_VECTOR_1_8);
	TRegTypes.RegisterType(TypeInfo(IVector<SmallInt>), SYSTEM_NUMERICS_VECTOR_1_9);
	TRegTypes.RegisterType(TypeInfo(IVector<Byte>), SYSTEM_NUMERICS_VECTOR_1_10);
	TRegTypes.RegisterType(TypeInfo(IVector<Shortint>), SYSTEM_NUMERICS_VECTOR_1_11);
	TRegTypes.RegisterType(TypeInfo(IValueTuple<Integer, Integer, Integer, Integer>), SYSTEM_VALUETUPLE_4_2);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<IAssemblyLoadContext, IAssemblyName, IAssembly>), SYSTEM_FUNC_3_2);
	TRegTypes.RegisterType(TypeInfo(TClrFunc<IAssembly, String, IIntPtr>), SYSTEM_FUNC_3_3);
	TRegTypes.RegisterType(TypeInfo(TClrAction<IAssemblyLoadContext>), SYSTEM_ACTION_1_5);
end;

initialization
	RegisterTypes;

end.

